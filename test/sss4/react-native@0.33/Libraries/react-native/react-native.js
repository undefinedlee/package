loader.define("react-native@0.33/Libraries/react-native/react-native.js", ["react-native@0.33/__fbjs__/lib/warning.js", "react-native@0.33/Libraries/Utilities/Alert.js", "react-native@0.33/Libraries/Utilities/AlertIOS.js", "react-native@0.33/Libraries/AppState/AppState.js", "react-native@0.33/Libraries/Components/Keyboard/Keyboard.js", "react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js", "react-native@0.33/Libraries/Components/StatusBar/StatusBarIOS.ios.js", "react-native@0.33/Libraries/Utilities/Systrace.js", "react-native@0.33/Libraries/Utilities/UIManager.js", "react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js", "react-native@0.33/Libraries/EventEmitter/RCTNativeAppEventEmitter.js", "react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js", "react-native@0.33/Libraries/Utilities/Platform.ios.js", "react-native@0.33/Libraries/StyleSheet/processColor.js", "react-native@0.33/__react__/lib/ReactUpdates.js", "react-native@0.33/__react__/lib/ReactPropTypeLocationNames.js", "react-native@0.33/Libraries/StyleSheet/normalizeColor.js", "react-native@0.33/__react__/lib/reactProdInvariant.js", "react-native@0.33/lib/UIManager.js", "react-native@0.33/__react__/lib/findNodeHandle.js", "react-native@0.33/__fbjs__/lib/invariant.js", "react-native@0.33/__react__/lib/ReactNativePropRegistry.js", "react-native@0.33/Libraries/StyleSheet/flattenStyle.js", "react-native@0.33/__react__/lib/ReactElement.js", "react-native@0.33/__react__/lib/ReactPropTypesSecret.js", "react-native@0.33/__fbjs__/lib/emptyFunction.js", "object-assign@4/index.js", "react-native@0.33/__react__/lib/PooledClass.js", "react-native@0.33/__react__/lib/ReactCurrentOwner.js", "react-native@0.33/__react__/lib/canDefineProperty.js", "react-native@0.33/__fbjs__/lib/emptyObject.js", "react-native@0.33/__react__/lib/ReactPropTypeLocations.js", "react-native@0.33/__fbjs__/lib/keyMirror.js", "react-native@0.33/__react__/lib/ReactComponentTreeHook.js", "react-native@0.33/__react__/lib/checkReactTypeSpec.js", "react-native@0.33/Libraries/Utilities/stringifySafe.js", "react-native@0.33/__react__/lib/ReactNativeComponentTree.js", "react-native@0.33/__react__/lib/ReactNativeTagHandles.js", "react-native@0.33/__react__/lib/ReactErrorUtils.js", "react-native@0.33/__react__/lib/ReactComponentEnvironment.js", "react-native@0.33/__react__/lib/ReactInstanceMap.js", "react-native@0.33/__react__/lib/ReactInstrumentation.js", "react-native@0.33/__react__/lib/ReactReconciler.js", "react-native@0.33/__react__/lib/instantiateReactComponent.js", "react-native@0.33/__react__/lib/shouldUpdateReactComponent.js", "art@0.10/core/color.js", "art@0.10/core/transform.js", "art@0.10/core/class.js", "art@0.10/core/path.js", "react-timer-mixin@0.13/TimerMixin.js", "react-clone-referenced-element@1/cloneReferencedElement.js", "react-native@0.33/__react__/lib/ReactNativeMount.js", "react-native@0.33/__react__/lib/ReactEmptyComponent.js", "react-native@0.33/__react__/lib/ReactHostComponent.js", "react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/InitializeJavaScriptAppEngine.js", "react-native@0.33/Libraries/BatchedBridge/BatchedBridge.js", "react-native@0.33/__react__/lib/Transaction.js", "react-native@0.33/__react__/lib/CallbackQueue.js", "react-native@0.33/__react__/lib/ReactUpdateQueue.js", "rebound@0.0.13/rebound.js", "react-native@0.33/Libraries/EventEmitter/EventEmitter.js", "react-native@0.33/Libraries/vendor/core/Set.js", "immutable@3/dist/immutable.js", "react-native@0.33/Libraries/vendor/core/guid.js", "react-native@0.33/Libraries/Utilities/logError.js", "react-native@0.33/Libraries/vendor/core/Map.js", "react-native@0.33/Libraries/Fetch/fetch.js", "react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/getDevServer.js", "react-native@0.33/Libraries/Utilities/PerformanceLogger.js", "base64-js@0.0.8/lib/b64.js", "react-native@0.33/Libraries/Network/XMLHttpRequest.js", "react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/parseErrorStack.js", "react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/symbolicateStackTrace.js", "react-native@0.33/__react__/lib/ReactDebugTool.js", "react-native@0.33/__fbjs__/lib/performanceNow.js", "react-native@0.33/__fbjs__/lib/shallowEqual.js", "react-native@0.33/Libraries/react-native/react-native.js", "react@15.3/react.js", "react-native@0.33/__react__/lib/ReactCompositeComponent.js", "react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js", "react-native@0.33/__fbjs__/lib/isNode.js", "react-native@0.33/__react__/lib/ReactFeatureFlags.js", "react-native@0.33/__react__/lib/ReactNodeTypes.js"], function (require, global, __project, __filename, __dirname, __base, __pixel_ratio) {

	return [
	// Libraries/react-native/react-native.js
	function (__inner_require__, exports, module) {
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		if (__DEV__) {
			var warningDedupe = {};
			var addonWarn = function addonWarn(prevName, newPackageName) {
				warning(warningDedupe[prevName], 'React.addons.' + prevName + ' is deprecated. Please import the "' + newPackageName + '" package instead.');

				warningDedupe[prevName] = true;
			};
		}

		var ReactNative = {

			get ActivityIndicator() {
				return __inner_require__(1 /*Libraries/Components/ActivityIndicator/ActivityIndicator.js*/);
			},
			get ActivityIndicatorIOS() {
				return __inner_require__(76 /*Libraries/Components/ActivityIndicator/ActivityIndicatorIOS.ios.js*/);
			},
			get ART() {
				return __inner_require__(77 /*Libraries/ART/ReactNativeART.js*/);
			},
			get DatePickerIOS() {
				return __inner_require__(79 /*Libraries/Components/DatePicker/DatePickerIOS.ios.js*/);
			},
			get DrawerLayoutAndroid() {
				return __inner_require__(80 /*Libraries/Components/DrawerAndroid/DrawerLayoutAndroid.ios.js*/);
			},
			get Image() {
				return __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
			},
			get ImageEditor() {
				return __inner_require__(83 /*Libraries/Image/ImageEditor.js*/);
			},
			get ImageStore() {
				return __inner_require__(84 /*Libraries/Image/ImageStore.js*/);
			},
			get KeyboardAvoidingView() {
				return __inner_require__(85 /*Libraries/Components/Keyboard/KeyboardAvoidingView.js*/);
			},
			get ListView() {
				return __inner_require__(87 /*Libraries/CustomComponents/ListView/ListView.js*/);
			},
			get MapView() {
				return __inner_require__(119 /*Libraries/Components/MapView/MapView.js*/);
			},
			get Modal() {
				return __inner_require__(120 /*Libraries/Modal/Modal.js*/);
			},
			get Navigator() {
				return __inner_require__(122 /*Libraries/CustomComponents/Navigator/Navigator.js*/);
			},
			get NavigatorIOS() {
				return __inner_require__(141 /*Libraries/Components/Navigation/NavigatorIOS.ios.js*/);
			},
			get Picker() {
				return __inner_require__(143 /*Libraries/Components/Picker/Picker.js*/);
			},
			get PickerIOS() {
				return __inner_require__(144 /*Libraries/Components/Picker/PickerIOS.ios.js*/);
			},
			get ProgressBarAndroid() {
				return __inner_require__(146 /*Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.ios.js*/);
			},
			get ProgressViewIOS() {
				return __inner_require__(147 /*Libraries/Components/ProgressViewIOS/ProgressViewIOS.ios.js*/);
			},
			get ScrollView() {
				return __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
			},
			get SegmentedControlIOS() {
				return __inner_require__(148 /*Libraries/Components/SegmentedControlIOS/SegmentedControlIOS.ios.js*/);
			},
			get Slider() {
				return __inner_require__(149 /*Libraries/Components/Slider/Slider.js*/);
			},
			get SliderIOS() {
				return __inner_require__(150 /*Libraries/Components/SliderIOS/SliderIOS.ios.js*/);
			},
			get SnapshotViewIOS() {
				return __inner_require__(151 /*Libraries/RCTTest/SnapshotViewIOS.ios.js*/);
			},
			get Switch() {
				return __inner_require__(152 /*Libraries/Components/Switch/Switch.js*/);
			},
			get RecyclerViewBackedScrollView() {
				return __inner_require__(153 /*Libraries/Components/ScrollView/RecyclerViewBackedScrollView.ios.js*/);
			},
			get RefreshControl() {
				return __inner_require__(154 /*Libraries/Components/RefreshControl/RefreshControl.js*/);
			},
			get StatusBar() {
				return __inner_require__(155 /*Libraries/Components/StatusBar/StatusBar.js*/);
			},
			get SwipeableListView() {
				return __inner_require__(156 /*Libraries/Experimental/SwipeableRow/SwipeableListView.js*/);
			},
			get SwitchAndroid() {
				return __inner_require__(174 /*Libraries/Components/SwitchAndroid/SwitchAndroid.ios.js*/);
			},
			get SwitchIOS() {
				return __inner_require__(175 /*Libraries/Components/SwitchIOS/SwitchIOS.ios.js*/);
			},
			get TabBarIOS() {
				return __inner_require__(176 /*Libraries/Components/TabBarIOS/TabBarIOS.ios.js*/);
			},
			get Text() {
				return __inner_require__(168 /*Libraries/Text/Text.js*/);
			},
			get TextInput() {
				return __inner_require__(178 /*Libraries/Components/TextInput/TextInput.js*/);
			},
			get ToastAndroid() {
				return __inner_require__(187 /*Libraries/Components/ToastAndroid/ToastAndroid.ios.js*/);
			},
			get ToolbarAndroid() {
				return __inner_require__(188 /*Libraries/Components/ToolbarAndroid/ToolbarAndroid.ios.js*/);
			},
			get Touchable() {
				return __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
			},
			get TouchableHighlight() {
				return __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
			},
			get TouchableNativeFeedback() {
				return __inner_require__(191 /*Libraries/Components/Touchable/TouchableNativeFeedback.ios.js*/);
			},
			get TouchableOpacity() {
				return __inner_require__(192 /*Libraries/Components/Touchable/TouchableOpacity.js*/);
			},
			get TouchableWithoutFeedback() {
				return __inner_require__(185 /*Libraries/Components/Touchable/TouchableWithoutFeedback.js*/);
			},
			get View() {
				return __inner_require__(38 /*Libraries/Components/View/View.js*/);
			},
			get ViewPagerAndroid() {
				return __inner_require__(193 /*Libraries/Components/ViewPager/ViewPagerAndroid.ios.js*/);
			},
			get WebView() {
				return __inner_require__(194 /*Libraries/Components/WebView/WebView.ios.js*/);
			},

			get ActionSheetIOS() {
				return __inner_require__(195 /*Libraries/ActionSheetIOS/ActionSheetIOS.js*/);
			},
			get AdSupportIOS() {
				return __inner_require__(196 /*Libraries/AdSupport/AdSupportIOS.js*/);
			},
			get Alert() {
				return require('react-native@0.33/Libraries/Utilities/Alert.js');
			},
			get AlertIOS() {
				return require('react-native@0.33/Libraries/Utilities/AlertIOS.js');
			},
			get Animated() {
				return __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
			},
			get AppRegistry() {
				return __inner_require__(197 /*Libraries/AppRegistry/AppRegistry.js*/);
			},
			get AppState() {
				return require('react-native@0.33/Libraries/AppState/AppState.js');
			},
			get AppStateIOS() {
				return __inner_require__(223 /*Libraries/AppState/AppStateIOS.js*/);
			},
			get AsyncStorage() {
				return __inner_require__(224 /*Libraries/Storage/AsyncStorage.js*/);
			},
			get BackAndroid() {
				return __inner_require__(220 /*Libraries/Utilities/BackAndroid.ios.js*/);
			},
			get CameraRoll() {
				return __inner_require__(225 /*Libraries/CameraRoll/CameraRoll.js*/);
			},
			get Clipboard() {
				return __inner_require__(226 /*Libraries/Components/Clipboard/Clipboard.js*/);
			},
			get DatePickerAndroid() {
				return __inner_require__(228 /*Libraries/Components/DatePickerAndroid/DatePickerAndroid.ios.js*/);
			},
			get Dimensions() {
				return __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
			},
			get Easing() {
				return __inner_require__(166 /*Libraries/Animated/src/Easing.js*/);
			},
			get I18nManager() {
				return __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);
			},
			get ImagePickerIOS() {
				return __inner_require__(229 /*Libraries/CameraRoll/ImagePickerIOS.js*/);
			},
			get IntentAndroid() {
				return __inner_require__(230 /*Libraries/Components/Intent/IntentAndroid.ios.js*/);
			},
			get InteractionManager() {
				return __inner_require__(124 /*Libraries/Interaction/InteractionManager.js*/);
			},
			get Keyboard() {
				return require('react-native@0.33/Libraries/Components/Keyboard/Keyboard.js');
			},
			get LayoutAnimation() {
				return __inner_require__(86 /*Libraries/LayoutAnimation/LayoutAnimation.js*/);
			},
			get Linking() {
				return __inner_require__(231 /*Libraries/Linking/Linking.js*/);
			},
			get LinkingIOS() {
				return __inner_require__(232 /*Libraries/LinkingIOS/LinkingIOS.js*/);
			},
			get NativeEventEmitter() {
				return require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');
			},
			get NavigationExperimental() {
				return __inner_require__(233 /*Libraries/NavigationExperimental/NavigationExperimental.js*/);
			},
			get NetInfo() {
				return __inner_require__(253 /*Libraries/Network/NetInfo.js*/);
			},
			get PanResponder() {
				return __inner_require__(138 /*Libraries/Interaction/PanResponder.js*/);
			},
			get PermissionsAndroid() {
				return __inner_require__(254 /*Libraries/PermissionsAndroid/PermissionsAndroid.js*/);
			},
			get PixelRatio() {
				return __inner_require__(27 /*Libraries/Utilities/PixelRatio.js*/);
			},
			get PushNotificationIOS() {
				return __inner_require__(255 /*Libraries/PushNotificationIOS/PushNotificationIOS.js*/);
			},
			get Settings() {
				return __inner_require__(256 /*Libraries/Settings/Settings.ios.js*/);
			},
			get Share() {
				return __inner_require__(257 /*Libraries/Share/Share.js*/);
			},
			get StatusBarIOS() {
				return require('react-native@0.33/Libraries/Components/StatusBar/StatusBarIOS.ios.js');
			},
			get StyleSheet() {
				return __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
			},
			get Systrace() {
				return require('react-native@0.33/Libraries/Utilities/Systrace.js');
			},
			get TimePickerAndroid() {
				return __inner_require__(258 /*Libraries/Components/TimePickerAndroid/TimePickerAndroid.ios.js*/);
			},
			get UIManager() {
				return require('react-native@0.33/Libraries/Utilities/UIManager.js');
			},
			get Vibration() {
				return __inner_require__(259 /*Libraries/Vibration/Vibration.js*/);
			},
			get VibrationIOS() {
				return __inner_require__(260 /*Libraries/Vibration/VibrationIOS.ios.js*/);
			},

			get DeviceEventEmitter() {
				return require('react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js');
			},
			get NativeAppEventEmitter() {
				return require('react-native@0.33/Libraries/EventEmitter/RCTNativeAppEventEmitter.js');
			},
			get NativeModules() {
				return require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js');
			},
			get Platform() {
				return require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
			},
			get processColor() {
				return require('react-native@0.33/Libraries/StyleSheet/processColor.js');
			},
			get requireNativeComponent() {
				return __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);
			},

			get ColorPropType() {
				return __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
			},
			get EdgeInsetsPropType() {
				return __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
			},
			get PointPropType() {
				return __inner_require__(113 /*Libraries/StyleSheet/PointPropType.js*/);
			},

			addons: {
				get LinkedStateMixin() {
					if (__DEV__) {
						addonWarn('LinkedStateMixin', 'react-addons-linked-state-mixin');
					}
					return __inner_require__(261 /*__react__/lib/LinkedStateMixin.js*/);
				},
				Perf: undefined,
				get PureRenderMixin() {
					if (__DEV__) {
						addonWarn('PureRenderMixin', 'react-addons-pure-render-mixin');
					}
					return __inner_require__(250 /*__react__/lib/ReactComponentWithPureRenderMixin.js*/);
				},
				get TestModule() {
					if (__DEV__) {
						warning(warningDedupe.TestModule, 'React.addons.TestModule is deprecated. ' + 'Use ReactNative.NativeModules.TestModule instead.');

						warningDedupe.TestModule = true;
					}
					return require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').TestModule;
				},
				TestUtils: undefined,
				get batchedUpdates() {
					if (__DEV__) {
						warning(warningDedupe.batchedUpdates, 'React.addons.batchedUpdates is deprecated. ' + 'Use ReactNative.unstable_batchedUpdates instead.');

						warningDedupe.batchedUpdates = true;
					}
					return require('react-native@0.33/__react__/lib/ReactUpdates.js').batchedUpdates;
				},
				get createFragment() {
					if (__DEV__) {
						addonWarn('createFragment', 'react-addons-create-fragment');
					}
					return __inner_require__(264 /*__react__/lib/ReactFragment.js*/).create;
				},
				get update() {
					if (__DEV__) {
						addonWarn('update', 'react-addons-update');
					}
					return __inner_require__(265 /*__react__/lib/update.js*/);
				} } };

		if (__DEV__) {
			(function () {
				var throwOnWrongReactAPI = __inner_require__(266 /*Libraries/Utilities/throwOnWrongReactAPI.js*/);
				var reactAPIs = ['createClass', 'Component'];var _loop = function _loop(key) {
					Object.defineProperty(ReactNative, key, {
						get: function get() {
							throwOnWrongReactAPI(key);
						},
						enumerable: false,
						configurable: false });
				};for (var _iterator = reactAPIs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
					var _ref;if (_isArray) {
						if (_i >= _iterator.length) break;_ref = _iterator[_i++];
					} else {
						_i = _iterator.next();if (_i.done) break;_ref = _i.value;
					}var key = _ref;_loop(key);
				}
			})();
		}

		var ReactNativeInternal = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		function applyForwarding(key) {
			if (__DEV__) {
				Object.defineProperty(ReactNative, key, Object.getOwnPropertyDescriptor(ReactNativeInternal, key));

				return;
			}
			ReactNative[key] = ReactNativeInternal[key];
		}
		for (var key in ReactNativeInternal) {
			applyForwarding(key);
		}

		if (__DEV__) {
			Object.defineProperty(ReactNative.addons, 'Perf', {
				enumerable: true,
				get: function get() {
					if (__DEV__) {
						addonWarn('Perf', 'react-addons-perf');
					}
					return __inner_require__(222 /*__react__/lib/ReactPerf.js*/);
				} });

			Object.defineProperty(ReactNative.addons, 'TestUtils', {
				enumerable: true,
				get: function get() {
					if (__DEV__) {
						addonWarn('update', 'react-addons-test-utils');
					}
					return __inner_require__(267 /*__react__/lib/ReactTestUtils.js*/);
				} });
		}

		module.exports = ReactNative;
	}, // Libraries/Components/ActivityIndicator/ActivityIndicator.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var GRAY = '#999999';

		var ActivityIndicator = React.createClass({ displayName: 'ActivityIndicator',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				animating: PropTypes.bool,

				color: ColorPropType,

				size: PropTypes.oneOfType([PropTypes.oneOf(['small', 'large']), PropTypes.number]),

				hidesWhenStopped: PropTypes.bool }),

			getDefaultProps: function getDefaultProps() {
				return {
					animating: true,
					color: Platform.OS === 'ios' ? GRAY : undefined,
					hidesWhenStopped: true,
					size: 'small' };
			},

			render: function render() {
				var _props = this.props,
				    onLayout = _props.onLayout,
				    style = _props.style,
				    props = babelHelpers.objectWithoutProperties(_props, ['onLayout', 'style']);
				var sizeStyle = void 0;

				switch (props.size) {
					case 'small':
						sizeStyle = styles.sizeSmall;
						break;
					case 'large':
						sizeStyle = styles.sizeLarge;
						break;
					default:
						sizeStyle = { height: props.size, width: props.size };
						break;}

				return React.createElement(View, {
					onLayout: onLayout,
					style: [styles.container, style] }, React.createElement(RCTActivityIndicator, babelHelpers.extends({}, props, {
					style: sizeStyle,
					styleAttr: 'Normal',
					indeterminate: true })));
			} });

		var styles = StyleSheet.create({
			container: {
				alignItems: 'center',
				justifyContent: 'center' },

			sizeSmall: {
				width: 20,
				height: 20 },

			sizeLarge: {
				width: 36,
				height: 36 } });

		if (Platform.OS === 'ios') {
			var RCTActivityIndicator = requireNativeComponent('RCTActivityIndicatorView', ActivityIndicator, { nativeOnly: { activityIndicatorViewStyle: true } });
		} else if (Platform.OS === 'android') {
			var RCTActivityIndicator = requireNativeComponent('AndroidProgressBar', ActivityIndicator, { nativeOnly: {
					indeterminate: true,
					progress: true,
					styleAttr: true } });
		}

		module.exports = ActivityIndicator;
	}, // Libraries/StyleSheet/ColorPropType.js
	function (__inner_require__, exports, module) {
		var ReactPropTypeLocationNames = require('react-native@0.33/__react__/lib/ReactPropTypeLocationNames.js');

		var normalizeColor = require('react-native@0.33/Libraries/StyleSheet/normalizeColor.js');

		var colorPropType = function colorPropType(isRequired, props, propName, componentName, location, propFullName) {
			var color = props[propName];
			if (color === undefined || color === null) {
				if (isRequired) {
					var locationName = ReactPropTypeLocationNames[location];
					return new Error('Required ' + locationName + ' `' + (propFullName || propName) + '` was not specified in `' + componentName + '`.');
				}
				return;
			}

			if (typeof color === 'number') {

				return;
			}

			if (normalizeColor(color) === null) {
				var locationName = ReactPropTypeLocationNames[location];
				return new Error('Invalid ' + locationName + ' `' + (propFullName || propName) + '` supplied to `' + componentName + '`: ' + color + '\n' + 'Valid color formats are\n  - \'#f0f\' (#rgb)\n  - \'#f0fc\' (#rgba)\n  - \'#ff00ff\' (#rrggbb)\n  - \'#ff00ff00\' (#rrggbbaa)\n  - \'rgb(255, 255, 255)\'\n  - \'rgba(255, 255, 255, 1.0)\'\n  - \'hsl(360, 100%, 100%)\'\n  - \'hsla(360, 100%, 100%, 1.0)\'\n  - \'transparent\'\n  - \'red\'\n  - 0xff00ff00 (0xrrggbbaa)\n');
			}
		};

		var ColorPropType = colorPropType.bind(null, false);
		ColorPropType.isRequired = colorPropType.bind(null, true);

		module.exports = ColorPropType;
	}, // __react__/lib/NativeMethodsMixin.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactNativeAttributePayload = __inner_require__(4 /*__react__/lib/ReactNativeAttributePayload.js*/);
		var TextInputState = __inner_require__(8 /*lib/TextInputState.js*/);
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var findNodeHandle = require('react-native@0.33/__react__/lib/findNodeHandle.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function warnForStyleProps(props, validAttributes) {
			for (var key in validAttributes.style) {
				if (!(validAttributes[key] || props[key] === undefined)) {
					console.error('You are setting the style `{ ' + key + ': ... }` as a prop. You ' + 'should nest it in a style object. ' + 'E.g. `{ style: { ' + key + ': ... } }`');
				}
			}
		}

		var NativeMethodsMixin = {

			measure: function measure(callback) {
				UIManager.measure(findNodeHandle(this), mountSafeCallback(this, callback));
			},

			measureInWindow: function measureInWindow(callback) {
				UIManager.measureInWindow(findNodeHandle(this), mountSafeCallback(this, callback));
			},

			measureLayout: function measureLayout(relativeToNativeNode, onSuccess, onFail) {
				UIManager.measureLayout(findNodeHandle(this), relativeToNativeNode, mountSafeCallback(this, onFail), mountSafeCallback(this, onSuccess));
			},

			setNativeProps: function setNativeProps(nativeProps) {
				if (process.env.NODE_ENV !== 'production') {
					warnForStyleProps(nativeProps, this.viewConfig.validAttributes);
				}

				var updatePayload = ReactNativeAttributePayload.create(nativeProps, this.viewConfig.validAttributes);

				UIManager.updateView(findNodeHandle(this), this.viewConfig.uiViewClassName, updatePayload);
			},

			focus: function focus() {
				TextInputState.focusTextInput(findNodeHandle(this));
			},

			blur: function blur() {
				TextInputState.blurTextInput(findNodeHandle(this));
			} };

		function throwOnStylesProp(component, props) {
			if (props.styles !== undefined) {
				var owner = component._owner || null;
				var name = component.constructor.displayName;
				var msg = '`styles` is not a supported property of `' + name + '`, did ' + 'you mean `style` (singular)?';
				if (owner && owner.constructor && owner.constructor.displayName) {
					msg += '\n\nCheck the `' + owner.constructor.displayName + '` parent ' + ' component.';
				}
				throw new Error(msg);
			}
		}
		if (process.env.NODE_ENV !== 'production') {

			var NativeMethodsMixin_DEV = NativeMethodsMixin;
			!(!NativeMethodsMixin_DEV.componentWillMount && !NativeMethodsMixin_DEV.componentWillReceiveProps) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Do not override existing functions.') : _prodInvariant('16') : void 0;
			NativeMethodsMixin_DEV.componentWillMount = function () {
				throwOnStylesProp(this, this.props);
			};
			NativeMethodsMixin_DEV.componentWillReceiveProps = function (newProps) {
				throwOnStylesProp(this, newProps);
			};
		}

		function mountSafeCallback(context, callback) {
			return function () {
				if (!callback || context.isMounted && !context.isMounted()) {
					return undefined;
				}
				return callback.apply(context, arguments);
			};
		}

		module.exports = NativeMethodsMixin;
	}, // __react__/lib/ReactNativeAttributePayload.js
	function (__inner_require__, exports, module) {
		var ReactNativePropRegistry = require('react-native@0.33/__react__/lib/ReactNativePropRegistry.js');

		var deepDiffer = __inner_require__(5 /*lib/deepDiffer.js*/);
		var flattenStyle = __inner_require__(7 /*lib/flattenStyle.js*/);

		var emptyObject = {};

		var removedKeys = null;
		var removedKeyCount = 0;

		function defaultDiffer(prevProp, nextProp) {
			if (typeof nextProp !== 'object' || nextProp === null) {

				return true;
			} else {

				return deepDiffer(prevProp, nextProp);
			}
		}

		function resolveObject(idOrObject) {
			if (typeof idOrObject === 'number') {
				return ReactNativePropRegistry.getByID(idOrObject);
			}
			return idOrObject;
		}

		function restoreDeletedValuesInNestedArray(updatePayload, node, validAttributes) {
			if (Array.isArray(node)) {
				var i = node.length;
				while (i-- && removedKeyCount > 0) {
					restoreDeletedValuesInNestedArray(updatePayload, node[i], validAttributes);
				}
			} else if (node && removedKeyCount > 0) {
				var obj = resolveObject(node);
				for (var propKey in removedKeys) {
					if (!removedKeys[propKey]) {
						continue;
					}
					var nextProp = obj[propKey];
					if (nextProp === undefined) {
						continue;
					}

					var attributeConfig = validAttributes[propKey];
					if (!attributeConfig) {
						continue;
					}

					if (typeof nextProp === 'function') {
						nextProp = true;
					}
					if (typeof nextProp === 'undefined') {
						nextProp = null;
					}

					if (typeof attributeConfig !== 'object') {

						updatePayload[propKey] = nextProp;
					} else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {

						var nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;
						updatePayload[propKey] = nextValue;
					}
					removedKeys[propKey] = false;
					removedKeyCount--;
				}
			}
		}

		function diffNestedArrayProperty(updatePayload, prevArray, nextArray, validAttributes) {
			var minLength = prevArray.length < nextArray.length ? prevArray.length : nextArray.length;
			var i;
			for (i = 0; i < minLength; i++) {

				updatePayload = diffNestedProperty(updatePayload, prevArray[i], nextArray[i], validAttributes);
			}
			for (; i < prevArray.length; i++) {

				updatePayload = clearNestedProperty(updatePayload, prevArray[i], validAttributes);
			}
			for (; i < nextArray.length; i++) {

				updatePayload = addNestedProperty(updatePayload, nextArray[i], validAttributes);
			}
			return updatePayload;
		}

		function diffNestedProperty(updatePayload, prevProp, nextProp, validAttributes) {

			if (!updatePayload && prevProp === nextProp) {

				return updatePayload;
			}

			if (!prevProp || !nextProp) {
				if (nextProp) {
					return addNestedProperty(updatePayload, nextProp, validAttributes);
				}
				if (prevProp) {
					return clearNestedProperty(updatePayload, prevProp, validAttributes);
				}
				return updatePayload;
			}

			if (!Array.isArray(prevProp) && !Array.isArray(nextProp)) {

				return diffProperties(updatePayload, resolveObject(prevProp), resolveObject(nextProp), validAttributes);
			}

			if (Array.isArray(prevProp) && Array.isArray(nextProp)) {

				return diffNestedArrayProperty(updatePayload, prevProp, nextProp, validAttributes);
			}

			if (Array.isArray(prevProp)) {
				return diffProperties(updatePayload, flattenStyle(prevProp), resolveObject(nextProp), validAttributes);
			}

			return diffProperties(updatePayload, resolveObject(prevProp), flattenStyle(nextProp), validAttributes);
		}

		function addNestedProperty(updatePayload, nextProp, validAttributes) {
			if (!nextProp) {
				return updatePayload;
			}

			if (!Array.isArray(nextProp)) {

				return addProperties(updatePayload, resolveObject(nextProp), validAttributes);
			}

			for (var i = 0; i < nextProp.length; i++) {

				updatePayload = addNestedProperty(updatePayload, nextProp[i], validAttributes);
			}

			return updatePayload;
		}

		function clearNestedProperty(updatePayload, prevProp, validAttributes) {
			if (!prevProp) {
				return updatePayload;
			}

			if (!Array.isArray(prevProp)) {

				return clearProperties(updatePayload, resolveObject(prevProp), validAttributes);
			}

			for (var i = 0; i < prevProp.length; i++) {

				updatePayload = clearNestedProperty(updatePayload, prevProp[i], validAttributes);
			}
			return updatePayload;
		}

		function diffProperties(updatePayload, prevProps, nextProps, validAttributes) {
			var attributeConfig;
			var nextProp;
			var prevProp;

			for (var propKey in nextProps) {
				attributeConfig = validAttributes[propKey];
				if (!attributeConfig) {
					continue;
				}

				prevProp = prevProps[propKey];
				nextProp = nextProps[propKey];

				if (typeof nextProp === 'function') {
					nextProp = true;

					if (typeof prevProp === 'function') {
						prevProp = true;
					}
				}

				if (typeof nextProp === 'undefined') {
					nextProp = null;
					if (typeof prevProp === 'undefined') {
						prevProp = null;
					}
				}

				if (removedKeys) {
					removedKeys[propKey] = false;
				}

				if (updatePayload && updatePayload[propKey] !== undefined) {

					if (typeof attributeConfig !== 'object') {

						updatePayload[propKey] = nextProp;
					} else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {

						var nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;
						updatePayload[propKey] = nextValue;
					}
					continue;
				}

				if (prevProp === nextProp) {
					continue;
				}

				if (typeof attributeConfig !== 'object') {

					if (defaultDiffer(prevProp, nextProp)) {

						(updatePayload || (updatePayload = {}))[propKey] = nextProp;
					}
				} else if (typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {

					var shouldUpdate = prevProp === undefined || (typeof attributeConfig.diff === 'function' ? attributeConfig.diff(prevProp, nextProp) : defaultDiffer(prevProp, nextProp));
					if (shouldUpdate) {
						nextValue = typeof attributeConfig.process === 'function' ? attributeConfig.process(nextProp) : nextProp;
						(updatePayload || (updatePayload = {}))[propKey] = nextValue;
					}
				} else {

					removedKeys = null;
					removedKeyCount = 0;

					updatePayload = diffNestedProperty(updatePayload, prevProp, nextProp, attributeConfig);
					if (removedKeyCount > 0 && updatePayload) {
						restoreDeletedValuesInNestedArray(updatePayload, nextProp, attributeConfig);
						removedKeys = null;
					}
				}
			}

			for (propKey in prevProps) {
				if (nextProps[propKey] !== undefined) {
					continue;
				}
				attributeConfig = validAttributes[propKey];
				if (!attributeConfig) {
					continue;
				}

				if (updatePayload && updatePayload[propKey] !== undefined) {

					continue;
				}

				prevProp = prevProps[propKey];
				if (prevProp === undefined) {
					continue;
				}

				if (typeof attributeConfig !== 'object' || typeof attributeConfig.diff === 'function' || typeof attributeConfig.process === 'function') {

					(updatePayload || (updatePayload = {}))[propKey] = null;
					if (!removedKeys) {
						removedKeys = {};
					}
					if (!removedKeys[propKey]) {
						removedKeys[propKey] = true;
						removedKeyCount++;
					}
				} else {

					updatePayload = clearNestedProperty(updatePayload, prevProp, attributeConfig);
				}
			}
			return updatePayload;
		}

		function addProperties(updatePayload, props, validAttributes) {

			return diffProperties(updatePayload, emptyObject, props, validAttributes);
		}

		function clearProperties(updatePayload, prevProps, validAttributes) {

			return diffProperties(updatePayload, prevProps, emptyObject, validAttributes);
		}

		var ReactNativeAttributePayload = {

			create: function create(props, validAttributes) {
				return addProperties(null, props, validAttributes);
			},

			diff: function diff(prevProps, nextProps, validAttributes) {
				return diffProperties(null, prevProps, nextProps, validAttributes);
			} };

		module.exports = ReactNativeAttributePayload;
	}, // lib/deepDiffer.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(6 /*Libraries/Utilities/differ/deepDiffer.js*/);
	}, // Libraries/Utilities/differ/deepDiffer.js
	function (__inner_require__, exports, module) {
		var deepDiffer = function deepDiffer(one, two) {
			if (one === two) {

				return false;
			}
			if (typeof one === 'function' && typeof two === 'function') {

				return false;
			}
			if (typeof one !== 'object' || one === null) {

				return one !== two;
			}
			if (typeof two !== 'object' || two === null) {

				return true;
			}
			if (one.constructor !== two.constructor) {
				return true;
			}
			if (Array.isArray(one)) {

				var len = one.length;
				if (two.length !== len) {
					return true;
				}
				for (var ii = 0; ii < len; ii++) {
					if (deepDiffer(one[ii], two[ii])) {
						return true;
					}
				}
			} else {
				for (var key in one) {
					if (deepDiffer(one[key], two[key])) {
						return true;
					}
				}
				for (var twoKey in two) {

					if (one[twoKey] === undefined && two[twoKey] !== undefined) {
						return true;
					}
				}
			}
			return false;
		};

		module.exports = deepDiffer;
	}, // lib/flattenStyle.js
	function (__inner_require__, exports, module) {
		module.exports = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
	}, // lib/TextInputState.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(9 /*Libraries/Components/TextInput/TextInputState.js*/);
	}, // Libraries/Components/TextInput/TextInputState.js
	function (__inner_require__, exports, module) {
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');

		var TextInputState = {

			_currentlyFocusedID: null,

			currentlyFocusedField: function currentlyFocusedField() {
				return this._currentlyFocusedID;
			},

			focusTextInput: function focusTextInput(textFieldID) {
				if (this._currentlyFocusedID !== textFieldID && textFieldID !== null) {
					this._currentlyFocusedID = textFieldID;
					if (Platform.OS === 'ios') {
						UIManager.focus(textFieldID);
					} else if (Platform.OS === 'android') {
						UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.focusTextInput, null);
					}
				}
			},

			blurTextInput: function blurTextInput(textFieldID) {
				if (this._currentlyFocusedID === textFieldID && textFieldID !== null) {
					this._currentlyFocusedID = null;
					if (Platform.OS === 'ios') {
						UIManager.blur(textFieldID);
					} else if (Platform.OS === 'android') {
						UIManager.dispatchViewManagerCommand(textFieldID, UIManager.AndroidTextInput.Commands.blurTextInput, null);
					}
				}
			} };

		module.exports = TextInputState;
	}, // __react__/lib/ReactPropTypes.js
	function (__inner_require__, exports, module) {
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactPropTypeLocationNames = require('react-native@0.33/__react__/lib/ReactPropTypeLocationNames.js');
		var ReactPropTypesSecret = require('react-native@0.33/__react__/lib/ReactPropTypesSecret.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var getIteratorFn = __inner_require__(11 /*__react__/lib/getIteratorFn.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ANONYMOUS = '<<anonymous>>';

		var ReactPropTypes = {
			array: createPrimitiveTypeChecker('array'),
			bool: createPrimitiveTypeChecker('boolean'),
			func: createPrimitiveTypeChecker('function'),
			number: createPrimitiveTypeChecker('number'),
			object: createPrimitiveTypeChecker('object'),
			string: createPrimitiveTypeChecker('string'),
			symbol: createPrimitiveTypeChecker('symbol'),

			any: createAnyTypeChecker(),
			arrayOf: createArrayOfTypeChecker,
			element: createElementTypeChecker(),
			instanceOf: createInstanceTypeChecker,
			node: createNodeChecker(),
			objectOf: createObjectOfTypeChecker,
			oneOf: createEnumTypeChecker,
			oneOfType: createUnionTypeChecker,
			shape: createShapeTypeChecker };

		function is(x, y) {

			if (x === y) {

				return x !== 0 || 1 / x === 1 / y;
			} else {

				return x !== x && y !== y;
			}
		}

		function PropTypeError(message) {
			this.message = message;
			this.stack = '';
		}

		PropTypeError.prototype = Error.prototype;

		function createChainableTypeChecker(validate) {
			if (process.env.NODE_ENV !== 'production') {
				var manualPropTypeCallCache = {};
			}
			function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
				componentName = componentName || ANONYMOUS;
				propFullName = propFullName || propName;
				if (process.env.NODE_ENV !== 'production') {
					if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
						var cacheKey = componentName + ':' + propName;
						if (!manualPropTypeCallCache[cacheKey]) {
							process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in the next major version. You may be ' + 'seeing this warning due to a third-party PropTypes library. ' + 'See https://fb.me/react-warning-dont-call-proptypes for details.', propFullName, componentName) : void 0;
							manualPropTypeCallCache[cacheKey] = true;
						}
					}
				}
				if (props[propName] == null) {
					var locationName = ReactPropTypeLocationNames[location];
					if (isRequired) {
						return new PropTypeError('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
					}
					return null;
				} else {
					return validate(props, propName, componentName, location, propFullName);
				}
			}

			var chainedCheckType = checkType.bind(null, false);
			chainedCheckType.isRequired = checkType.bind(null, true);

			return chainedCheckType;
		}

		function createPrimitiveTypeChecker(expectedType) {
			function validate(props, propName, componentName, location, propFullName, secret) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== expectedType) {
					var locationName = ReactPropTypeLocationNames[location];

					var preciseType = getPreciseType(propValue);

					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createAnyTypeChecker() {
			return createChainableTypeChecker(emptyFunction.thatReturns(null));
		}

		function createArrayOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== 'function') {
					return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
				}
				var propValue = props[propName];
				if (!Array.isArray(propValue)) {
					var locationName = ReactPropTypeLocationNames[location];
					var propType = getPropType(propValue);
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
				}
				for (var i = 0; i < propValue.length; i++) {
					var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
					if (error instanceof Error) {
						return error;
					}
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createElementTypeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				if (!ReactElement.isValidElement(propValue)) {
					var locationName = ReactPropTypeLocationNames[location];
					var propType = getPropType(propValue);
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createInstanceTypeChecker(expectedClass) {
			function validate(props, propName, componentName, location, propFullName) {
				if (!(props[propName] instanceof expectedClass)) {
					var locationName = ReactPropTypeLocationNames[location];
					var expectedClassName = expectedClass.name || ANONYMOUS;
					var actualClassName = getClassName(props[propName]);
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createEnumTypeChecker(expectedValues) {
			if (!Array.isArray(expectedValues)) {
				process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
				return emptyFunction.thatReturnsNull;
			}

			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				for (var i = 0; i < expectedValues.length; i++) {
					if (is(propValue, expectedValues[i])) {
						return null;
					}
				}

				var locationName = ReactPropTypeLocationNames[location];
				var valuesString = JSON.stringify(expectedValues);
				return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
			}
			return createChainableTypeChecker(validate);
		}

		function createObjectOfTypeChecker(typeChecker) {
			function validate(props, propName, componentName, location, propFullName) {
				if (typeof typeChecker !== 'function') {
					return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
				}
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== 'object') {
					var locationName = ReactPropTypeLocationNames[location];
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
				}
				for (var key in propValue) {
					if (propValue.hasOwnProperty(key)) {
						var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
						if (error instanceof Error) {
							return error;
						}
					}
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createUnionTypeChecker(arrayOfTypeCheckers) {
			if (!Array.isArray(arrayOfTypeCheckers)) {
				process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
				return emptyFunction.thatReturnsNull;
			}

			function validate(props, propName, componentName, location, propFullName) {
				for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
					var checker = arrayOfTypeCheckers[i];
					if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
						return null;
					}
				}

				var locationName = ReactPropTypeLocationNames[location];
				return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
			}
			return createChainableTypeChecker(validate);
		}

		function createNodeChecker() {
			function validate(props, propName, componentName, location, propFullName) {
				if (!isNode(props[propName])) {
					var locationName = ReactPropTypeLocationNames[location];
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function createShapeTypeChecker(shapeTypes) {
			function validate(props, propName, componentName, location, propFullName) {
				var propValue = props[propName];
				var propType = getPropType(propValue);
				if (propType !== 'object') {
					var locationName = ReactPropTypeLocationNames[location];
					return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
				}
				for (var key in shapeTypes) {
					var checker = shapeTypes[key];
					if (!checker) {
						continue;
					}
					var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
					if (error) {
						return error;
					}
				}
				return null;
			}
			return createChainableTypeChecker(validate);
		}

		function isNode(propValue) {
			switch (typeof propValue) {
				case 'number':
				case 'string':
				case 'undefined':
					return true;
				case 'boolean':
					return !propValue;
				case 'object':
					if (Array.isArray(propValue)) {
						return propValue.every(isNode);
					}
					if (propValue === null || ReactElement.isValidElement(propValue)) {
						return true;
					}

					var iteratorFn = getIteratorFn(propValue);
					if (iteratorFn) {
						var iterator = iteratorFn.call(propValue);
						var step;
						if (iteratorFn !== propValue.entries) {
							while (!(step = iterator.next()).done) {
								if (!isNode(step.value)) {
									return false;
								}
							}
						} else {

							while (!(step = iterator.next()).done) {
								var entry = step.value;
								if (entry) {
									if (!isNode(entry[1])) {
										return false;
									}
								}
							}
						}
					} else {
						return false;
					}

					return true;
				default:
					return false;}
		}

		function isSymbol(propType, propValue) {

			if (propType === 'symbol') {
				return true;
			}

			if (propValue['@@toStringTag'] === 'Symbol') {
				return true;
			}

			if (typeof Symbol === 'function' && propValue instanceof Symbol) {
				return true;
			}

			return false;
		}

		function getPropType(propValue) {
			var propType = typeof propValue;
			if (Array.isArray(propValue)) {
				return 'array';
			}
			if (propValue instanceof RegExp) {

				return 'object';
			}
			if (isSymbol(propType, propValue)) {
				return 'symbol';
			}
			return propType;
		}

		function getPreciseType(propValue) {
			var propType = getPropType(propValue);
			if (propType === 'object') {
				if (propValue instanceof Date) {
					return 'date';
				} else if (propValue instanceof RegExp) {
					return 'regexp';
				}
			}
			return propType;
		}

		function getClassName(propValue) {
			if (!propValue.constructor || !propValue.constructor.name) {
				return ANONYMOUS;
			}
			return propValue.constructor.name;
		}

		module.exports = ReactPropTypes;
	}, // __react__/lib/getIteratorFn.js
	function (__inner_require__, exports, module) {
		var ITERATOR_SYMBOL = typeof Symbol === 'function' && (typeof Symbol === 'function' ? Symbol.iterator : '@@iterator');
		var FAUX_ITERATOR_SYMBOL = '@@iterator';

		function getIteratorFn(maybeIterable) {
			var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
			if (typeof iteratorFn === 'function') {
				return iteratorFn;
			}
		}

		module.exports = getIteratorFn;
	}, // Libraries/react-native/React.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(13 /*__react__/lib/React.js*/);
	}, // __react__/lib/React.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var ReactChildren = __inner_require__(14 /*__react__/lib/ReactChildren.js*/);
		var ReactComponent = __inner_require__(17 /*__react__/lib/ReactComponent.js*/);
		var ReactPureComponent = __inner_require__(19 /*__react__/lib/ReactPureComponent.js*/);
		var ReactClass = __inner_require__(20 /*__react__/lib/ReactClass.js*/);
		var ReactDOMFactories = __inner_require__(22 /*__react__/lib/ReactDOMFactories.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var ReactVersion = __inner_require__(24 /*__react__/lib/ReactVersion.js*/);

		var onlyChild = __inner_require__(25 /*__react__/lib/onlyChild.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var createElement = ReactElement.createElement;
		var createFactory = ReactElement.createFactory;
		var cloneElement = ReactElement.cloneElement;

		if (process.env.NODE_ENV !== 'production') {
			var ReactElementValidator = __inner_require__(23 /*__react__/lib/ReactElementValidator.js*/);
			createElement = ReactElementValidator.createElement;
			createFactory = ReactElementValidator.createFactory;
			cloneElement = ReactElementValidator.cloneElement;
		}

		var __spread = _assign;

		if (process.env.NODE_ENV !== 'production') {
			var warned = false;
			__spread = function __spread() {
				process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
				warned = true;
				return _assign.apply(null, arguments);
			};
		}

		var React = {

			Children: {
				map: ReactChildren.map,
				forEach: ReactChildren.forEach,
				count: ReactChildren.count,
				toArray: ReactChildren.toArray,
				only: onlyChild },

			Component: ReactComponent,
			PureComponent: ReactPureComponent,

			createElement: createElement,
			cloneElement: cloneElement,
			isValidElement: ReactElement.isValidElement,

			PropTypes: ReactPropTypes,
			createClass: ReactClass.createClass,
			createFactory: createFactory,
			createMixin: function createMixin(mixin) {

				return mixin;
			},

			DOM: ReactDOMFactories,

			version: ReactVersion,

			__spread: __spread };

		module.exports = React;
	}, // __react__/lib/ReactChildren.js
	function (__inner_require__, exports, module) {
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var traverseAllChildren = __inner_require__(15 /*__react__/lib/traverseAllChildren.js*/);

		var twoArgumentPooler = PooledClass.twoArgumentPooler;
		var fourArgumentPooler = PooledClass.fourArgumentPooler;

		var userProvidedKeyEscapeRegex = /\/+/g;
		function escapeUserProvidedKey(text) {
			return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
		}

		function ForEachBookKeeping(forEachFunction, forEachContext) {
			this.func = forEachFunction;
			this.context = forEachContext;
			this.count = 0;
		}
		ForEachBookKeeping.prototype.destructor = function () {
			this.func = null;
			this.context = null;
			this.count = 0;
		};
		PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

		function forEachSingleChild(bookKeeping, child, name) {
			var func = bookKeeping.func;
			var context = bookKeeping.context;

			func.call(context, child, bookKeeping.count++);
		}

		function forEachChildren(children, forEachFunc, forEachContext) {
			if (children == null) {
				return children;
			}
			var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
			traverseAllChildren(children, forEachSingleChild, traverseContext);
			ForEachBookKeeping.release(traverseContext);
		}

		function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
			this.result = mapResult;
			this.keyPrefix = keyPrefix;
			this.func = mapFunction;
			this.context = mapContext;
			this.count = 0;
		}
		MapBookKeeping.prototype.destructor = function () {
			this.result = null;
			this.keyPrefix = null;
			this.func = null;
			this.context = null;
			this.count = 0;
		};
		PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

		function mapSingleChildIntoContext(bookKeeping, child, childKey) {
			var result = bookKeeping.result;
			var keyPrefix = bookKeeping.keyPrefix;
			var func = bookKeeping.func;
			var context = bookKeeping.context;

			var mappedChild = func.call(context, child, bookKeeping.count++);
			if (Array.isArray(mappedChild)) {
				mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
			} else if (mappedChild != null) {
				if (ReactElement.isValidElement(mappedChild)) {
					mappedChild = ReactElement.cloneAndReplaceKey(mappedChild, keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
				}
				result.push(mappedChild);
			}
		}

		function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
			var escapedPrefix = '';
			if (prefix != null) {
				escapedPrefix = escapeUserProvidedKey(prefix) + '/';
			}
			var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
			traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
			MapBookKeeping.release(traverseContext);
		}

		function mapChildren(children, func, context) {
			if (children == null) {
				return children;
			}
			var result = [];
			mapIntoWithKeyPrefixInternal(children, result, null, func, context);
			return result;
		}

		function forEachSingleChildDummy(traverseContext, child, name) {
			return null;
		}

		function countChildren(children, context) {
			return traverseAllChildren(children, forEachSingleChildDummy, null);
		}

		function toArray(children) {
			var result = [];
			mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
			return result;
		}

		var ReactChildren = {
			forEach: forEachChildren,
			map: mapChildren,
			mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
			count: countChildren,
			toArray: toArray };

		module.exports = ReactChildren;
	}, // __react__/lib/traverseAllChildren.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactCurrentOwner = require('react-native@0.33/__react__/lib/ReactCurrentOwner.js');
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');

		var getIteratorFn = __inner_require__(11 /*__react__/lib/getIteratorFn.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var KeyEscapeUtils = __inner_require__(16 /*__react__/lib/KeyEscapeUtils.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var SEPARATOR = '.';
		var SUBSEPARATOR = ':';

		var didWarnAboutMaps = false;

		function getComponentKey(component, index) {

			if (component && typeof component === 'object' && component.key != null) {

				return KeyEscapeUtils.escape(component.key);
			}

			return index.toString(36);
		}

		function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
			var type = typeof children;

			if (type === 'undefined' || type === 'boolean') {

				children = null;
			}

			if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
				callback(traverseContext, children, nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
				return 1;
			}

			var child;
			var nextName;
			var subtreeCount = 0;
			var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

			if (Array.isArray(children)) {
				for (var i = 0; i < children.length; i++) {
					child = children[i];
					nextName = nextNamePrefix + getComponentKey(child, i);
					subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
				}
			} else {
				var iteratorFn = getIteratorFn(children);
				if (iteratorFn) {
					var iterator = iteratorFn.call(children);
					var step;
					if (iteratorFn !== children.entries) {
						var ii = 0;
						while (!(step = iterator.next()).done) {
							child = step.value;
							nextName = nextNamePrefix + getComponentKey(child, ii++);
							subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
						}
					} else {
						if (process.env.NODE_ENV !== 'production') {
							var mapsAsChildrenAddendum = '';
							if (ReactCurrentOwner.current) {
								var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
								if (mapsAsChildrenOwnerName) {
									mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
								}
							}
							process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
							didWarnAboutMaps = true;
						}

						while (!(step = iterator.next()).done) {
							var entry = step.value;
							if (entry) {
								child = entry[1];
								nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
								subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
							}
						}
					}
				} else if (type === 'object') {
					var addendum = '';
					if (process.env.NODE_ENV !== 'production') {
						addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
						if (children._isReactElement) {
							addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
						}
						if (ReactCurrentOwner.current) {
							var name = ReactCurrentOwner.current.getName();
							if (name) {
								addendum += ' Check the render method of `' + name + '`.';
							}
						}
					}
					var childrenString = String(children);
					!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
				}
			}

			return subtreeCount;
		}

		function traverseAllChildren(children, callback, traverseContext) {
			if (children == null) {
				return 0;
			}

			return traverseAllChildrenImpl(children, '', callback, traverseContext);
		}

		module.exports = traverseAllChildren;
	}, // __react__/lib/KeyEscapeUtils.js
	function (__inner_require__, exports, module) {
		function escape(key) {
			var escapeRegex = /[=:]/g;
			var escaperLookup = {
				'=': '=0',
				':': '=2' };

			var escapedString = ('' + key).replace(escapeRegex, function (match) {
				return escaperLookup[match];
			});

			return '$' + escapedString;
		}

		function unescape(key) {
			var unescapeRegex = /(=0|=2)/g;
			var unescaperLookup = {
				'=0': '=',
				'=2': ':' };

			var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

			return ('' + keySubstring).replace(unescapeRegex, function (match) {
				return unescaperLookup[match];
			});
		}

		var KeyEscapeUtils = {
			escape: escape,
			unescape: unescape };

		module.exports = KeyEscapeUtils;
	}, // __react__/lib/ReactComponent.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactNoopUpdateQueue = __inner_require__(18 /*__react__/lib/ReactNoopUpdateQueue.js*/);

		var canDefineProperty = require('react-native@0.33/__react__/lib/canDefineProperty.js');
		var emptyObject = require('react-native@0.33/__fbjs__/lib/emptyObject.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function ReactComponent(props, context, updater) {
			this.props = props;
			this.context = context;
			this.refs = emptyObject;

			this.updater = updater || ReactNoopUpdateQueue;
		}

		ReactComponent.prototype.isReactComponent = {};

		ReactComponent.prototype.setState = function (partialState, callback) {
			!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
			this.updater.enqueueSetState(this, partialState);
			if (callback) {
				this.updater.enqueueCallback(this, callback, 'setState');
			}
		};

		ReactComponent.prototype.forceUpdate = function (callback) {
			this.updater.enqueueForceUpdate(this);
			if (callback) {
				this.updater.enqueueCallback(this, callback, 'forceUpdate');
			}
		};

		if (process.env.NODE_ENV !== 'production') {
			var deprecatedAPIs = {
				isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
				replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'] };

			var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
				if (canDefineProperty) {
					Object.defineProperty(ReactComponent.prototype, methodName, {
						get: function get() {
							process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
							return undefined;
						} });
				}
			};
			for (var fnName in deprecatedAPIs) {
				if (deprecatedAPIs.hasOwnProperty(fnName)) {
					defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
				}
			}
		}

		module.exports = ReactComponent;
	}, // __react__/lib/ReactNoopUpdateQueue.js
	function (__inner_require__, exports, module) {
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function warnNoop(publicInstance, callerName) {
			if (process.env.NODE_ENV !== 'production') {
				var constructor = publicInstance.constructor;
				process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
			}
		}

		var ReactNoopUpdateQueue = {

			isMounted: function isMounted(publicInstance) {
				return false;
			},

			enqueueCallback: function enqueueCallback(publicInstance, callback) {},

			enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
				warnNoop(publicInstance, 'forceUpdate');
			},

			enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
				warnNoop(publicInstance, 'replaceState');
			},

			enqueueSetState: function enqueueSetState(publicInstance, partialState) {
				warnNoop(publicInstance, 'setState');
			} };

		module.exports = ReactNoopUpdateQueue;
	}, // __react__/lib/ReactPureComponent.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var ReactComponent = __inner_require__(17 /*__react__/lib/ReactComponent.js*/);
		var ReactNoopUpdateQueue = __inner_require__(18 /*__react__/lib/ReactNoopUpdateQueue.js*/);

		var emptyObject = require('react-native@0.33/__fbjs__/lib/emptyObject.js');

		function ReactPureComponent(props, context, updater) {

			this.props = props;
			this.context = context;
			this.refs = emptyObject;

			this.updater = updater || ReactNoopUpdateQueue;
		}

		function ComponentDummy() {}
		ComponentDummy.prototype = ReactComponent.prototype;
		ReactPureComponent.prototype = new ComponentDummy();
		ReactPureComponent.prototype.constructor = ReactPureComponent;

		_assign(ReactPureComponent.prototype, ReactComponent.prototype);
		ReactPureComponent.prototype.isPureReactComponent = true;

		module.exports = ReactPureComponent;
	}, // __react__/lib/ReactClass.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var ReactComponent = __inner_require__(17 /*__react__/lib/ReactComponent.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactPropTypeLocations = require('react-native@0.33/__react__/lib/ReactPropTypeLocations.js');
		var ReactPropTypeLocationNames = require('react-native@0.33/__react__/lib/ReactPropTypeLocationNames.js');
		var ReactNoopUpdateQueue = __inner_require__(18 /*__react__/lib/ReactNoopUpdateQueue.js*/);

		var emptyObject = require('react-native@0.33/__fbjs__/lib/emptyObject.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var MIXINS_KEY = keyOf({ mixins: null });

		var SpecPolicy = keyMirror({

			DEFINE_ONCE: null,

			DEFINE_MANY: null,

			OVERRIDE_BASE: null,

			DEFINE_MANY_MERGED: null });

		var injectedMixins = [];

		var ReactClassInterface = {

			mixins: SpecPolicy.DEFINE_MANY,

			statics: SpecPolicy.DEFINE_MANY,

			propTypes: SpecPolicy.DEFINE_MANY,

			contextTypes: SpecPolicy.DEFINE_MANY,

			childContextTypes: SpecPolicy.DEFINE_MANY,

			getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,

			getInitialState: SpecPolicy.DEFINE_MANY_MERGED,

			getChildContext: SpecPolicy.DEFINE_MANY_MERGED,

			render: SpecPolicy.DEFINE_ONCE,

			componentWillMount: SpecPolicy.DEFINE_MANY,

			componentDidMount: SpecPolicy.DEFINE_MANY,

			componentWillReceiveProps: SpecPolicy.DEFINE_MANY,

			shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,

			componentWillUpdate: SpecPolicy.DEFINE_MANY,

			componentDidUpdate: SpecPolicy.DEFINE_MANY,

			componentWillUnmount: SpecPolicy.DEFINE_MANY,

			updateComponent: SpecPolicy.OVERRIDE_BASE };

		var RESERVED_SPEC_KEYS = {
			displayName: function displayName(Constructor, _displayName) {
				Constructor.displayName = _displayName;
			},
			mixins: function mixins(Constructor, _mixins) {
				if (_mixins) {
					for (var i = 0; i < _mixins.length; i++) {
						mixSpecIntoComponent(Constructor, _mixins[i]);
					}
				}
			},
			childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
				if (process.env.NODE_ENV !== 'production') {
					validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
				}
				Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, _childContextTypes);
			},
			contextTypes: function contextTypes(Constructor, _contextTypes) {
				if (process.env.NODE_ENV !== 'production') {
					validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
				}
				Constructor.contextTypes = _assign({}, Constructor.contextTypes, _contextTypes);
			},

			getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
				if (Constructor.getDefaultProps) {
					Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
				} else {
					Constructor.getDefaultProps = _getDefaultProps;
				}
			},
			propTypes: function propTypes(Constructor, _propTypes) {
				if (process.env.NODE_ENV !== 'production') {
					validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
				}
				Constructor.propTypes = _assign({}, Constructor.propTypes, _propTypes);
			},
			statics: function statics(Constructor, _statics) {
				mixStaticSpecIntoComponent(Constructor, _statics);
			},
			autobind: function autobind() {} };

		function validateTypeDef(Constructor, typeDef, location) {
			for (var propName in typeDef) {
				if (typeDef.hasOwnProperty(propName)) {

					process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
				}
			}
		}

		function validateMethodOverride(isAlreadyDefined, name) {
			var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

			if (ReactClassMixin.hasOwnProperty(name)) {
				!(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
			}

			if (isAlreadyDefined) {
				!(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
			}
		}

		function mixSpecIntoComponent(Constructor, spec) {
			if (!spec) {
				if (process.env.NODE_ENV !== 'production') {
					var typeofSpec = typeof spec;
					var isMixinValid = typeofSpec === 'object' && spec !== null;

					process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
				}

				return;
			}

			!(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
			!!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

			var proto = Constructor.prototype;
			var autoBindPairs = proto.__reactAutoBindPairs;

			if (spec.hasOwnProperty(MIXINS_KEY)) {
				RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
			}

			for (var name in spec) {
				if (!spec.hasOwnProperty(name)) {
					continue;
				}

				if (name === MIXINS_KEY) {

					continue;
				}

				var property = spec[name];
				var isAlreadyDefined = proto.hasOwnProperty(name);
				validateMethodOverride(isAlreadyDefined, name);

				if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
					RESERVED_SPEC_KEYS[name](Constructor, property);
				} else {

					var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
					var isFunction = typeof property === 'function';
					var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

					if (shouldAutoBind) {
						autoBindPairs.push(name, property);
						proto[name] = property;
					} else {
						if (isAlreadyDefined) {
							var specPolicy = ReactClassInterface[name];

							!(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

							if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
								proto[name] = createMergedResultFunction(proto[name], property);
							} else if (specPolicy === SpecPolicy.DEFINE_MANY) {
								proto[name] = createChainedFunction(proto[name], property);
							}
						} else {
							proto[name] = property;
							if (process.env.NODE_ENV !== 'production') {

								if (typeof property === 'function' && spec.displayName) {
									proto[name].displayName = spec.displayName + '_' + name;
								}
							}
						}
					}
				}
			}
		}

		function mixStaticSpecIntoComponent(Constructor, statics) {
			if (!statics) {
				return;
			}
			for (var name in statics) {
				var property = statics[name];
				if (!statics.hasOwnProperty(name)) {
					continue;
				}

				var isReserved = name in RESERVED_SPEC_KEYS;
				!!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

				var isInherited = name in Constructor;
				!!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
				Constructor[name] = property;
			}
		}

		function mergeIntoWithNoDuplicateKeys(one, two) {
			!(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

			for (var key in two) {
				if (two.hasOwnProperty(key)) {
					!(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
					one[key] = two[key];
				}
			}
			return one;
		}

		function createMergedResultFunction(one, two) {
			return function mergedResult() {
				var a = one.apply(this, arguments);
				var b = two.apply(this, arguments);
				if (a == null) {
					return b;
				} else if (b == null) {
					return a;
				}
				var c = {};
				mergeIntoWithNoDuplicateKeys(c, a);
				mergeIntoWithNoDuplicateKeys(c, b);
				return c;
			};
		}

		function createChainedFunction(one, two) {
			return function chainedFunction() {
				one.apply(this, arguments);
				two.apply(this, arguments);
			};
		}

		function bindAutoBindMethod(component, method) {
			var boundMethod = method.bind(component);
			if (process.env.NODE_ENV !== 'production') {
				boundMethod.__reactBoundContext = component;
				boundMethod.__reactBoundMethod = method;
				boundMethod.__reactBoundArguments = null;
				var componentName = component.constructor.displayName;
				var _bind = boundMethod.bind;
				boundMethod.bind = function (newThis) {
					for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						args[_key - 1] = arguments[_key];
					}

					if (newThis !== component && newThis !== null) {
						process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
					} else if (!args.length) {
						process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
						return boundMethod;
					}
					var reboundMethod = _bind.apply(boundMethod, arguments);
					reboundMethod.__reactBoundContext = component;
					reboundMethod.__reactBoundMethod = method;
					reboundMethod.__reactBoundArguments = args;
					return reboundMethod;
				};
			}
			return boundMethod;
		}

		function bindAutoBindMethods(component) {
			var pairs = component.__reactAutoBindPairs;
			for (var i = 0; i < pairs.length; i += 2) {
				var autoBindKey = pairs[i];
				var method = pairs[i + 1];
				component[autoBindKey] = bindAutoBindMethod(component, method);
			}
		}

		var ReactClassMixin = {

			replaceState: function replaceState(newState, callback) {
				this.updater.enqueueReplaceState(this, newState);
				if (callback) {
					this.updater.enqueueCallback(this, callback, 'replaceState');
				}
			},

			isMounted: function isMounted() {
				return this.updater.isMounted(this);
			} };

		var ReactClassComponent = function ReactClassComponent() {};
		_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

		var ReactClass = {

			createClass: function createClass(spec) {
				var Constructor = function Constructor(props, context, updater) {

					if (process.env.NODE_ENV !== 'production') {
						process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
					}

					if (this.__reactAutoBindPairs.length) {
						bindAutoBindMethods(this);
					}

					this.props = props;
					this.context = context;
					this.refs = emptyObject;
					this.updater = updater || ReactNoopUpdateQueue;

					this.state = null;

					var initialState = this.getInitialState ? this.getInitialState() : null;
					if (process.env.NODE_ENV !== 'production') {

						if (initialState === undefined && this.getInitialState._isMockFunction) {

							initialState = null;
						}
					}
					!(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

					this.state = initialState;
				};
				Constructor.prototype = new ReactClassComponent();
				Constructor.prototype.constructor = Constructor;
				Constructor.prototype.__reactAutoBindPairs = [];

				injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

				mixSpecIntoComponent(Constructor, spec);

				if (Constructor.getDefaultProps) {
					Constructor.defaultProps = Constructor.getDefaultProps();
				}

				if (process.env.NODE_ENV !== 'production') {

					if (Constructor.getDefaultProps) {
						Constructor.getDefaultProps.isReactClassApproved = {};
					}
					if (Constructor.prototype.getInitialState) {
						Constructor.prototype.getInitialState.isReactClassApproved = {};
					}
				}

				!Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
					process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
				}

				for (var methodName in ReactClassInterface) {
					if (!Constructor.prototype[methodName]) {
						Constructor.prototype[methodName] = null;
					}
				}

				return Constructor;
			},

			injection: {
				injectMixin: function injectMixin(mixin) {
					injectedMixins.push(mixin);
				} } };

		module.exports = ReactClass;
	}, // __fbjs__/lib/keyOf.js
	function (__inner_require__, exports, module) {
		var keyOf = function keyOf(oneKeyObj) {
			var key;
			for (key in oneKeyObj) {
				if (!oneKeyObj.hasOwnProperty(key)) {
					continue;
				}
				return key;
			}
			return null;
		};

		module.exports = keyOf;
	}, // __react__/lib/ReactDOMFactories.js
	function (__inner_require__, exports, module) {
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');

		var createDOMFactory = ReactElement.createFactory;
		if (process.env.NODE_ENV !== 'production') {
			var ReactElementValidator = __inner_require__(23 /*__react__/lib/ReactElementValidator.js*/);
			createDOMFactory = ReactElementValidator.createFactory;
		}

		var ReactDOMFactories = {
			a: createDOMFactory('a'),
			abbr: createDOMFactory('abbr'),
			address: createDOMFactory('address'),
			area: createDOMFactory('area'),
			article: createDOMFactory('article'),
			aside: createDOMFactory('aside'),
			audio: createDOMFactory('audio'),
			b: createDOMFactory('b'),
			base: createDOMFactory('base'),
			bdi: createDOMFactory('bdi'),
			bdo: createDOMFactory('bdo'),
			big: createDOMFactory('big'),
			blockquote: createDOMFactory('blockquote'),
			body: createDOMFactory('body'),
			br: createDOMFactory('br'),
			button: createDOMFactory('button'),
			canvas: createDOMFactory('canvas'),
			caption: createDOMFactory('caption'),
			cite: createDOMFactory('cite'),
			code: createDOMFactory('code'),
			col: createDOMFactory('col'),
			colgroup: createDOMFactory('colgroup'),
			data: createDOMFactory('data'),
			datalist: createDOMFactory('datalist'),
			dd: createDOMFactory('dd'),
			del: createDOMFactory('del'),
			details: createDOMFactory('details'),
			dfn: createDOMFactory('dfn'),
			dialog: createDOMFactory('dialog'),
			div: createDOMFactory('div'),
			dl: createDOMFactory('dl'),
			dt: createDOMFactory('dt'),
			em: createDOMFactory('em'),
			embed: createDOMFactory('embed'),
			fieldset: createDOMFactory('fieldset'),
			figcaption: createDOMFactory('figcaption'),
			figure: createDOMFactory('figure'),
			footer: createDOMFactory('footer'),
			form: createDOMFactory('form'),
			h1: createDOMFactory('h1'),
			h2: createDOMFactory('h2'),
			h3: createDOMFactory('h3'),
			h4: createDOMFactory('h4'),
			h5: createDOMFactory('h5'),
			h6: createDOMFactory('h6'),
			head: createDOMFactory('head'),
			header: createDOMFactory('header'),
			hgroup: createDOMFactory('hgroup'),
			hr: createDOMFactory('hr'),
			html: createDOMFactory('html'),
			i: createDOMFactory('i'),
			iframe: createDOMFactory('iframe'),
			img: createDOMFactory('img'),
			input: createDOMFactory('input'),
			ins: createDOMFactory('ins'),
			kbd: createDOMFactory('kbd'),
			keygen: createDOMFactory('keygen'),
			label: createDOMFactory('label'),
			legend: createDOMFactory('legend'),
			li: createDOMFactory('li'),
			link: createDOMFactory('link'),
			main: createDOMFactory('main'),
			map: createDOMFactory('map'),
			mark: createDOMFactory('mark'),
			menu: createDOMFactory('menu'),
			menuitem: createDOMFactory('menuitem'),
			meta: createDOMFactory('meta'),
			meter: createDOMFactory('meter'),
			nav: createDOMFactory('nav'),
			noscript: createDOMFactory('noscript'),
			object: createDOMFactory('object'),
			ol: createDOMFactory('ol'),
			optgroup: createDOMFactory('optgroup'),
			option: createDOMFactory('option'),
			output: createDOMFactory('output'),
			p: createDOMFactory('p'),
			param: createDOMFactory('param'),
			picture: createDOMFactory('picture'),
			pre: createDOMFactory('pre'),
			progress: createDOMFactory('progress'),
			q: createDOMFactory('q'),
			rp: createDOMFactory('rp'),
			rt: createDOMFactory('rt'),
			ruby: createDOMFactory('ruby'),
			s: createDOMFactory('s'),
			samp: createDOMFactory('samp'),
			script: createDOMFactory('script'),
			section: createDOMFactory('section'),
			select: createDOMFactory('select'),
			small: createDOMFactory('small'),
			source: createDOMFactory('source'),
			span: createDOMFactory('span'),
			strong: createDOMFactory('strong'),
			style: createDOMFactory('style'),
			sub: createDOMFactory('sub'),
			summary: createDOMFactory('summary'),
			sup: createDOMFactory('sup'),
			table: createDOMFactory('table'),
			tbody: createDOMFactory('tbody'),
			td: createDOMFactory('td'),
			textarea: createDOMFactory('textarea'),
			tfoot: createDOMFactory('tfoot'),
			th: createDOMFactory('th'),
			thead: createDOMFactory('thead'),
			time: createDOMFactory('time'),
			title: createDOMFactory('title'),
			tr: createDOMFactory('tr'),
			track: createDOMFactory('track'),
			u: createDOMFactory('u'),
			ul: createDOMFactory('ul'),
			'var': createDOMFactory('var'),
			video: createDOMFactory('video'),
			wbr: createDOMFactory('wbr'),

			circle: createDOMFactory('circle'),
			clipPath: createDOMFactory('clipPath'),
			defs: createDOMFactory('defs'),
			ellipse: createDOMFactory('ellipse'),
			g: createDOMFactory('g'),
			image: createDOMFactory('image'),
			line: createDOMFactory('line'),
			linearGradient: createDOMFactory('linearGradient'),
			mask: createDOMFactory('mask'),
			path: createDOMFactory('path'),
			pattern: createDOMFactory('pattern'),
			polygon: createDOMFactory('polygon'),
			polyline: createDOMFactory('polyline'),
			radialGradient: createDOMFactory('radialGradient'),
			rect: createDOMFactory('rect'),
			stop: createDOMFactory('stop'),
			svg: createDOMFactory('svg'),
			text: createDOMFactory('text'),
			tspan: createDOMFactory('tspan') };

		module.exports = ReactDOMFactories;
	}, // __react__/lib/ReactElementValidator.js
	function (__inner_require__, exports, module) {
		var ReactCurrentOwner = require('react-native@0.33/__react__/lib/ReactCurrentOwner.js');
		var ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactPropTypeLocations = require('react-native@0.33/__react__/lib/ReactPropTypeLocations.js');

		var checkReactTypeSpec = require('react-native@0.33/__react__/lib/checkReactTypeSpec.js');

		var canDefineProperty = require('react-native@0.33/__react__/lib/canDefineProperty.js');
		var getIteratorFn = __inner_require__(11 /*__react__/lib/getIteratorFn.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function getDeclarationErrorAddendum() {
			if (ReactCurrentOwner.current) {
				var name = ReactCurrentOwner.current.getName();
				if (name) {
					return ' Check the render method of `' + name + '`.';
				}
			}
			return '';
		}

		var ownerHasKeyUseWarning = {};

		function getCurrentComponentErrorInfo(parentType) {
			var info = getDeclarationErrorAddendum();

			if (!info) {
				var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
				if (parentName) {
					info = ' Check the top-level render call using <' + parentName + '>.';
				}
			}
			return info;
		}

		function validateExplicitKey(element, parentType) {
			if (!element._store || element._store.validated || element.key != null) {
				return;
			}
			element._store.validated = true;

			var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

			var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
			if (memoizer[currentComponentErrorInfo]) {
				return;
			}
			memoizer[currentComponentErrorInfo] = true;

			var childOwner = '';
			if (element && element._owner && element._owner !== ReactCurrentOwner.current) {

				childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
			}

			process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
		}

		function validateChildKeys(node, parentType) {
			if (typeof node !== 'object') {
				return;
			}
			if (Array.isArray(node)) {
				for (var i = 0; i < node.length; i++) {
					var child = node[i];
					if (ReactElement.isValidElement(child)) {
						validateExplicitKey(child, parentType);
					}
				}
			} else if (ReactElement.isValidElement(node)) {

				if (node._store) {
					node._store.validated = true;
				}
			} else if (node) {
				var iteratorFn = getIteratorFn(node);

				if (iteratorFn) {
					if (iteratorFn !== node.entries) {
						var iterator = iteratorFn.call(node);
						var step;
						while (!(step = iterator.next()).done) {
							if (ReactElement.isValidElement(step.value)) {
								validateExplicitKey(step.value, parentType);
							}
						}
					}
				}
			}
		}

		function validatePropTypes(element) {
			var componentClass = element.type;
			if (typeof componentClass !== 'function') {
				return;
			}
			var name = componentClass.displayName || componentClass.name;
			if (componentClass.propTypes) {
				checkReactTypeSpec(componentClass.propTypes, element.props, ReactPropTypeLocations.prop, name, element, null);
			}
			if (typeof componentClass.getDefaultProps === 'function') {
				process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
			}
		}

		var ReactElementValidator = {

			createElement: function createElement(type, props, children) {
				var validType = typeof type === 'string' || typeof type === 'function';

				if (!validType) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : void 0;
				}

				var element = ReactElement.createElement.apply(this, arguments);

				if (element == null) {
					return element;
				}

				if (validType) {
					for (var i = 2; i < arguments.length; i++) {
						validateChildKeys(arguments[i], type);
					}
				}

				validatePropTypes(element);

				return element;
			},

			createFactory: function createFactory(type) {
				var validatedFactory = ReactElementValidator.createElement.bind(null, type);

				validatedFactory.type = type;

				if (process.env.NODE_ENV !== 'production') {
					if (canDefineProperty) {
						Object.defineProperty(validatedFactory, 'type', {
							enumerable: false,
							get: function get() {
								process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
								Object.defineProperty(this, 'type', {
									value: type });

								return type;
							} });
					}
				}

				return validatedFactory;
			},

			cloneElement: function cloneElement(element, props, children) {
				var newElement = ReactElement.cloneElement.apply(this, arguments);
				for (var i = 2; i < arguments.length; i++) {
					validateChildKeys(arguments[i], newElement.type);
				}
				validatePropTypes(newElement);
				return newElement;
			} };

		module.exports = ReactElementValidator;
	}, // __react__/lib/ReactVersion.js
	function (__inner_require__, exports, module) {
		module.exports = '15.3.2';
	}, // __react__/lib/onlyChild.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function onlyChild(children) {
			!ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
			return children;
		}

		module.exports = onlyChild;
	}, // Libraries/StyleSheet/StyleSheet.js
	function (__inner_require__, exports, module) {
		var PixelRatio = __inner_require__(27 /*Libraries/Utilities/PixelRatio.js*/);
		var ReactNativePropRegistry = require('react-native@0.33/__react__/lib/ReactNativePropRegistry.js');
		var StyleSheetValidation = __inner_require__(29 /*Libraries/StyleSheet/StyleSheetValidation.js*/);

		var flatten = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');

		var hairlineWidth = PixelRatio.roundToNearestPixel(0.4);
		if (hairlineWidth === 0) {
			hairlineWidth = 1 / PixelRatio.get();
		}

		var absoluteFillObject = {
			position: 'absolute',
			left: 0,
			right: 0,
			top: 0,
			bottom: 0 };

		var absoluteFill = ReactNativePropRegistry.register(absoluteFillObject);

		module.exports = {

			hairlineWidth: hairlineWidth,

			absoluteFill: absoluteFill,

			absoluteFillObject: absoluteFillObject,

			flatten: flatten,

			create: function create(obj) {
				var result = {};
				for (var key in obj) {
					StyleSheetValidation.validateStyle(key, obj);
					result[key] = ReactNativePropRegistry.register(obj[key]);
				}
				return result;
			} };
	}, // Libraries/Utilities/PixelRatio.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);var PixelRatio = function () {
			function PixelRatio() {
				babelHelpers.classCallCheck(this, PixelRatio);
			}babelHelpers.createClass(PixelRatio, null, [{ key: 'get', value: function get() {
					return Dimensions.get('window').scale;
				} }, { key: 'getFontScale', value: function getFontScale() {
					return Dimensions.get('window').fontScale || PixelRatio.get();
				} }, { key: 'getPixelSizeForLayoutSize', value: function getPixelSizeForLayoutSize(layoutSize) {
					return Math.round(layoutSize * PixelRatio.get());
				} }, { key: 'roundToNearestPixel', value: function roundToNearestPixel(layoutSize) {
					var ratio = PixelRatio.get();
					return Math.round(layoutSize * ratio) / ratio;
				} }, { key: 'startDetecting', value: function startDetecting() {} }]);return PixelRatio;
		}();

		module.exports = PixelRatio;
	}, // Libraries/Utilities/Dimensions.js
	function (__inner_require__, exports, module) {
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var RCTDeviceEventEmitter = require('react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var dimensions = {};var Dimensions = function () {
			function Dimensions() {
				babelHelpers.classCallCheck(this, Dimensions);
			}babelHelpers.createClass(Dimensions, null, [{ key: 'set', value: function set(dims) {

					if (dims && dims.windowPhysicalPixels) {

						dims = JSON.parse(JSON.stringify(dims));

						var windowPhysicalPixels = dims.windowPhysicalPixels;
						dims.window = {
							width: windowPhysicalPixels.width / windowPhysicalPixels.scale,
							height: windowPhysicalPixels.height / windowPhysicalPixels.scale,
							scale: windowPhysicalPixels.scale,
							fontScale: windowPhysicalPixels.fontScale };

						if (Platform.OS === 'android') {

							var screenPhysicalPixels = dims.screenPhysicalPixels;
							dims.screen = {
								width: screenPhysicalPixels.width / screenPhysicalPixels.scale,
								height: screenPhysicalPixels.height / screenPhysicalPixels.scale,
								scale: screenPhysicalPixels.scale,
								fontScale: screenPhysicalPixels.fontScale };

							delete dims.screenPhysicalPixels;
						} else {
							dims.screen = dims.window;
						}

						delete dims.windowPhysicalPixels;
					}

					babelHelpers.extends(dimensions, dims);
				} }, { key: 'get', value: function get(dim) {
					invariant(dimensions[dim], 'No dimension set for key ' + dim);
					return dimensions[dim];
				} }]);return Dimensions;
		}();

		Dimensions.set(UIManager.Dimensions);
		RCTDeviceEventEmitter.addListener('didUpdateDimensions', function (update) {
			Dimensions.set(update);
		});

		module.exports = Dimensions;
	}, // Libraries/StyleSheet/StyleSheetValidation.js
	function (__inner_require__, exports, module) {
		var ImageStylePropTypes = __inner_require__(30 /*Libraries/Image/ImageStylePropTypes.js*/);
		var ReactPropTypeLocations = require('react-native@0.33/__react__/lib/ReactPropTypeLocations.js');
		var ReactPropTypesSecret = require('react-native@0.33/__react__/lib/ReactPropTypesSecret.js');
		var TextStylePropTypes = __inner_require__(36 /*Libraries/Text/TextStylePropTypes.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');var StyleSheetValidation = function () {
			function StyleSheetValidation() {
				babelHelpers.classCallCheck(this, StyleSheetValidation);
			}babelHelpers.createClass(StyleSheetValidation, null, [{ key: 'validateStyleProp', value: function validateStyleProp(prop, style, caller) {
					if (!__DEV__) {
						return;
					}
					if (allStylePropTypes[prop] === undefined) {
						var message1 = '"' + prop + '" is not a valid style property.';
						var message2 = '\nValid style props: ' + JSON.stringify(Object.keys(allStylePropTypes).sort(), null, '  ');
						styleError(message1, style, caller, message2);
					}
					var error = allStylePropTypes[prop](style, prop, caller, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);

					if (error) {
						styleError(error.message, style, caller);
					}
				} }, { key: 'validateStyle', value: function validateStyle(name, styles) {
					if (!__DEV__) {
						return;
					}
					for (var prop in styles[name]) {
						StyleSheetValidation.validateStyleProp(prop, styles[name], 'StyleSheet ' + name);
					}
				} }, { key: 'addValidStylePropTypes', value: function addValidStylePropTypes(stylePropTypes) {
					for (var key in stylePropTypes) {
						allStylePropTypes[key] = stylePropTypes[key];
					}
				} }]);return StyleSheetValidation;
		}();

		var styleError = function styleError(message1, style, caller, message2) {
			invariant(false, message1 + '\n' + (caller || '<<unknown>>') + ': ' + JSON.stringify(style, null, '  ') + (message2 || ''));
		};

		var allStylePropTypes = {};

		StyleSheetValidation.addValidStylePropTypes(ImageStylePropTypes);
		StyleSheetValidation.addValidStylePropTypes(TextStylePropTypes);
		StyleSheetValidation.addValidStylePropTypes(ViewStylePropTypes);

		module.exports = StyleSheetValidation;
	}, // Libraries/Image/ImageStylePropTypes.js
	function (__inner_require__, exports, module) {
		var ImageResizeMode = __inner_require__(31 /*Libraries/Image/ImageResizeMode.js*/);
		var LayoutPropTypes = __inner_require__(32 /*Libraries/StyleSheet/LayoutPropTypes.js*/);
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var ShadowPropTypesIOS = __inner_require__(33 /*Libraries/Components/View/ShadowPropTypesIOS.js*/);
		var TransformPropTypes = __inner_require__(34 /*Libraries/StyleSheet/TransformPropTypes.js*/);

		var ImageStylePropTypes = babelHelpers.extends({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
			resizeMode: ReactPropTypes.oneOf(Object.keys(ImageResizeMode)),
			backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
			backgroundColor: ColorPropType,
			borderColor: ColorPropType,
			borderWidth: ReactPropTypes.number,
			borderRadius: ReactPropTypes.number,
			overflow: ReactPropTypes.oneOf(['visible', 'hidden']),

			tintColor: ColorPropType,
			opacity: ReactPropTypes.number,

			overlayColor: ReactPropTypes.string,

			borderTopLeftRadius: ReactPropTypes.number,
			borderTopRightRadius: ReactPropTypes.number,
			borderBottomLeftRadius: ReactPropTypes.number,
			borderBottomRightRadius: ReactPropTypes.number });

		module.exports = ImageStylePropTypes;
	}, // Libraries/Image/ImageResizeMode.js
	function (__inner_require__, exports, module) {
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var ImageResizeMode = keyMirror({

			contain: null,

			cover: null,

			stretch: null,

			center: null,

			repeat: null });

		module.exports = ImageResizeMode;
	}, // Libraries/StyleSheet/LayoutPropTypes.js
	function (__inner_require__, exports, module) {
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);

		var LayoutPropTypes = {

			width: ReactPropTypes.number,

			height: ReactPropTypes.number,

			top: ReactPropTypes.number,

			left: ReactPropTypes.number,

			right: ReactPropTypes.number,

			bottom: ReactPropTypes.number,

			minWidth: ReactPropTypes.number,

			maxWidth: ReactPropTypes.number,

			minHeight: ReactPropTypes.number,

			maxHeight: ReactPropTypes.number,

			margin: ReactPropTypes.number,

			marginVertical: ReactPropTypes.number,

			marginHorizontal: ReactPropTypes.number,

			marginTop: ReactPropTypes.number,

			marginBottom: ReactPropTypes.number,

			marginLeft: ReactPropTypes.number,

			marginRight: ReactPropTypes.number,

			padding: ReactPropTypes.number,

			paddingVertical: ReactPropTypes.number,

			paddingHorizontal: ReactPropTypes.number,

			paddingTop: ReactPropTypes.number,

			paddingBottom: ReactPropTypes.number,

			paddingLeft: ReactPropTypes.number,

			paddingRight: ReactPropTypes.number,

			borderWidth: ReactPropTypes.number,

			borderTopWidth: ReactPropTypes.number,

			borderRightWidth: ReactPropTypes.number,

			borderBottomWidth: ReactPropTypes.number,

			borderLeftWidth: ReactPropTypes.number,

			position: ReactPropTypes.oneOf(['absolute', 'relative']),

			flexDirection: ReactPropTypes.oneOf(['row', 'row-reverse', 'column', 'column-reverse']),

			flexWrap: ReactPropTypes.oneOf(['wrap', 'nowrap']),

			justifyContent: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'space-between', 'space-around']),

			alignItems: ReactPropTypes.oneOf(['flex-start', 'flex-end', 'center', 'stretch']),

			alignSelf: ReactPropTypes.oneOf(['auto', 'flex-start', 'flex-end', 'center', 'stretch']),

			flex: ReactPropTypes.number,

			zIndex: ReactPropTypes.number };

		module.exports = LayoutPropTypes;
	}, // Libraries/Components/View/ShadowPropTypesIOS.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);

		var ShadowPropTypesIOS = {

			shadowColor: ColorPropType,

			shadowOffset: ReactPropTypes.shape({ width: ReactPropTypes.number, height: ReactPropTypes.number }),

			shadowOpacity: ReactPropTypes.number,

			shadowRadius: ReactPropTypes.number };

		module.exports = ShadowPropTypesIOS;
	}, // Libraries/StyleSheet/TransformPropTypes.js
	function (__inner_require__, exports, module) {
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var deprecatedPropType = __inner_require__(35 /*Libraries/Utilities/deprecatedPropType.js*/);

		var ArrayOfNumberPropType = ReactPropTypes.arrayOf(ReactPropTypes.number);

		var TransformMatrixPropType = function TransformMatrixPropType(props, propName, componentName) {
			if (props[propName]) {
				return new Error('The transformMatrix style property is deprecated. ' + 'Use `transform: [{ matrix: ... }]` instead.');
			}
		};

		var DecomposedMatrixPropType = function DecomposedMatrixPropType(props, propName, componentName) {
			if (props[propName]) {
				return new Error('The decomposedMatrix style property is deprecated. ' + 'Use `transform: [...]` instead.');
			}
		};

		var TransformPropTypes = {
			transform: ReactPropTypes.arrayOf(ReactPropTypes.oneOfType([ReactPropTypes.shape({ perspective: ReactPropTypes.number }), ReactPropTypes.shape({ rotate: ReactPropTypes.string }), ReactPropTypes.shape({ rotateX: ReactPropTypes.string }), ReactPropTypes.shape({ rotateY: ReactPropTypes.string }), ReactPropTypes.shape({ rotateZ: ReactPropTypes.string }), ReactPropTypes.shape({ scale: ReactPropTypes.number }), ReactPropTypes.shape({ scaleX: ReactPropTypes.number }), ReactPropTypes.shape({ scaleY: ReactPropTypes.number }), ReactPropTypes.shape({ translateX: ReactPropTypes.number }), ReactPropTypes.shape({ translateY: ReactPropTypes.number }), ReactPropTypes.shape({ skewX: ReactPropTypes.string }), ReactPropTypes.shape({ skewY: ReactPropTypes.string })])),

			transformMatrix: TransformMatrixPropType,
			decomposedMatrix: DecomposedMatrixPropType,

			scaleX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
			scaleY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
			rotation: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
			translateX: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.'),
			translateY: deprecatedPropType(ReactPropTypes.number, 'Use the transform prop instead.') };

		module.exports = TransformPropTypes;
	}, // Libraries/Utilities/deprecatedPropType.js
	function (__inner_require__, exports, module) {
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var ReactPropTypesSecret = require('react-native@0.33/__react__/lib/ReactPropTypesSecret.js');
		var ReactPropTypeLocations = require('react-native@0.33/__react__/lib/ReactPropTypeLocations.js');

		function deprecatedPropType(propType, explanation) {
			return function validate(props, propName, componentName) {

				if (!UIManager[componentName] && props[propName] !== undefined) {
					console.warn('`' + propName + '` supplied to `' + componentName + '` has been deprecated. ' + explanation);
				}

				return propType(props, propName, componentName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
			};
		}

		module.exports = deprecatedPropType;
	}, // Libraries/Text/TextStylePropTypes.js
	function (__inner_require__, exports, module) {
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var TextStylePropTypes = babelHelpers.extends(Object.create(ViewStylePropTypes), {
			color: ColorPropType,
			fontFamily: ReactPropTypes.string,
			fontSize: ReactPropTypes.number,
			fontStyle: ReactPropTypes.oneOf(['normal', 'italic']),

			fontWeight: ReactPropTypes.oneOf(['normal', 'bold', '100', '200', '300', '400', '500', '600', '700', '800', '900']),

			fontVariant: ReactPropTypes.arrayOf(ReactPropTypes.oneOf(['small-caps', 'oldstyle-nums', 'lining-nums', 'tabular-nums', 'proportional-nums'])),

			textShadowOffset: ReactPropTypes.shape({ width: ReactPropTypes.number, height: ReactPropTypes.number }),

			textShadowRadius: ReactPropTypes.number,
			textShadowColor: ColorPropType,

			letterSpacing: ReactPropTypes.number,
			lineHeight: ReactPropTypes.number,

			textAlign: ReactPropTypes.oneOf(['auto', 'left', 'right', 'center', 'justify']),

			textAlignVertical: ReactPropTypes.oneOf(['auto', 'top', 'bottom', 'center']),

			textDecorationLine: ReactPropTypes.oneOf(['none', 'underline', 'line-through', 'underline line-through']),

			textDecorationStyle: ReactPropTypes.oneOf(['solid', 'double', 'dotted', 'dashed']),

			textDecorationColor: ColorPropType,

			writingDirection: ReactPropTypes.oneOf(['auto', 'ltr', 'rtl']) });

		module.exports = TextStylePropTypes;
	}, // Libraries/Components/View/ViewStylePropTypes.js
	function (__inner_require__, exports, module) {
		var LayoutPropTypes = __inner_require__(32 /*Libraries/StyleSheet/LayoutPropTypes.js*/);
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var ShadowPropTypesIOS = __inner_require__(33 /*Libraries/Components/View/ShadowPropTypesIOS.js*/);
		var TransformPropTypes = __inner_require__(34 /*Libraries/StyleSheet/TransformPropTypes.js*/);

		var ViewStylePropTypes = babelHelpers.extends({}, LayoutPropTypes, ShadowPropTypesIOS, TransformPropTypes, {
			backfaceVisibility: ReactPropTypes.oneOf(['visible', 'hidden']),
			backgroundColor: ColorPropType,
			borderColor: ColorPropType,
			borderTopColor: ColorPropType,
			borderRightColor: ColorPropType,
			borderBottomColor: ColorPropType,
			borderLeftColor: ColorPropType,
			borderRadius: ReactPropTypes.number,
			borderTopLeftRadius: ReactPropTypes.number,
			borderTopRightRadius: ReactPropTypes.number,
			borderBottomLeftRadius: ReactPropTypes.number,
			borderBottomRightRadius: ReactPropTypes.number,
			borderStyle: ReactPropTypes.oneOf(['solid', 'dotted', 'dashed']),
			borderWidth: ReactPropTypes.number,
			borderTopWidth: ReactPropTypes.number,
			borderRightWidth: ReactPropTypes.number,
			borderBottomWidth: ReactPropTypes.number,
			borderLeftWidth: ReactPropTypes.number,
			opacity: ReactPropTypes.number,
			overflow: ReactPropTypes.oneOf(['visible', 'hidden']),

			elevation: ReactPropTypes.number });

		module.exports = ViewStylePropTypes;
	}, // Libraries/Components/View/View.js
	function (__inner_require__, exports, module) {
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNativeStyleAttributes = __inner_require__(44 /*Libraries/Components/View/ReactNativeStyleAttributes.js*/);
		var ReactNativeViewAttributes = __inner_require__(49 /*Libraries/Components/View/ReactNativeViewAttributes.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var stylePropType = StyleSheetPropType(ViewStylePropTypes);

		var AccessibilityTraits = ['none', 'button', 'link', 'header', 'search', 'image', 'selected', 'plays', 'key', 'text', 'summary', 'disabled', 'frequentUpdates', 'startsMedia', 'adjustable', 'allowsDirectInteraction', 'pageTurn'];

		var AccessibilityComponentType = ['none', 'button', 'radiobutton_checked', 'radiobutton_unchecked'];

		var forceTouchAvailable = UIManager.RCTView.Constants && UIManager.RCTView.Constants.forceTouchAvailable || false;

		var statics = {
			AccessibilityTraits: AccessibilityTraits,
			AccessibilityComponentType: AccessibilityComponentType,

			forceTouchAvailable: forceTouchAvailable };

		var View = React.createClass({ displayName: 'View',

			mixins: [NativeMethodsMixin],

			viewConfig: {
				uiViewClassName: 'RCTView',
				validAttributes: ReactNativeViewAttributes.RCTView },

			statics: babelHelpers.extends({}, statics),

			propTypes: {

				accessible: PropTypes.bool,

				accessibilityLabel: PropTypes.string,

				accessibilityComponentType: PropTypes.oneOf(AccessibilityComponentType),

				accessibilityLiveRegion: PropTypes.oneOf(['none', 'polite', 'assertive']),

				importantForAccessibility: PropTypes.oneOf(['auto', 'yes', 'no', 'no-hide-descendants']),

				accessibilityTraits: PropTypes.oneOfType([PropTypes.oneOf(AccessibilityTraits), PropTypes.arrayOf(PropTypes.oneOf(AccessibilityTraits))]),

				onAccessibilityTap: PropTypes.func,

				onMagicTap: PropTypes.func,

				testID: PropTypes.string,

				onResponderGrant: PropTypes.func,

				onResponderMove: PropTypes.func,

				onResponderReject: PropTypes.func,

				onResponderRelease: PropTypes.func,

				onResponderTerminate: PropTypes.func,

				onResponderTerminationRequest: PropTypes.func,

				onStartShouldSetResponder: PropTypes.func,

				onStartShouldSetResponderCapture: PropTypes.func,

				onMoveShouldSetResponder: PropTypes.func,

				onMoveShouldSetResponderCapture: PropTypes.func,

				hitSlop: EdgeInsetsPropType,

				onLayout: PropTypes.func,

				pointerEvents: PropTypes.oneOf(['box-none', 'none', 'box-only', 'auto']),

				style: stylePropType,

				removeClippedSubviews: PropTypes.bool,

				renderToHardwareTextureAndroid: PropTypes.bool,

				shouldRasterizeIOS: PropTypes.bool,

				collapsable: PropTypes.bool,

				needsOffscreenAlphaCompositing: PropTypes.bool },

			render: function render() {

				return React.createElement(RCTView, this.props);
			} });

		var RCTView = requireNativeComponent('RCTView', View, {
			nativeOnly: {
				nativeBackgroundAndroid: true } });

		if (__DEV__) {
			var viewConfig = UIManager.viewConfigs && UIManager.viewConfigs.RCTView || {};
			for (var prop in viewConfig.nativeProps) {
				var viewAny = View;
				if (!viewAny.propTypes[prop] && !ReactNativeStyleAttributes[prop]) {
					throw new Error('View is missing propType for native prop `' + prop + '`');
				}
			}
		}

		var ViewToExport = RCTView;
		if (__DEV__) {
			ViewToExport = View;
		} else {
			babelHelpers.extends(RCTView, statics);
		}

		module.exports = ViewToExport;
	}, // Libraries/StyleSheet/EdgeInsetsPropType.js
	function (__inner_require__, exports, module) {
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);

		var createStrictShapeTypeChecker = __inner_require__(40 /*Libraries/Utilities/createStrictShapeTypeChecker.js*/);

		var EdgeInsetsPropType = createStrictShapeTypeChecker({
			top: PropTypes.number,
			left: PropTypes.number,
			bottom: PropTypes.number,
			right: PropTypes.number });

		module.exports = EdgeInsetsPropType;
	}, // Libraries/Utilities/createStrictShapeTypeChecker.js
	function (__inner_require__, exports, module) {
		var ReactPropTypeLocationNames = require('react-native@0.33/__react__/lib/ReactPropTypeLocationNames.js');
		var ReactPropTypesSecret = require('react-native@0.33/__react__/lib/ReactPropTypesSecret.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		function createStrictShapeTypeChecker(shapeTypes) {
			function checkType(isRequired, props, propName, componentName, location) {
				if (!props[propName]) {
					if (isRequired) {
						invariant(false, 'Required object `' + propName + '` was not specified in ' + ('`' + componentName + '`.'));
					}
					return;
				}
				var propValue = props[propName];
				var propType = typeof propValue;
				var locationName = location && ReactPropTypeLocationNames[location] || '(unknown)';
				if (propType !== 'object') {
					invariant(false, 'Invalid ' + locationName + ' `' + propName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
				}

				var allKeys = merge(props[propName], shapeTypes);
				for (var key in allKeys) {
					var checker = shapeTypes[key];
					if (!checker) {
						invariant(false, 'Invalid props.' + propName + ' key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
					}
					var error = checker(propValue, key, componentName, location, null, ReactPropTypesSecret);
					if (error) {
						invariant(false, error.message + '\nBad object: ' + JSON.stringify(props[propName], null, '  '));
					}
				}
			}
			function chainedCheckType(props, propName, componentName, location) {
				return checkType(false, props, propName, componentName, location);
			}
			chainedCheckType.isRequired = checkType.bind(null, true);
			return chainedCheckType;
		}

		module.exports = createStrictShapeTypeChecker;
	}, // Libraries/vendor/core/merge.js
	function (__inner_require__, exports, module) {
		var mergeInto = __inner_require__(42 /*Libraries/vendor/core/mergeInto.js*/);

		var merge = function merge(one, two) {
			var result = {};
			mergeInto(result, one);
			mergeInto(result, two);
			return result;
		};

		module.exports = merge;
	}, // Libraries/vendor/core/mergeInto.js
	function (__inner_require__, exports, module) {
		var mergeHelpers = __inner_require__(43 /*Libraries/vendor/core/mergeHelpers.js*/);

		var checkMergeObjectArg = mergeHelpers.checkMergeObjectArg;
		var checkMergeIntoObjectArg = mergeHelpers.checkMergeIntoObjectArg;

		function mergeInto(one, two) {
			checkMergeIntoObjectArg(one);
			if (two != null) {
				checkMergeObjectArg(two);
				for (var key in two) {
					if (!two.hasOwnProperty(key)) {
						continue;
					}
					one[key] = two[key];
				}
			}
		}

		module.exports = mergeInto;
	}, // Libraries/vendor/core/mergeHelpers.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var MAX_MERGE_DEPTH = 36;

		var isTerminal = function isTerminal(o) {
			return typeof o !== 'object' || o === null;
		};

		var mergeHelpers = {

			MAX_MERGE_DEPTH: MAX_MERGE_DEPTH,

			isTerminal: isTerminal,

			normalizeMergeArg: function normalizeMergeArg(arg) {
				return arg === undefined || arg === null ? {} : arg;
			},

			checkMergeArrayArgs: function checkMergeArrayArgs(one, two) {
				invariant(Array.isArray(one) && Array.isArray(two), 'Tried to merge arrays, instead got %s and %s.', one, two);
			},

			checkMergeObjectArgs: function checkMergeObjectArgs(one, two) {
				mergeHelpers.checkMergeObjectArg(one);
				mergeHelpers.checkMergeObjectArg(two);
			},

			checkMergeObjectArg: function checkMergeObjectArg(arg) {
				invariant(!isTerminal(arg) && !Array.isArray(arg), 'Tried to merge an object, instead got %s.', arg);
			},

			checkMergeIntoObjectArg: function checkMergeIntoObjectArg(arg) {
				invariant((!isTerminal(arg) || typeof arg === 'function') && !Array.isArray(arg), 'Tried to merge into an object, instead got %s.', arg);
			},

			checkMergeLevel: function checkMergeLevel(level) {
				invariant(level < MAX_MERGE_DEPTH, 'Maximum deep merge depth exceeded. You may be attempting to merge ' + 'circular structures in an unsupported way.');
			},

			checkArrayStrategy: function checkArrayStrategy(strategy) {
				invariant(strategy === undefined || strategy in mergeHelpers.ArrayStrategies, 'You must provide an array strategy to deep merge functions to ' + 'instruct the deep merge how to resolve merging two arrays.');
			},

			ArrayStrategies: keyMirror({
				Clobber: true,
				IndexByIndex: true }) };

		module.exports = mergeHelpers;
	}, // Libraries/Components/View/ReactNativeStyleAttributes.js
	function (__inner_require__, exports, module) {
		var ImageStylePropTypes = __inner_require__(30 /*Libraries/Image/ImageStylePropTypes.js*/);
		var TextStylePropTypes = __inner_require__(36 /*Libraries/Text/TextStylePropTypes.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');
		var matricesDiffer = __inner_require__(45 /*Libraries/Utilities/differ/matricesDiffer.js*/);
		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');
		var processTransform = __inner_require__(46 /*Libraries/StyleSheet/processTransform.js*/);
		var sizesDiffer = __inner_require__(48 /*Libraries/Utilities/differ/sizesDiffer.js*/);

		var ReactNativeStyleAttributes = babelHelpers.extends({}, keyMirror(ViewStylePropTypes), keyMirror(TextStylePropTypes), keyMirror(ImageStylePropTypes));

		ReactNativeStyleAttributes.transform = { process: processTransform };
		ReactNativeStyleAttributes.transformMatrix = { diff: matricesDiffer };
		ReactNativeStyleAttributes.shadowOffset = { diff: sizesDiffer };

		ReactNativeStyleAttributes.decomposedMatrix = 'decomposedMatrix';

		var colorAttributes = { process: processColor };
		ReactNativeStyleAttributes.backgroundColor = colorAttributes;
		ReactNativeStyleAttributes.borderBottomColor = colorAttributes;
		ReactNativeStyleAttributes.borderColor = colorAttributes;
		ReactNativeStyleAttributes.borderLeftColor = colorAttributes;
		ReactNativeStyleAttributes.borderRightColor = colorAttributes;
		ReactNativeStyleAttributes.borderTopColor = colorAttributes;
		ReactNativeStyleAttributes.color = colorAttributes;
		ReactNativeStyleAttributes.shadowColor = colorAttributes;
		ReactNativeStyleAttributes.textDecorationColor = colorAttributes;
		ReactNativeStyleAttributes.tintColor = colorAttributes;
		ReactNativeStyleAttributes.textShadowColor = colorAttributes;
		ReactNativeStyleAttributes.overlayColor = colorAttributes;

		module.exports = ReactNativeStyleAttributes;
	}, // Libraries/Utilities/differ/matricesDiffer.js
	function (__inner_require__, exports, module) {
		var matricesDiffer = function matricesDiffer(one, two) {
			if (one === two) {
				return false;
			}
			return !one || !two || one[12] !== two[12] || one[13] !== two[13] || one[14] !== two[14] || one[5] !== two[5] || one[10] !== two[10] || one[1] !== two[1] || one[2] !== two[2] || one[3] !== two[3] || one[4] !== two[4] || one[6] !== two[6] || one[7] !== two[7] || one[8] !== two[8] || one[9] !== two[9] || one[11] !== two[11] || one[15] !== two[15];
		};

		module.exports = matricesDiffer;
	}, // Libraries/StyleSheet/processTransform.js
	function (__inner_require__, exports, module) {
		var MatrixMath = __inner_require__(47 /*Libraries/Utilities/MatrixMath.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var stringifySafe = require('react-native@0.33/Libraries/Utilities/stringifySafe.js');

		function processTransform(transform) {
			if (__DEV__) {
				_validateTransforms(transform);
			}

			if (Platform.OS === 'android') {
				return transform;
			}

			var result = MatrixMath.createIdentityMatrix();

			transform.forEach(function (transformation) {
				var key = Object.keys(transformation)[0];
				var value = transformation[key];

				switch (key) {
					case 'matrix':
						MatrixMath.multiplyInto(result, result, value);
						break;
					case 'perspective':
						_multiplyTransform(result, MatrixMath.reusePerspectiveCommand, [value]);
						break;
					case 'rotateX':
						_multiplyTransform(result, MatrixMath.reuseRotateXCommand, [_convertToRadians(value)]);
						break;
					case 'rotateY':
						_multiplyTransform(result, MatrixMath.reuseRotateYCommand, [_convertToRadians(value)]);
						break;
					case 'rotate':
					case 'rotateZ':
						_multiplyTransform(result, MatrixMath.reuseRotateZCommand, [_convertToRadians(value)]);
						break;
					case 'scale':
						_multiplyTransform(result, MatrixMath.reuseScaleCommand, [value]);
						break;
					case 'scaleX':
						_multiplyTransform(result, MatrixMath.reuseScaleXCommand, [value]);
						break;
					case 'scaleY':
						_multiplyTransform(result, MatrixMath.reuseScaleYCommand, [value]);
						break;
					case 'translate':
						_multiplyTransform(result, MatrixMath.reuseTranslate3dCommand, [value[0], value[1], value[2] || 0]);
						break;
					case 'translateX':
						_multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [value, 0]);
						break;
					case 'translateY':
						_multiplyTransform(result, MatrixMath.reuseTranslate2dCommand, [0, value]);
						break;
					case 'skewX':
						_multiplyTransform(result, MatrixMath.reuseSkewXCommand, [_convertToRadians(value)]);
						break;
					case 'skewY':
						_multiplyTransform(result, MatrixMath.reuseSkewYCommand, [_convertToRadians(value)]);
						break;
					default:
						throw new Error('Invalid transform name: ' + key);}
			});

			return result;
		}

		function _multiplyTransform(result, matrixMathFunction, args) {
			var matrixToApply = MatrixMath.createIdentityMatrix();
			var argsWithIdentity = [matrixToApply].concat(args);
			matrixMathFunction.apply(this, argsWithIdentity);
			MatrixMath.multiplyInto(result, result, matrixToApply);
		}

		function _convertToRadians(value) {
			var floatValue = parseFloat(value, 10);
			return value.indexOf('rad') > -1 ? floatValue : floatValue * Math.PI / 180;
		}

		function _validateTransforms(transform) {
			transform.forEach(function (transformation) {
				var key = Object.keys(transformation)[0];
				var value = transformation[key];
				_validateTransform(key, value, transformation);
			});
		}

		function _validateTransform(key, value, transformation) {
			invariant(!value.getValue, 'You passed an Animated.Value to a normal component. ' + 'You need to wrap that component in an Animated. For example, ' + 'replace <View /> by <Animated.View />.');

			var multivalueTransforms = ['matrix', 'translate'];

			if (multivalueTransforms.indexOf(key) !== -1) {
				invariant(Array.isArray(value), 'Transform with key of %s must have an array as the value: %s', key, stringifySafe(transformation));
			}
			switch (key) {
				case 'matrix':
					invariant(value.length === 9 || value.length === 16, 'Matrix transform must have a length of 9 (2d) or 16 (3d). ' + 'Provided matrix has a length of %s: %s', value.length, stringifySafe(transformation));

					break;
				case 'translate':
					break;
				case 'rotateX':
				case 'rotateY':
				case 'rotateZ':
				case 'rotate':
				case 'skewX':
				case 'skewY':
					invariant(typeof value === 'string', 'Transform with key of "%s" must be a string: %s', key, stringifySafe(transformation));

					invariant(value.indexOf('deg') > -1 || value.indexOf('rad') > -1, 'Rotate transform must be expressed in degrees (deg) or radians ' + '(rad): %s', stringifySafe(transformation));

					break;
				case 'perspective':
					invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));

					invariant(value !== 0, 'Transform with key of "%s" cannot be zero: %s', key, stringifySafe(transformation));

					break;
				default:
					invariant(typeof value === 'number', 'Transform with key of "%s" must be a number: %s', key, stringifySafe(transformation));}
		}

		module.exports = processTransform;
	}, // Libraries/Utilities/MatrixMath.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var MatrixMath = {
			createIdentityMatrix: function createIdentityMatrix() {
				return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
			},

			createCopy: function createCopy(m) {
				return [m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]];
			},

			createOrthographic: function createOrthographic(left, right, bottom, top, near, far) {
				var a = 2 / (right - left);
				var b = 2 / (top - bottom);
				var c = -2 / (far - near);

				var tx = -(right + left) / (right - left);
				var ty = -(top + bottom) / (top - bottom);
				var tz = -(far + near) / (far - near);

				return [a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, tx, ty, tz, 1];
			},

			createFrustum: function createFrustum(left, right, bottom, top, near, far) {
				var r_width = 1 / (right - left);
				var r_height = 1 / (top - bottom);
				var r_depth = 1 / (near - far);
				var x = 2 * (near * r_width);
				var y = 2 * (near * r_height);
				var A = (right + left) * r_width;
				var B = (top + bottom) * r_height;
				var C = (far + near) * r_depth;
				var D = 2 * (far * near * r_depth);
				return [x, 0, 0, 0, 0, y, 0, 0, A, B, C, -1, 0, 0, D, 0];
			},

			createPerspective: function createPerspective(fovInRadians, aspect, near, far) {
				var h = 1 / Math.tan(fovInRadians / 2);
				var r_depth = 1 / (near - far);
				var C = (far + near) * r_depth;
				var D = 2 * (far * near * r_depth);
				return [h / aspect, 0, 0, 0, 0, h, 0, 0, 0, 0, C, -1, 0, 0, D, 0];
			},

			createTranslate2d: function createTranslate2d(x, y) {
				var mat = MatrixMath.createIdentityMatrix();
				MatrixMath.reuseTranslate2dCommand(mat, x, y);
				return mat;
			},

			reuseTranslate2dCommand: function reuseTranslate2dCommand(matrixCommand, x, y) {
				matrixCommand[12] = x;
				matrixCommand[13] = y;
			},

			reuseTranslate3dCommand: function reuseTranslate3dCommand(matrixCommand, x, y, z) {
				matrixCommand[12] = x;
				matrixCommand[13] = y;
				matrixCommand[14] = z;
			},

			createScale: function createScale(factor) {
				var mat = MatrixMath.createIdentityMatrix();
				MatrixMath.reuseScaleCommand(mat, factor);
				return mat;
			},

			reuseScaleCommand: function reuseScaleCommand(matrixCommand, factor) {
				matrixCommand[0] = factor;
				matrixCommand[5] = factor;
			},

			reuseScale3dCommand: function reuseScale3dCommand(matrixCommand, x, y, z) {
				matrixCommand[0] = x;
				matrixCommand[5] = y;
				matrixCommand[10] = z;
			},

			reusePerspectiveCommand: function reusePerspectiveCommand(matrixCommand, p) {
				matrixCommand[11] = -1 / p;
			},

			reuseScaleXCommand: function reuseScaleXCommand(matrixCommand, factor) {
				matrixCommand[0] = factor;
			},

			reuseScaleYCommand: function reuseScaleYCommand(matrixCommand, factor) {
				matrixCommand[5] = factor;
			},

			reuseScaleZCommand: function reuseScaleZCommand(matrixCommand, factor) {
				matrixCommand[10] = factor;
			},

			reuseRotateXCommand: function reuseRotateXCommand(matrixCommand, radians) {
				matrixCommand[5] = Math.cos(radians);
				matrixCommand[6] = Math.sin(radians);
				matrixCommand[9] = -Math.sin(radians);
				matrixCommand[10] = Math.cos(radians);
			},

			reuseRotateYCommand: function reuseRotateYCommand(matrixCommand, amount) {
				matrixCommand[0] = Math.cos(amount);
				matrixCommand[2] = -Math.sin(amount);
				matrixCommand[8] = Math.sin(amount);
				matrixCommand[10] = Math.cos(amount);
			},

			reuseRotateZCommand: function reuseRotateZCommand(matrixCommand, radians) {
				matrixCommand[0] = Math.cos(radians);
				matrixCommand[1] = Math.sin(radians);
				matrixCommand[4] = -Math.sin(radians);
				matrixCommand[5] = Math.cos(radians);
			},

			createRotateZ: function createRotateZ(radians) {
				var mat = MatrixMath.createIdentityMatrix();
				MatrixMath.reuseRotateZCommand(mat, radians);
				return mat;
			},

			reuseSkewXCommand: function reuseSkewXCommand(matrixCommand, radians) {
				matrixCommand[4] = Math.sin(radians);
				matrixCommand[5] = Math.cos(radians);
			},

			reuseSkewYCommand: function reuseSkewYCommand(matrixCommand, radians) {
				matrixCommand[0] = Math.cos(radians);
				matrixCommand[1] = Math.sin(radians);
			},

			multiplyInto: function multiplyInto(out, a, b) {
				var a00 = a[0],
				    a01 = a[1],
				    a02 = a[2],
				    a03 = a[3],
				    a10 = a[4],
				    a11 = a[5],
				    a12 = a[6],
				    a13 = a[7],
				    a20 = a[8],
				    a21 = a[9],
				    a22 = a[10],
				    a23 = a[11],
				    a30 = a[12],
				    a31 = a[13],
				    a32 = a[14],
				    a33 = a[15];

				var b0 = b[0],
				    b1 = b[1],
				    b2 = b[2],
				    b3 = b[3];
				out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

				b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
				out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

				b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
				out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

				b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
				out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
				out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
				out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
				out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
			},

			determinant: function determinant(matrix) {
				var _matrix = babelHelpers.slicedToArray(matrix, 16),
				    m00 = _matrix[0],
				    m01 = _matrix[1],
				    m02 = _matrix[2],
				    m03 = _matrix[3],
				    m10 = _matrix[4],
				    m11 = _matrix[5],
				    m12 = _matrix[6],
				    m13 = _matrix[7],
				    m20 = _matrix[8],
				    m21 = _matrix[9],
				    m22 = _matrix[10],
				    m23 = _matrix[11],
				    m30 = _matrix[12],
				    m31 = _matrix[13],
				    m32 = _matrix[14],
				    m33 = _matrix[15];
				return m03 * m12 * m21 * m30 - m02 * m13 * m21 * m30 - m03 * m11 * m22 * m30 + m01 * m13 * m22 * m30 + m02 * m11 * m23 * m30 - m01 * m12 * m23 * m30 - m03 * m12 * m20 * m31 + m02 * m13 * m20 * m31 + m03 * m10 * m22 * m31 - m00 * m13 * m22 * m31 - m02 * m10 * m23 * m31 + m00 * m12 * m23 * m31 + m03 * m11 * m20 * m32 - m01 * m13 * m20 * m32 - m03 * m10 * m21 * m32 + m00 * m13 * m21 * m32 + m01 * m10 * m23 * m32 - m00 * m11 * m23 * m32 - m02 * m11 * m20 * m33 + m01 * m12 * m20 * m33 + m02 * m10 * m21 * m33 - m00 * m12 * m21 * m33 - m01 * m10 * m22 * m33 + m00 * m11 * m22 * m33;
			},

			inverse: function inverse(matrix) {
				var det = MatrixMath.determinant(matrix);
				if (!det) {
					return matrix;
				}var _matrix2 = babelHelpers.slicedToArray(matrix, 16),
				    m00 = _matrix2[0],
				    m01 = _matrix2[1],
				    m02 = _matrix2[2],
				    m03 = _matrix2[3],
				    m10 = _matrix2[4],
				    m11 = _matrix2[5],
				    m12 = _matrix2[6],
				    m13 = _matrix2[7],
				    m20 = _matrix2[8],
				    m21 = _matrix2[9],
				    m22 = _matrix2[10],
				    m23 = _matrix2[11],
				    m30 = _matrix2[12],
				    m31 = _matrix2[13],
				    m32 = _matrix2[14],
				    m33 = _matrix2[15];
				return [(m12 * m23 * m31 - m13 * m22 * m31 + m13 * m21 * m32 - m11 * m23 * m32 - m12 * m21 * m33 + m11 * m22 * m33) / det, (m03 * m22 * m31 - m02 * m23 * m31 - m03 * m21 * m32 + m01 * m23 * m32 + m02 * m21 * m33 - m01 * m22 * m33) / det, (m02 * m13 * m31 - m03 * m12 * m31 + m03 * m11 * m32 - m01 * m13 * m32 - m02 * m11 * m33 + m01 * m12 * m33) / det, (m03 * m12 * m21 - m02 * m13 * m21 - m03 * m11 * m22 + m01 * m13 * m22 + m02 * m11 * m23 - m01 * m12 * m23) / det, (m13 * m22 * m30 - m12 * m23 * m30 - m13 * m20 * m32 + m10 * m23 * m32 + m12 * m20 * m33 - m10 * m22 * m33) / det, (m02 * m23 * m30 - m03 * m22 * m30 + m03 * m20 * m32 - m00 * m23 * m32 - m02 * m20 * m33 + m00 * m22 * m33) / det, (m03 * m12 * m30 - m02 * m13 * m30 - m03 * m10 * m32 + m00 * m13 * m32 + m02 * m10 * m33 - m00 * m12 * m33) / det, (m02 * m13 * m20 - m03 * m12 * m20 + m03 * m10 * m22 - m00 * m13 * m22 - m02 * m10 * m23 + m00 * m12 * m23) / det, (m11 * m23 * m30 - m13 * m21 * m30 + m13 * m20 * m31 - m10 * m23 * m31 - m11 * m20 * m33 + m10 * m21 * m33) / det, (m03 * m21 * m30 - m01 * m23 * m30 - m03 * m20 * m31 + m00 * m23 * m31 + m01 * m20 * m33 - m00 * m21 * m33) / det, (m01 * m13 * m30 - m03 * m11 * m30 + m03 * m10 * m31 - m00 * m13 * m31 - m01 * m10 * m33 + m00 * m11 * m33) / det, (m03 * m11 * m20 - m01 * m13 * m20 - m03 * m10 * m21 + m00 * m13 * m21 + m01 * m10 * m23 - m00 * m11 * m23) / det, (m12 * m21 * m30 - m11 * m22 * m30 - m12 * m20 * m31 + m10 * m22 * m31 + m11 * m20 * m32 - m10 * m21 * m32) / det, (m01 * m22 * m30 - m02 * m21 * m30 + m02 * m20 * m31 - m00 * m22 * m31 - m01 * m20 * m32 + m00 * m21 * m32) / det, (m02 * m11 * m30 - m01 * m12 * m30 - m02 * m10 * m31 + m00 * m12 * m31 + m01 * m10 * m32 - m00 * m11 * m32) / det, (m01 * m12 * m20 - m02 * m11 * m20 + m02 * m10 * m21 - m00 * m12 * m21 - m01 * m10 * m22 + m00 * m11 * m22) / det];
			},

			transpose: function transpose(m) {
				return [m[0], m[4], m[8], m[12], m[1], m[5], m[9], m[13], m[2], m[6], m[10], m[14], m[3], m[7], m[11], m[15]];
			},

			multiplyVectorByMatrix: function multiplyVectorByMatrix(v, m) {
				var _v = babelHelpers.slicedToArray(v, 4),
				    vx = _v[0],
				    vy = _v[1],
				    vz = _v[2],
				    vw = _v[3];
				return [vx * m[0] + vy * m[4] + vz * m[8] + vw * m[12], vx * m[1] + vy * m[5] + vz * m[9] + vw * m[13], vx * m[2] + vy * m[6] + vz * m[10] + vw * m[14], vx * m[3] + vy * m[7] + vz * m[11] + vw * m[15]];
			},

			v3Length: function v3Length(a) {
				return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
			},

			v3Normalize: function v3Normalize(vector, v3Length) {
				var im = 1 / (v3Length || MatrixMath.v3Length(vector));
				return [vector[0] * im, vector[1] * im, vector[2] * im];
			},

			v3Dot: function v3Dot(a, b) {
				return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
			},

			v3Combine: function v3Combine(a, b, aScale, bScale) {
				return [aScale * a[0] + bScale * b[0], aScale * a[1] + bScale * b[1], aScale * a[2] + bScale * b[2]];
			},

			v3Cross: function v3Cross(a, b) {
				return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
			},

			quaternionToDegreesXYZ: function quaternionToDegreesXYZ(q, matrix, row) {
				var _q = babelHelpers.slicedToArray(q, 4),
				    qx = _q[0],
				    qy = _q[1],
				    qz = _q[2],
				    qw = _q[3];
				var qw2 = qw * qw;
				var qx2 = qx * qx;
				var qy2 = qy * qy;
				var qz2 = qz * qz;
				var test = qx * qy + qz * qw;
				var unit = qw2 + qx2 + qy2 + qz2;
				var conv = 180 / Math.PI;

				if (test > 0.49999 * unit) {
					return [0, 2 * Math.atan2(qx, qw) * conv, 90];
				}
				if (test < -0.49999 * unit) {
					return [0, -2 * Math.atan2(qx, qw) * conv, -90];
				}

				return [MatrixMath.roundTo3Places(Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy2 - 2 * qz2) * conv), MatrixMath.roundTo3Places(Math.asin(2 * qx * qy + 2 * qz * qw) * conv)];
			},

			roundTo3Places: function roundTo3Places(n) {
				var arr = n.toString().split('e');
				return Math.round(arr[0] + 'e' + (arr[1] ? +arr[1] - 3 : 3)) * 0.001;
			},

			decomposeMatrix: function decomposeMatrix(transformMatrix) {

				invariant(transformMatrix.length === 16, 'Matrix decomposition needs a list of 3d matrix values, received %s', transformMatrix);

				var perspective = [];
				var quaternion = [];
				var scale = [];
				var skew = [];
				var translation = [];

				if (!transformMatrix[15]) {
					return;
				}
				var matrix = [];
				var perspectiveMatrix = [];
				for (var i = 0; i < 4; i++) {
					matrix.push([]);
					for (var j = 0; j < 4; j++) {
						var value = transformMatrix[i * 4 + j] / transformMatrix[15];
						matrix[i].push(value);
						perspectiveMatrix.push(j === 3 ? 0 : value);
					}
				}
				perspectiveMatrix[15] = 1;

				if (!MatrixMath.determinant(perspectiveMatrix)) {
					return;
				}

				if (matrix[0][3] !== 0 || matrix[1][3] !== 0 || matrix[2][3] !== 0) {

					var rightHandSide = [matrix[0][3], matrix[1][3], matrix[2][3], matrix[3][3]];

					var inversePerspectiveMatrix = MatrixMath.inverse(perspectiveMatrix);

					var transposedInversePerspectiveMatrix = MatrixMath.transpose(inversePerspectiveMatrix);

					var perspective = MatrixMath.multiplyVectorByMatrix(rightHandSide, transposedInversePerspectiveMatrix);
				} else {

					perspective[0] = perspective[1] = perspective[2] = 0;
					perspective[3] = 1;
				}

				for (var i = 0; i < 3; i++) {
					translation[i] = matrix[3][i];
				}

				var row = [];
				for (i = 0; i < 3; i++) {
					row[i] = [matrix[i][0], matrix[i][1], matrix[i][2]];
				}

				scale[0] = MatrixMath.v3Length(row[0]);
				row[0] = MatrixMath.v3Normalize(row[0], scale[0]);

				skew[0] = MatrixMath.v3Dot(row[0], row[1]);
				row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);

				skew[0] = MatrixMath.v3Dot(row[0], row[1]);
				row[1] = MatrixMath.v3Combine(row[1], row[0], 1.0, -skew[0]);

				scale[1] = MatrixMath.v3Length(row[1]);
				row[1] = MatrixMath.v3Normalize(row[1], scale[1]);
				skew[0] /= scale[1];

				skew[1] = MatrixMath.v3Dot(row[0], row[2]);
				row[2] = MatrixMath.v3Combine(row[2], row[0], 1.0, -skew[1]);
				skew[2] = MatrixMath.v3Dot(row[1], row[2]);
				row[2] = MatrixMath.v3Combine(row[2], row[1], 1.0, -skew[2]);

				scale[2] = MatrixMath.v3Length(row[2]);
				row[2] = MatrixMath.v3Normalize(row[2], scale[2]);
				skew[1] /= scale[2];
				skew[2] /= scale[2];

				var pdum3 = MatrixMath.v3Cross(row[1], row[2]);
				if (MatrixMath.v3Dot(row[0], pdum3) < 0) {
					for (i = 0; i < 3; i++) {
						scale[i] *= -1;
						row[i][0] *= -1;
						row[i][1] *= -1;
						row[i][2] *= -1;
					}
				}

				quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
				quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
				quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
				quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));

				if (row[2][1] > row[1][2]) {
					quaternion[0] = -quaternion[0];
				}
				if (row[0][2] > row[2][0]) {
					quaternion[1] = -quaternion[1];
				}
				if (row[1][0] > row[0][1]) {
					quaternion[2] = -quaternion[2];
				}

				var rotationDegrees;
				if (quaternion[0] < 0.001 && quaternion[0] >= 0 && quaternion[1] < 0.001 && quaternion[1] >= 0) {

					rotationDegrees = [0, 0, MatrixMath.roundTo3Places(Math.atan2(row[0][1], row[0][0]) * 180 / Math.PI)];
				} else {
					rotationDegrees = MatrixMath.quaternionToDegreesXYZ(quaternion, matrix, row);
				}

				return {
					rotationDegrees: rotationDegrees,
					perspective: perspective,
					quaternion: quaternion,
					scale: scale,
					skew: skew,
					translation: translation,

					rotate: rotationDegrees[2],
					rotateX: rotationDegrees[0],
					rotateY: rotationDegrees[1],
					scaleX: scale[0],
					scaleY: scale[1],
					translateX: translation[0],
					translateY: translation[1] };
			} };

		module.exports = MatrixMath;
	}, // Libraries/Utilities/differ/sizesDiffer.js
	function (__inner_require__, exports, module) {
		var dummySize = { width: undefined, height: undefined };

		var sizesDiffer = function sizesDiffer(one, two) {
			one = one || dummySize;
			two = two || dummySize;
			return one !== two && (one.width !== two.width || one.height !== two.height);
		};

		module.exports = sizesDiffer;
	}, // Libraries/Components/View/ReactNativeViewAttributes.js
	function (__inner_require__, exports, module) {
		var ReactNativeStyleAttributes = __inner_require__(44 /*Libraries/Components/View/ReactNativeStyleAttributes.js*/);

		var ReactNativeViewAttributes = {};

		ReactNativeViewAttributes.UIView = {
			pointerEvents: true,
			accessible: true,
			accessibilityLabel: true,
			accessibilityComponentType: true,
			accessibilityLiveRegion: true,
			accessibilityTraits: true,
			importantForAccessibility: true,
			testID: true,
			renderToHardwareTextureAndroid: true,
			shouldRasterizeIOS: true,
			onLayout: true,
			onAccessibilityTap: true,
			onMagicTap: true,
			collapsable: true,
			needsOffscreenAlphaCompositing: true,
			style: ReactNativeStyleAttributes };

		ReactNativeViewAttributes.RCTView = babelHelpers.extends({}, ReactNativeViewAttributes.UIView, {

			removeClippedSubviews: true });

		module.exports = ReactNativeViewAttributes;
	}, // Libraries/StyleSheet/StyleSheetPropType.js
	function (__inner_require__, exports, module) {
		var createStrictShapeTypeChecker = __inner_require__(40 /*Libraries/Utilities/createStrictShapeTypeChecker.js*/);
		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');

		function StyleSheetPropType(shape) {
			var shapePropType = createStrictShapeTypeChecker(shape);
			return function (props, propName, componentName, location) {
				var newProps = props;
				if (props[propName]) {

					newProps = {};
					newProps[propName] = flattenStyle(props[propName]);
				}
				return shapePropType(newProps, propName, componentName, location);
			};
		}

		module.exports = StyleSheetPropType;
	}, // Libraries/ReactIOS/requireNativeComponent.js
	function (__inner_require__, exports, module) {
		var ReactNativeStyleAttributes = __inner_require__(44 /*Libraries/Components/View/ReactNativeStyleAttributes.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var UnimplementedView = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);

		var createReactNativeComponentClass = __inner_require__(53 /*__react__/lib/createReactNativeComponentClass.js*/);

		var insetsDiffer = __inner_require__(69 /*Libraries/Utilities/differ/insetsDiffer.js*/);
		var pointsDiffer = __inner_require__(70 /*Libraries/Utilities/differ/pointsDiffer.js*/);
		var matricesDiffer = __inner_require__(45 /*Libraries/Utilities/differ/matricesDiffer.js*/);
		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');
		var resolveAssetSource = __inner_require__(71 /*Libraries/Image/resolveAssetSource.js*/);
		var sizesDiffer = __inner_require__(48 /*Libraries/Utilities/differ/sizesDiffer.js*/);
		var verifyPropTypes = __inner_require__(75 /*Libraries/ReactIOS/verifyPropTypes.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function requireNativeComponent(viewName, componentInterface, extraConfig) {
			var viewConfig = UIManager[viewName];
			if (!viewConfig || !viewConfig.NativeProps) {
				warning(false, 'Native component for "%s" does not exist', viewName);
				return UnimplementedView;
			}
			var nativeProps = babelHelpers.extends({}, UIManager.RCTView.NativeProps, viewConfig.NativeProps);

			viewConfig.uiViewClassName = viewName;
			viewConfig.validAttributes = {};
			viewConfig.propTypes = componentInterface && componentInterface.propTypes;
			for (var key in nativeProps) {
				var useAttribute = false;
				var attribute = {};

				var differ = TypeToDifferMap[nativeProps[key]];
				if (differ) {
					attribute.diff = differ;
					useAttribute = true;
				}

				var processor = TypeToProcessorMap[nativeProps[key]];
				if (processor) {
					attribute.process = processor;
					useAttribute = true;
				}

				viewConfig.validAttributes[key] = useAttribute ? attribute : true;
			}

			viewConfig.validAttributes.style = ReactNativeStyleAttributes;

			if (__DEV__) {
				componentInterface && verifyPropTypes(componentInterface, viewConfig, extraConfig && extraConfig.nativeOnly);
			}
			return createReactNativeComponentClass(viewConfig);
		}

		var TypeToDifferMap = {

			CATransform3D: matricesDiffer,
			CGPoint: pointsDiffer,
			CGSize: sizesDiffer,
			UIEdgeInsets: insetsDiffer };

		function processColorArray(colors) {
			return colors && colors.map(processColor);
		}

		var TypeToProcessorMap = {

			CGColor: processColor,
			CGColorArray: processColorArray,
			UIColor: processColor,
			UIColorArray: processColorArray,
			CGImage: resolveAssetSource,
			UIImage: resolveAssetSource,
			RCTImageSource: resolveAssetSource,

			Color: processColor,
			ColorArray: processColorArray };

		module.exports = requireNativeComponent;
	}, // Libraries/Components/UnimplementedViews/UnimplementedView.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);var UnimplementedView = function (_React$Component) {
			babelHelpers.inherits(UnimplementedView, _React$Component);function UnimplementedView() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, UnimplementedView);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = UnimplementedView.__proto__ || Object.getPrototypeOf(UnimplementedView)).call.apply(_ref, [this].concat(args))), _this), _this.setNativeProps = function () {}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(UnimplementedView, [{ key: 'render', value: function render() {

					var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
					return React.createElement(View, { style: [styles.unimplementedView, this.props.style] }, this.props.children);
				} }]);return UnimplementedView;
		}(React.Component);

		var styles = StyleSheet.create({
			unimplementedView: {
				borderWidth: 1,
				borderColor: 'red',
				alignSelf: 'flex-start' } });

		module.exports = UnimplementedView;
	}, // __react__/lib/createReactNativeComponentClass.js
	function (__inner_require__, exports, module) {
		var ReactNativeBaseComponent = __inner_require__(54 /*__react__/lib/ReactNativeBaseComponent.js*/);

		var createReactNativeComponentClass = function createReactNativeComponentClass(viewConfig) {
			var Constructor = function Constructor(element) {
				this._currentElement = element;
				this._topLevelWrapper = null;
				this._hostParent = null;
				this._hostContainerInfo = null;
				this._rootNodeID = 0;
				this._renderedChildren = null;
			};
			Constructor.displayName = viewConfig.uiViewClassName;
			Constructor.viewConfig = viewConfig;
			Constructor.propTypes = viewConfig.propTypes;
			Constructor.prototype = new ReactNativeBaseComponent(viewConfig);
			Constructor.prototype.constructor = Constructor;

			return Constructor;
		};

		module.exports = createReactNativeComponentClass;
	}, // __react__/lib/ReactNativeBaseComponent.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var ReactNativeAttributePayload = __inner_require__(4 /*__react__/lib/ReactNativeAttributePayload.js*/);
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactNativeEventEmitter = __inner_require__(55 /*__react__/lib/ReactNativeEventEmitter.js*/);
		var ReactNativeTagHandles = require('react-native@0.33/__react__/lib/ReactNativeTagHandles.js');
		var ReactMultiChild = __inner_require__(63 /*__react__/lib/ReactMultiChild.js*/);
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var deepFreezeAndThrowOnMutationInDev = __inner_require__(67 /*lib/deepFreezeAndThrowOnMutationInDev.js*/);

		var registrationNames = ReactNativeEventEmitter.registrationNames;
		var putListener = ReactNativeEventEmitter.putListener;
		var deleteListener = ReactNativeEventEmitter.deleteListener;
		var deleteAllListeners = ReactNativeEventEmitter.deleteAllListeners;

		var ReactNativeBaseComponent = function ReactNativeBaseComponent(viewConfig) {
			this.viewConfig = viewConfig;
		};

		ReactNativeBaseComponent.Mixin = {
			getPublicInstance: function getPublicInstance() {

				return this;
			},

			unmountComponent: function unmountComponent() {
				ReactNativeComponentTree.uncacheNode(this);
				deleteAllListeners(this);
				this.unmountChildren();
				this._rootNodeID = 0;
			},

			initializeChildren: function initializeChildren(children, containerTag, transaction, context) {
				var mountImages = this.mountChildren(children, transaction, context);

				if (mountImages.length) {

					var createdTags = [];
					for (var i = 0, l = mountImages.length; i < l; i++) {
						var mountImage = mountImages[i];
						var childTag = mountImage;
						createdTags[i] = childTag;
					}
					UIManager.setChildren(containerTag, createdTags);
				}
			},

			receiveComponent: function receiveComponent(nextElement, transaction, context) {
				var prevElement = this._currentElement;
				this._currentElement = nextElement;

				if (process.env.NODE_ENV !== 'production') {
					for (var key in this.viewConfig.validAttributes) {
						if (nextElement.props.hasOwnProperty(key)) {
							deepFreezeAndThrowOnMutationInDev(nextElement.props[key]);
						}
					}
				}

				var updatePayload = ReactNativeAttributePayload.diff(prevElement.props, nextElement.props, this.viewConfig.validAttributes);

				if (updatePayload) {
					UIManager.updateView(this._rootNodeID, this.viewConfig.uiViewClassName, updatePayload);
				}

				this._reconcileListenersUponUpdate(prevElement.props, nextElement.props);
				this.updateChildren(nextElement.props.children, transaction, context);
			},

			_registerListenersUponCreation: function _registerListenersUponCreation(initialProps) {
				for (var key in initialProps) {

					if (registrationNames[key] && initialProps[key]) {
						var listener = initialProps[key];
						putListener(this, key, listener);
					}
				}
			},

			_reconcileListenersUponUpdate: function _reconcileListenersUponUpdate(prevProps, nextProps) {
				for (var key in nextProps) {
					if (registrationNames[key] && nextProps[key] !== prevProps[key]) {
						if (nextProps[key]) {
							putListener(this, key, nextProps[key]);
						} else {
							deleteListener(this, key);
						}
					}
				}
			},

			getHostNode: function getHostNode() {
				return this._rootNodeID;
			},

			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
				var tag = ReactNativeTagHandles.allocateTag();

				this._rootNodeID = tag;
				this._hostParent = hostParent;
				this._hostContainerInfo = hostContainerInfo;

				if (process.env.NODE_ENV !== 'production') {
					for (var key in this.viewConfig.validAttributes) {
						if (this._currentElement.props.hasOwnProperty(key)) {
							deepFreezeAndThrowOnMutationInDev(this._currentElement.props[key]);
						}
					}
				}

				var updatePayload = ReactNativeAttributePayload.create(this._currentElement.props, this.viewConfig.validAttributes);

				var nativeTopRootTag = hostContainerInfo._tag;
				UIManager.createView(tag, this.viewConfig.uiViewClassName, nativeTopRootTag, updatePayload);

				ReactNativeComponentTree.precacheNode(this, tag);

				this._registerListenersUponCreation(this._currentElement.props);
				this.initializeChildren(this._currentElement.props.children, tag, transaction, context);
				return tag;
			} };

		_assign(ReactNativeBaseComponent.prototype, ReactMultiChild.Mixin, ReactNativeBaseComponent.Mixin, NativeMethodsMixin);

		module.exports = ReactNativeBaseComponent;
	}, // __react__/lib/ReactNativeEventEmitter.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var _extends = _assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}return target;
		};

		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var ReactEventEmitterMixin = __inner_require__(62 /*__react__/lib/ReactEventEmitterMixin.js*/);
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactNativeTagHandles = require('react-native@0.33/__react__/lib/ReactNativeTagHandles.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var topLevelTypes = EventConstants.topLevelTypes;

		var EMPTY_NATIVE_EVENT = {};

		var touchSubsequence = function touchSubsequence(touches, indices) {
			var ret = [];
			for (var i = 0; i < indices.length; i++) {
				ret.push(touches[indices[i]]);
			}
			return ret;
		};

		var removeTouchesAtIndices = function removeTouchesAtIndices(touches, indices) {
			var rippedOut = [];

			var temp = touches;
			for (var i = 0; i < indices.length; i++) {
				var index = indices[i];
				rippedOut.push(touches[index]);
				temp[index] = null;
			}
			var fillAt = 0;
			for (var j = 0; j < temp.length; j++) {
				var cur = temp[j];
				if (cur !== null) {
					temp[fillAt++] = cur;
				}
			}
			temp.length = fillAt;
			return rippedOut;
		};

		var ReactNativeEventEmitter = _extends({}, ReactEventEmitterMixin, {

			registrationNames: EventPluginRegistry.registrationNameModules,

			putListener: EventPluginHub.putListener,

			getListener: EventPluginHub.getListener,

			deleteListener: EventPluginHub.deleteListener,

			deleteAllListeners: EventPluginHub.deleteAllListeners,

			_receiveRootNodeIDEvent: function _receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam) {
				var nativeEvent = nativeEventParam || EMPTY_NATIVE_EVENT;
				var inst = ReactNativeComponentTree.getInstanceFromNode(rootNodeID);
				if (!inst) {

					return;
				}
				ReactUpdates.batchedUpdates(function () {
					ReactNativeEventEmitter.handleTopLevel(topLevelType, inst, nativeEvent, nativeEvent.target);
				});
			},

			receiveEvent: function receiveEvent(tag, topLevelType, nativeEventParam) {
				var rootNodeID = tag;
				ReactNativeEventEmitter._receiveRootNodeIDEvent(rootNodeID, topLevelType, nativeEventParam);
			},

			receiveTouches: function receiveTouches(eventTopLevelType, touches, changedIndices) {
				var changedTouches = eventTopLevelType === topLevelTypes.topTouchEnd || eventTopLevelType === topLevelTypes.topTouchCancel ? removeTouchesAtIndices(touches, changedIndices) : touchSubsequence(touches, changedIndices);

				for (var jj = 0; jj < changedTouches.length; jj++) {
					var touch = changedTouches[jj];

					touch.changedTouches = changedTouches;
					touch.touches = touches;
					var nativeEvent = touch;
					var rootNodeID = null;
					var target = nativeEvent.target;
					if (target !== null && target !== undefined) {
						if (target < ReactNativeTagHandles.tagsStartAt) {
							if (process.env.NODE_ENV !== 'production') {
								process.env.NODE_ENV !== 'production' ? warning(false, 'A view is reporting that a touch occured on tag zero.') : void 0;
							}
						} else {
							rootNodeID = target;
						}
					}
					ReactNativeEventEmitter._receiveRootNodeIDEvent(rootNodeID, eventTopLevelType, nativeEvent);
				}
			} });

		module.exports = ReactNativeEventEmitter;
	}, // __react__/lib/EventConstants.js
	function (__inner_require__, exports, module) {
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var PropagationPhases = keyMirror({ bubbled: null, captured: null });

		var topLevelTypes = keyMirror({
			topAbort: null,
			topAnimationEnd: null,
			topAnimationIteration: null,
			topAnimationStart: null,
			topBlur: null,
			topCanPlay: null,
			topCanPlayThrough: null,
			topChange: null,
			topClick: null,
			topCompositionEnd: null,
			topCompositionStart: null,
			topCompositionUpdate: null,
			topContextMenu: null,
			topCopy: null,
			topCut: null,
			topDoubleClick: null,
			topDrag: null,
			topDragEnd: null,
			topDragEnter: null,
			topDragExit: null,
			topDragLeave: null,
			topDragOver: null,
			topDragStart: null,
			topDrop: null,
			topDurationChange: null,
			topEmptied: null,
			topEncrypted: null,
			topEnded: null,
			topError: null,
			topFocus: null,
			topInput: null,
			topInvalid: null,
			topKeyDown: null,
			topKeyPress: null,
			topKeyUp: null,
			topLoad: null,
			topLoadedData: null,
			topLoadedMetadata: null,
			topLoadStart: null,
			topMouseDown: null,
			topMouseMove: null,
			topMouseOut: null,
			topMouseOver: null,
			topMouseUp: null,
			topPaste: null,
			topPause: null,
			topPlay: null,
			topPlaying: null,
			topProgress: null,
			topRateChange: null,
			topReset: null,
			topScroll: null,
			topSeeked: null,
			topSeeking: null,
			topSelectionChange: null,
			topStalled: null,
			topSubmit: null,
			topSuspend: null,
			topTextInput: null,
			topTimeUpdate: null,
			topTouchCancel: null,
			topTouchEnd: null,
			topTouchMove: null,
			topTouchStart: null,
			topTransitionEnd: null,
			topVolumeChange: null,
			topWaiting: null,
			topWheel: null });

		var EventConstants = {
			topLevelTypes: topLevelTypes,
			PropagationPhases: PropagationPhases };

		module.exports = EventConstants;
	}, // __react__/lib/EventPluginHub.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);
		var ReactErrorUtils = require('react-native@0.33/__react__/lib/ReactErrorUtils.js');

		var accumulateInto = __inner_require__(60 /*__react__/lib/accumulateInto.js*/);
		var forEachAccumulated = __inner_require__(61 /*__react__/lib/forEachAccumulated.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var listenerBank = {};

		var eventQueue = null;

		var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
			if (event) {
				EventPluginUtils.executeDispatchesInOrder(event, simulated);

				if (!event.isPersistent()) {
					event.constructor.release(event);
				}
			}
		};
		var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
			return executeDispatchesAndRelease(e, true);
		};
		var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
			return executeDispatchesAndRelease(e, false);
		};

		var getDictionaryKey = function getDictionaryKey(inst) {

			return '.' + inst._rootNodeID;
		};

		var EventPluginHub = {

			injection: {

				injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

				injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName },

			putListener: function putListener(inst, registrationName, listener) {
				!(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

				var key = getDictionaryKey(inst);
				var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
				bankForRegistrationName[key] = listener;

				var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
				if (PluginModule && PluginModule.didPutListener) {
					PluginModule.didPutListener(inst, registrationName, listener);
				}
			},

			getListener: function getListener(inst, registrationName) {
				var bankForRegistrationName = listenerBank[registrationName];
				var key = getDictionaryKey(inst);
				return bankForRegistrationName && bankForRegistrationName[key];
			},

			deleteListener: function deleteListener(inst, registrationName) {
				var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
				if (PluginModule && PluginModule.willDeleteListener) {
					PluginModule.willDeleteListener(inst, registrationName);
				}

				var bankForRegistrationName = listenerBank[registrationName];

				if (bankForRegistrationName) {
					var key = getDictionaryKey(inst);
					delete bankForRegistrationName[key];
				}
			},

			deleteAllListeners: function deleteAllListeners(inst) {
				var key = getDictionaryKey(inst);
				for (var registrationName in listenerBank) {
					if (!listenerBank.hasOwnProperty(registrationName)) {
						continue;
					}

					if (!listenerBank[registrationName][key]) {
						continue;
					}

					var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
					if (PluginModule && PluginModule.willDeleteListener) {
						PluginModule.willDeleteListener(inst, registrationName);
					}

					delete listenerBank[registrationName][key];
				}
			},

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				var events;
				var plugins = EventPluginRegistry.plugins;
				for (var i = 0; i < plugins.length; i++) {

					var possiblePlugin = plugins[i];
					if (possiblePlugin) {
						var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
						if (extractedEvents) {
							events = accumulateInto(events, extractedEvents);
						}
					}
				}
				return events;
			},

			enqueueEvents: function enqueueEvents(events) {
				if (events) {
					eventQueue = accumulateInto(eventQueue, events);
				}
			},

			processEventQueue: function processEventQueue(simulated) {

				var processingEventQueue = eventQueue;
				eventQueue = null;
				if (simulated) {
					forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
				} else {
					forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
				}
				!!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;

				ReactErrorUtils.rethrowCaughtError();
			},

			__purge: function __purge() {
				listenerBank = {};
			},

			__getListenerBank: function __getListenerBank() {
				return listenerBank;
			} };

		module.exports = EventPluginHub;
	}, // __react__/lib/EventPluginRegistry.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var EventPluginOrder = null;

		var namesToPlugins = {};

		function recomputePluginOrdering() {
			if (!EventPluginOrder) {

				return;
			}
			for (var pluginName in namesToPlugins) {
				var PluginModule = namesToPlugins[pluginName];
				var pluginIndex = EventPluginOrder.indexOf(pluginName);
				!(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
				if (EventPluginRegistry.plugins[pluginIndex]) {
					continue;
				}
				!PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
				EventPluginRegistry.plugins[pluginIndex] = PluginModule;
				var publishedEvents = PluginModule.eventTypes;
				for (var eventName in publishedEvents) {
					!publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
				}
			}
		}

		function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
			!!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
			EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

			var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
			if (phasedRegistrationNames) {
				for (var phaseName in phasedRegistrationNames) {
					if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
						var phasedRegistrationName = phasedRegistrationNames[phaseName];
						publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
					}
				}
				return true;
			} else if (dispatchConfig.registrationName) {
				publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
				return true;
			}
			return false;
		}

		function publishRegistrationName(registrationName, PluginModule, eventName) {
			!!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
			EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
			EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;

			if (process.env.NODE_ENV !== 'production') {
				var lowerCasedName = registrationName.toLowerCase();
				EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

				if (registrationName === 'onDoubleClick') {
					EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
				}
			}
		}

		var EventPluginRegistry = {

			plugins: [],

			eventNameDispatchConfigs: {},

			registrationNameModules: {},

			registrationNameDependencies: {},

			possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,

			injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
				!!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;

				EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
				recomputePluginOrdering();
			},

			injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
				var isOrderingDirty = false;
				for (var pluginName in injectedNamesToPlugins) {
					if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
						continue;
					}
					var PluginModule = injectedNamesToPlugins[pluginName];
					if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
						!!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
						namesToPlugins[pluginName] = PluginModule;
						isOrderingDirty = true;
					}
				}
				if (isOrderingDirty) {
					recomputePluginOrdering();
				}
			},

			getPluginModuleForEvent: function getPluginModuleForEvent(event) {
				var dispatchConfig = event.dispatchConfig;
				if (dispatchConfig.registrationName) {
					return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
				}
				for (var phase in dispatchConfig.phasedRegistrationNames) {
					if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
						continue;
					}
					var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
					if (PluginModule) {
						return PluginModule;
					}
				}
				return null;
			},

			_resetEventPlugins: function _resetEventPlugins() {
				EventPluginOrder = null;
				for (var pluginName in namesToPlugins) {
					if (namesToPlugins.hasOwnProperty(pluginName)) {
						delete namesToPlugins[pluginName];
					}
				}
				EventPluginRegistry.plugins.length = 0;

				var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
				for (var eventName in eventNameDispatchConfigs) {
					if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
						delete eventNameDispatchConfigs[eventName];
					}
				}

				var registrationNameModules = EventPluginRegistry.registrationNameModules;
				for (var registrationName in registrationNameModules) {
					if (registrationNameModules.hasOwnProperty(registrationName)) {
						delete registrationNameModules[registrationName];
					}
				}

				if (process.env.NODE_ENV !== 'production') {
					var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
					for (var lowerCasedName in possibleRegistrationNames) {
						if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
							delete possibleRegistrationNames[lowerCasedName];
						}
					}
				}
			} };

		module.exports = EventPluginRegistry;
	}, // __react__/lib/EventPluginUtils.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var ReactErrorUtils = require('react-native@0.33/__react__/lib/ReactErrorUtils.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ComponentTree;
		var TreeTraversal;
		var injection = {
			injectComponentTree: function injectComponentTree(Injected) {
				ComponentTree = Injected;
				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
				}
			},
			injectTreeTraversal: function injectTreeTraversal(Injected) {
				TreeTraversal = Injected;
				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
				}
			} };

		var topLevelTypes = EventConstants.topLevelTypes;

		function isEndish(topLevelType) {
			return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
		}

		function isMoveish(topLevelType) {
			return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
		}
		function isStartish(topLevelType) {
			return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
		}

		var validateEventDispatches;
		if (process.env.NODE_ENV !== 'production') {
			validateEventDispatches = function validateEventDispatches(event) {
				var dispatchListeners = event._dispatchListeners;
				var dispatchInstances = event._dispatchInstances;

				var listenersIsArr = Array.isArray(dispatchListeners);
				var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

				var instancesIsArr = Array.isArray(dispatchInstances);
				var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

				process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
			};
		}

		function executeDispatch(event, simulated, listener, inst) {
			var type = event.type || 'unknown-event';
			event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
			if (simulated) {
				ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
			} else {
				ReactErrorUtils.invokeGuardedCallback(type, listener, event);
			}
			event.currentTarget = null;
		}

		function executeDispatchesInOrder(event, simulated) {
			var dispatchListeners = event._dispatchListeners;
			var dispatchInstances = event._dispatchInstances;
			if (process.env.NODE_ENV !== 'production') {
				validateEventDispatches(event);
			}
			if (Array.isArray(dispatchListeners)) {
				for (var i = 0; i < dispatchListeners.length; i++) {
					if (event.isPropagationStopped()) {
						break;
					}

					executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
				}
			} else if (dispatchListeners) {
				executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
			}
			event._dispatchListeners = null;
			event._dispatchInstances = null;
		}

		function executeDispatchesInOrderStopAtTrueImpl(event) {
			var dispatchListeners = event._dispatchListeners;
			var dispatchInstances = event._dispatchInstances;
			if (process.env.NODE_ENV !== 'production') {
				validateEventDispatches(event);
			}
			if (Array.isArray(dispatchListeners)) {
				for (var i = 0; i < dispatchListeners.length; i++) {
					if (event.isPropagationStopped()) {
						break;
					}

					if (dispatchListeners[i](event, dispatchInstances[i])) {
						return dispatchInstances[i];
					}
				}
			} else if (dispatchListeners) {
				if (dispatchListeners(event, dispatchInstances)) {
					return dispatchInstances;
				}
			}
			return null;
		}

		function executeDispatchesInOrderStopAtTrue(event) {
			var ret = executeDispatchesInOrderStopAtTrueImpl(event);
			event._dispatchInstances = null;
			event._dispatchListeners = null;
			return ret;
		}

		function executeDirectDispatch(event) {
			if (process.env.NODE_ENV !== 'production') {
				validateEventDispatches(event);
			}
			var dispatchListener = event._dispatchListeners;
			var dispatchInstance = event._dispatchInstances;
			!!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
			event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
			var res = dispatchListener ? dispatchListener(event) : null;
			event.currentTarget = null;
			event._dispatchListeners = null;
			event._dispatchInstances = null;
			return res;
		}

		function hasDispatches(event) {
			return !!event._dispatchListeners;
		}

		var EventPluginUtils = {
			isEndish: isEndish,
			isMoveish: isMoveish,
			isStartish: isStartish,

			executeDirectDispatch: executeDirectDispatch,
			executeDispatchesInOrder: executeDispatchesInOrder,
			executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
			hasDispatches: hasDispatches,

			getInstanceFromNode: function getInstanceFromNode(node) {
				return ComponentTree.getInstanceFromNode(node);
			},
			getNodeFromInstance: function getNodeFromInstance(node) {
				return ComponentTree.getNodeFromInstance(node);
			},
			isAncestor: function isAncestor(a, b) {
				return TreeTraversal.isAncestor(a, b);
			},
			getLowestCommonAncestor: function getLowestCommonAncestor(a, b) {
				return TreeTraversal.getLowestCommonAncestor(a, b);
			},
			getParentInstance: function getParentInstance(inst) {
				return TreeTraversal.getParentInstance(inst);
			},
			traverseTwoPhase: function traverseTwoPhase(target, fn, arg) {
				return TreeTraversal.traverseTwoPhase(target, fn, arg);
			},
			traverseEnterLeave: function traverseEnterLeave(from, to, fn, argFrom, argTo) {
				return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
			},

			injection: injection };

		module.exports = EventPluginUtils;
	}, // __react__/lib/accumulateInto.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function accumulateInto(current, next) {
			!(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

			if (current == null) {
				return next;
			}

			if (Array.isArray(current)) {
				if (Array.isArray(next)) {
					current.push.apply(current, next);
					return current;
				}
				current.push(next);
				return current;
			}

			if (Array.isArray(next)) {

				return [current].concat(next);
			}

			return [current, next];
		}

		module.exports = accumulateInto;
	}, // __react__/lib/forEachAccumulated.js
	function (__inner_require__, exports, module) {
		function forEachAccumulated(arr, cb, scope) {
			if (Array.isArray(arr)) {
				arr.forEach(cb, scope);
			} else if (arr) {
				cb.call(scope, arr);
			}
		}

		module.exports = forEachAccumulated;
	}, // __react__/lib/ReactEventEmitterMixin.js
	function (__inner_require__, exports, module) {
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);

		function runEventQueueInBatch(events) {
			EventPluginHub.enqueueEvents(events);
			EventPluginHub.processEventQueue(false);
		}

		var ReactEventEmitterMixin = {

			handleTopLevel: function handleTopLevel(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
				runEventQueueInBatch(events);
			} };

		module.exports = ReactEventEmitterMixin;
	}, // __react__/lib/ReactMultiChild.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactComponentEnvironment = require('react-native@0.33/__react__/lib/ReactComponentEnvironment.js');
		var ReactInstanceMap = require('react-native@0.33/__react__/lib/ReactInstanceMap.js');
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var ReactMultiChildUpdateTypes = __inner_require__(64 /*__react__/lib/ReactMultiChildUpdateTypes.js*/);

		var ReactCurrentOwner = require('react-native@0.33/__react__/lib/ReactCurrentOwner.js');
		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');
		var ReactChildReconciler = __inner_require__(65 /*__react__/lib/ReactChildReconciler.js*/);

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var flattenChildren = __inner_require__(66 /*__react__/lib/flattenChildren.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function makeInsertMarkup(markup, afterNode, toIndex) {

			return {
				type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
				content: markup,
				fromIndex: null,
				fromNode: null,
				toIndex: toIndex,
				afterNode: afterNode };
		}

		function makeMove(child, afterNode, toIndex) {

			return {
				type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
				content: null,
				fromIndex: child._mountIndex,
				fromNode: ReactReconciler.getHostNode(child),
				toIndex: toIndex,
				afterNode: afterNode };
		}

		function makeRemove(child, node) {

			return {
				type: ReactMultiChildUpdateTypes.REMOVE_NODE,
				content: null,
				fromIndex: child._mountIndex,
				fromNode: node,
				toIndex: null,
				afterNode: null };
		}

		function makeSetMarkup(markup) {

			return {
				type: ReactMultiChildUpdateTypes.SET_MARKUP,
				content: markup,
				fromIndex: null,
				fromNode: null,
				toIndex: null,
				afterNode: null };
		}

		function makeTextContent(textContent) {

			return {
				type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
				content: textContent,
				fromIndex: null,
				fromNode: null,
				toIndex: null,
				afterNode: null };
		}

		function enqueue(queue, update) {
			if (update) {
				queue = queue || [];
				queue.push(update);
			}
			return queue;
		}

		function processQueue(inst, updateQueue) {
			ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
		}

		var setChildrenForInstrumentation = emptyFunction;
		if (process.env.NODE_ENV !== 'production') {
			var getDebugID = function getDebugID(inst) {
				if (!inst._debugID) {

					var internal;
					if (internal = ReactInstanceMap.get(inst)) {
						inst = internal;
					}
				}
				return inst._debugID;
			};
			setChildrenForInstrumentation = function setChildrenForInstrumentation(children) {
				var debugID = getDebugID(this);

				if (debugID !== 0) {
					ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
						return children[key]._debugID;
					}) : []);
				}
			};
		}

		var ReactMultiChild = {

			Mixin: {

				_reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
					if (process.env.NODE_ENV !== 'production') {
						var selfDebugID = getDebugID(this);
						if (this._currentElement) {
							try {
								ReactCurrentOwner.current = this._currentElement._owner;
								return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
							} finally {
								ReactCurrentOwner.current = null;
							}
						}
					}
					return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
				},

				_reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
					var nextChildren;
					var selfDebugID = 0;
					if (process.env.NODE_ENV !== 'production') {
						selfDebugID = getDebugID(this);
						if (this._currentElement) {
							try {
								ReactCurrentOwner.current = this._currentElement._owner;
								nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
							} finally {
								ReactCurrentOwner.current = null;
							}
							ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
							return nextChildren;
						}
					}
					nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
					ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
					return nextChildren;
				},

				mountChildren: function mountChildren(nestedChildren, transaction, context) {
					var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
					this._renderedChildren = children;

					var mountImages = [];
					var index = 0;
					for (var name in children) {
						if (children.hasOwnProperty(name)) {
							var child = children[name];
							var selfDebugID = 0;
							if (process.env.NODE_ENV !== 'production') {
								selfDebugID = getDebugID(this);
							}
							var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
							child._mountIndex = index++;
							mountImages.push(mountImage);
						}
					}

					if (process.env.NODE_ENV !== 'production') {
						setChildrenForInstrumentation.call(this, children);
					}

					return mountImages;
				},

				updateTextContent: function updateTextContent(nextContent) {
					var prevChildren = this._renderedChildren;

					ReactChildReconciler.unmountChildren(prevChildren, false);
					for (var name in prevChildren) {
						if (prevChildren.hasOwnProperty(name)) {
							!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
						}
					}

					var updates = [makeTextContent(nextContent)];
					processQueue(this, updates);
				},

				updateMarkup: function updateMarkup(nextMarkup) {
					var prevChildren = this._renderedChildren;

					ReactChildReconciler.unmountChildren(prevChildren, false);
					for (var name in prevChildren) {
						if (prevChildren.hasOwnProperty(name)) {
							!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
						}
					}
					var updates = [makeSetMarkup(nextMarkup)];
					processQueue(this, updates);
				},

				updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {

					this._updateChildren(nextNestedChildrenElements, transaction, context);
				},

				_updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
					var prevChildren = this._renderedChildren;
					var removedNodes = {};
					var mountImages = [];
					var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
					if (!nextChildren && !prevChildren) {
						return;
					}
					var updates = null;
					var name;

					var nextIndex = 0;
					var lastIndex = 0;

					var nextMountIndex = 0;
					var lastPlacedNode = null;
					for (name in nextChildren) {
						if (!nextChildren.hasOwnProperty(name)) {
							continue;
						}
						var prevChild = prevChildren && prevChildren[name];
						var nextChild = nextChildren[name];
						if (prevChild === nextChild) {
							updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
							lastIndex = Math.max(prevChild._mountIndex, lastIndex);
							prevChild._mountIndex = nextIndex;
						} else {
							if (prevChild) {

								lastIndex = Math.max(prevChild._mountIndex, lastIndex);
							}

							updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
							nextMountIndex++;
						}
						nextIndex++;
						lastPlacedNode = ReactReconciler.getHostNode(nextChild);
					}

					for (name in removedNodes) {
						if (removedNodes.hasOwnProperty(name)) {
							updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
						}
					}
					if (updates) {
						processQueue(this, updates);
					}
					this._renderedChildren = nextChildren;

					if (process.env.NODE_ENV !== 'production') {
						setChildrenForInstrumentation.call(this, nextChildren);
					}
				},

				unmountChildren: function unmountChildren(safely) {
					var renderedChildren = this._renderedChildren;
					ReactChildReconciler.unmountChildren(renderedChildren, safely);
					this._renderedChildren = null;
				},

				moveChild: function moveChild(child, afterNode, toIndex, lastIndex) {

					if (child._mountIndex < lastIndex) {
						return makeMove(child, afterNode, toIndex);
					}
				},

				createChild: function createChild(child, afterNode, mountImage) {
					return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
				},

				removeChild: function removeChild(child, node) {
					return makeRemove(child, node);
				},

				_mountChildAtIndex: function _mountChildAtIndex(child, mountImage, afterNode, index, transaction, context) {
					child._mountIndex = index;
					return this.createChild(child, afterNode, mountImage);
				},

				_unmountChild: function _unmountChild(child, node) {
					var update = this.removeChild(child, node);
					child._mountIndex = null;
					return update;
				} } };

		module.exports = ReactMultiChild;
	}, // __react__/lib/ReactMultiChildUpdateTypes.js
	function (__inner_require__, exports, module) {
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var ReactMultiChildUpdateTypes = keyMirror({
			INSERT_MARKUP: null,
			MOVE_EXISTING: null,
			REMOVE_NODE: null,
			SET_MARKUP: null,
			TEXT_CONTENT: null });

		module.exports = ReactMultiChildUpdateTypes;
	}, // __react__/lib/ReactChildReconciler.js
	function (__inner_require__, exports, module) {
		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');

		var instantiateReactComponent = require('react-native@0.33/__react__/lib/instantiateReactComponent.js');
		var KeyEscapeUtils = __inner_require__(16 /*__react__/lib/KeyEscapeUtils.js*/);
		var shouldUpdateReactComponent = require('react-native@0.33/__react__/lib/shouldUpdateReactComponent.js');
		var traverseAllChildren = __inner_require__(15 /*__react__/lib/traverseAllChildren.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ReactComponentTreeHook;

		if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {

			ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');
		}

		function instantiateChild(childInstances, child, name, selfDebugID) {

			var keyUnique = childInstances[name] === undefined;
			if (process.env.NODE_ENV !== 'production') {
				if (!ReactComponentTreeHook) {
					ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');
				}
				if (!keyUnique) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
				}
			}
			if (child != null && keyUnique) {
				childInstances[name] = instantiateReactComponent(child, true);
			}
		}

		var ReactChildReconciler = {

			instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context, selfDebugID) {
				if (nestedChildNodes == null) {
					return null;
				}
				var childInstances = {};

				if (process.env.NODE_ENV !== 'production') {
					traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
						return instantiateChild(childInsts, child, name, selfDebugID);
					}, childInstances);
				} else {
					traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
				}
				return childInstances;
			},

			updateChildren: function updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID) {

				if (!nextChildren && !prevChildren) {
					return;
				}
				var name;
				var prevChild;
				for (name in nextChildren) {
					if (!nextChildren.hasOwnProperty(name)) {
						continue;
					}
					prevChild = prevChildren && prevChildren[name];
					var prevElement = prevChild && prevChild._currentElement;
					var nextElement = nextChildren[name];
					if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
						ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
						nextChildren[name] = prevChild;
					} else {
						if (prevChild) {
							removedNodes[name] = ReactReconciler.getHostNode(prevChild);
							ReactReconciler.unmountComponent(prevChild, false);
						}

						var nextChildInstance = instantiateReactComponent(nextElement, true);
						nextChildren[name] = nextChildInstance;

						var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
						mountImages.push(nextChildMountImage);
					}
				}

				for (name in prevChildren) {
					if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
						prevChild = prevChildren[name];
						removedNodes[name] = ReactReconciler.getHostNode(prevChild);
						ReactReconciler.unmountComponent(prevChild, false);
					}
				}
			},

			unmountChildren: function unmountChildren(renderedChildren, safely) {
				for (var name in renderedChildren) {
					if (renderedChildren.hasOwnProperty(name)) {
						var renderedChild = renderedChildren[name];
						ReactReconciler.unmountComponent(renderedChild, safely);
					}
				}
			} };

		module.exports = ReactChildReconciler;
	}, // __react__/lib/flattenChildren.js
	function (__inner_require__, exports, module) {
		var KeyEscapeUtils = __inner_require__(16 /*__react__/lib/KeyEscapeUtils.js*/);
		var traverseAllChildren = __inner_require__(15 /*__react__/lib/traverseAllChildren.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ReactComponentTreeHook;

		if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {

			ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');
		}

		function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {

			if (traverseContext && typeof traverseContext === 'object') {
				var result = traverseContext;
				var keyUnique = result[name] === undefined;
				if (process.env.NODE_ENV !== 'production') {
					if (!ReactComponentTreeHook) {
						ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');
					}
					if (!keyUnique) {
						process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
					}
				}
				if (keyUnique && child != null) {
					result[name] = child;
				}
			}
		}

		function flattenChildren(children, selfDebugID) {
			if (children == null) {
				return children;
			}
			var result = {};

			if (process.env.NODE_ENV !== 'production') {
				traverseAllChildren(children, function (traverseContext, child, name) {
					return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
				}, result);
			} else {
				traverseAllChildren(children, flattenSingleChildIntoContext, result);
			}
			return result;
		}

		module.exports = flattenChildren;
	}, // lib/deepFreezeAndThrowOnMutationInDev.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(68 /*Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js*/);
	}, // Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js
	function (__inner_require__, exports, module) {
		function deepFreezeAndThrowOnMutationInDev(object) {
			if (__DEV__) {
				if (typeof object !== 'object' || object === null || Object.isFrozen(object) || Object.isSealed(object)) {
					return;
				}

				for (var key in object) {
					if (object.hasOwnProperty(key)) {
						object.__defineGetter__(key, identity.bind(null, object[key]));
						object.__defineSetter__(key, throwOnImmutableMutation.bind(null, key));
					}
				}

				Object.freeze(object);
				Object.seal(object);

				for (var key in object) {
					if (object.hasOwnProperty(key)) {
						deepFreezeAndThrowOnMutationInDev(object[key]);
					}
				}
			}
		}

		function throwOnImmutableMutation(key, value) {
			throw Error('You attempted to set the key `' + key + '` with the value `' + JSON.stringify(value) + '` on an object that is meant to be immutable ' + 'and has been frozen.');
		}

		function identity(value) {
			return value;
		}

		module.exports = deepFreezeAndThrowOnMutationInDev;
	}, // Libraries/Utilities/differ/insetsDiffer.js
	function (__inner_require__, exports, module) {
		var dummyInsets = {
			top: undefined,
			left: undefined,
			right: undefined,
			bottom: undefined };

		var insetsDiffer = function insetsDiffer(one, two) {
			one = one || dummyInsets;
			two = two || dummyInsets;
			return one !== two && (one.top !== two.top || one.left !== two.left || one.right !== two.right || one.bottom !== two.bottom);
		};

		module.exports = insetsDiffer;
	}, // Libraries/Utilities/differ/pointsDiffer.js
	function (__inner_require__, exports, module) {
		var dummyPoint = { x: undefined, y: undefined };

		var pointsDiffer = function pointsDiffer(one, two) {
			one = one || dummyPoint;
			two = two || dummyPoint;
			return one !== two && (one.x !== two.x || one.y !== two.y);
		};

		module.exports = pointsDiffer;
	}, // Libraries/Image/resolveAssetSource.js
	function (__inner_require__, exports, module) {
		var AssetRegistry = __inner_require__(72 /*Libraries/Image/AssetRegistry.js*/);
		var AssetSourceResolver = __inner_require__(73 /*Libraries/Image/AssetSourceResolver.js*/);var _require = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js'),
		    SourceCode = _require.SourceCode;

		var _customSourceTransformer = void 0,
		    _serverURL = void 0,
		    _bundleSourcePath = void 0;

		function getDevServerURL() {
			if (_serverURL === undefined) {
				var scriptURL = SourceCode.scriptURL;
				var match = scriptURL && scriptURL.match(/^https?:\/\/.*?\//);
				if (match) {

					_serverURL = match[0];
				} else {

					_serverURL = null;
				}
			}
			return _serverURL;
		}

		function getBundleSourcePath() {
			if (_bundleSourcePath === undefined) {
				var scriptURL = SourceCode.scriptURL;
				if (!scriptURL) {

					_bundleSourcePath = null;
					return _bundleSourcePath;
				}
				if (scriptURL.startsWith('assets://')) {

					_bundleSourcePath = null;
					return _bundleSourcePath;
				}
				if (scriptURL.startsWith('file://')) {

					_bundleSourcePath = scriptURL.substring(7, scriptURL.lastIndexOf('/') + 1);
				} else {
					_bundleSourcePath = scriptURL.substring(0, scriptURL.lastIndexOf('/') + 1);
				}
			}

			return _bundleSourcePath;
		}

		function setCustomSourceTransformer(transformer) {
			_customSourceTransformer = transformer;
		}

		function resolveAssetSource(source) {
			if (typeof source === 'object') {
				return source;
			}

			var asset = AssetRegistry.getAssetByID(source);
			if (!asset) {
				return null;
			}

			var resolver = new AssetSourceResolver(getDevServerURL(), getBundleSourcePath(), asset);
			if (_customSourceTransformer) {
				return _customSourceTransformer(resolver);
			}
			return resolver.defaultAsset();
		}

		module.exports = resolveAssetSource;
		module.exports.pickScale = AssetSourceResolver.pickScale;
		module.exports.setCustomSourceTransformer = setCustomSourceTransformer;
	}, // Libraries/Image/AssetRegistry.js
	function (__inner_require__, exports, module) {
		var assets = [];

		function registerAsset(asset) {

			return assets.push(asset);
		}

		function getAssetByID(assetId) {
			return assets[assetId - 1];
		}

		module.exports = { registerAsset: registerAsset, getAssetByID: getAssetByID };
	}, // Libraries/Image/AssetSourceResolver.js
	function (__inner_require__, exports, module) {
		var PixelRatio = __inner_require__(27 /*Libraries/Utilities/PixelRatio.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');

		var assetPathUtils = __inner_require__(74 /*local-cli/bundle/assetPathUtils.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function getScaledAssetPath(asset) {
			var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
			var scaleSuffix = scale === 1 ? '' : '@' + scale + 'x';
			var assetDir = assetPathUtils.getBasePath(asset);
			return assetDir + '/' + asset.name + scaleSuffix + '.' + asset.type;
		}

		function getAssetPathInDrawableFolder(asset) {
			var scale = AssetSourceResolver.pickScale(asset.scales, PixelRatio.get());
			var drawbleFolder = assetPathUtils.getAndroidDrawableFolderName(asset, scale);
			var fileName = assetPathUtils.getAndroidResourceIdentifier(asset);
			return drawbleFolder + '/' + fileName + '.' + asset.type;
		}var AssetSourceResolver = function () {

			function AssetSourceResolver(serverUrl, bundlePath, asset) {
				babelHelpers.classCallCheck(this, AssetSourceResolver);
				this.serverUrl = serverUrl;
				this.bundlePath = bundlePath;
				this.asset = asset;
			}babelHelpers.createClass(AssetSourceResolver, [{ key: 'isLoadedFromServer', value: function isLoadedFromServer() {
					return !!this.serverUrl;
				} }, { key: 'isLoadedFromFileSystem', value: function isLoadedFromFileSystem() {
					return !!this.bundlePath;
				} }, { key: 'defaultAsset', value: function defaultAsset() {
					if (this.isLoadedFromServer()) {
						return this.assetServerURL();
					}

					if (Platform.OS === 'android') {
						return this.isLoadedFromFileSystem() ? this.drawableFolderInBundle() : this.resourceIdentifierWithoutScale();
					} else {
						return this.scaledAssetPathInBundle();
					}
				} }, { key: 'assetServerURL', value: function assetServerURL() {
					invariant(!!this.serverUrl, 'need server to load from');
					return this.fromSource(this.serverUrl + getScaledAssetPath(this.asset) + '?platform=' + Platform.OS + '&hash=' + this.asset.hash);
				} }, { key: 'scaledAssetPath', value: function scaledAssetPath() {
					return this.fromSource(getScaledAssetPath(this.asset));
				} }, { key: 'scaledAssetPathInBundle', value: function scaledAssetPathInBundle() {
					var path = this.bundlePath || '';
					return this.fromSource(path + getScaledAssetPath(this.asset));
				} }, { key: 'resourceIdentifierWithoutScale', value: function resourceIdentifierWithoutScale() {
					invariant(Platform.OS === 'android', 'resource identifiers work on Android');
					return this.fromSource(assetPathUtils.getAndroidResourceIdentifier(this.asset));
				} }, { key: 'drawableFolderInBundle', value: function drawableFolderInBundle() {
					var path = this.bundlePath || '';
					return this.fromSource('file://' + path + getAssetPathInDrawableFolder(this.asset));
				} }, { key: 'fromSource', value: function fromSource(source) {
					return {
						__packager_asset: true,
						width: this.asset.width,
						height: this.asset.height,
						uri: source,
						scale: AssetSourceResolver.pickScale(this.asset.scales, PixelRatio.get()) };
				} }], [{ key: 'pickScale', value: function pickScale(scales, deviceScale) {

					for (var i = 0; i < scales.length; i++) {
						if (scales[i] >= deviceScale) {
							return scales[i];
						}
					}

					return scales[scales.length - 1] || 1;
				} }]);return AssetSourceResolver;
		}();

		module.exports = AssetSourceResolver;
	}, // local-cli/bundle/assetPathUtils.js
	function (__inner_require__, exports, module) {
		function getAndroidAssetSuffix(scale) {
			switch (scale) {
				case 0.75:
					return 'ldpi';
				case 1:
					return 'mdpi';
				case 1.5:
					return 'hdpi';
				case 2:
					return 'xhdpi';
				case 3:
					return 'xxhdpi';
				case 4:
					return 'xxxhdpi';}
		}

		function getAndroidDrawableFolderName(asset, scale) {
			var suffix = getAndroidAssetSuffix(scale);
			if (!suffix) {
				throw new Error('Don\'t know which android drawable suffix to use for asset: ' + JSON.stringify(asset));
			}
			var androidFolder = 'drawable-' + suffix;
			return androidFolder;
		}

		function getAndroidResourceIdentifier(asset) {
			var folderPath = getBasePath(asset);
			return (folderPath + '/' + asset.name).toLowerCase().replace(/\//g, '_').replace(/([^a-z0-9_])/g, '').replace(/^assets_/, '');
		}

		function getBasePath(asset) {
			var basePath = asset.httpServerLocation;
			if (basePath[0] === '/') {
				basePath = basePath.substr(1);
			}
			return basePath;
		}

		module.exports = {
			getAndroidAssetSuffix: getAndroidAssetSuffix,
			getAndroidDrawableFolderName: getAndroidDrawableFolderName,
			getAndroidResourceIdentifier: getAndroidResourceIdentifier,
			getBasePath: getBasePath };
	}, // Libraries/ReactIOS/verifyPropTypes.js
	function (__inner_require__, exports, module) {
		var ReactNativeStyleAttributes = __inner_require__(44 /*Libraries/Components/View/ReactNativeStyleAttributes.js*/);

		function verifyPropTypes(componentInterface, viewConfig, nativePropsToIgnore) {
			if (!viewConfig) {
				return;
			}
			var componentName = componentInterface.displayName || componentInterface.name || 'unknown';

			if (!componentInterface.propTypes) {
				throw new Error('`' + componentName + '` has no propTypes defined`');
			}

			var nativeProps = viewConfig.NativeProps;
			for (var prop in nativeProps) {
				if (!componentInterface.propTypes[prop] && !ReactNativeStyleAttributes[prop] && (!nativePropsToIgnore || !nativePropsToIgnore[prop])) {
					var message;
					if (componentInterface.propTypes.hasOwnProperty(prop)) {
						message = '`' + componentName + '` has incorrectly defined propType for native prop `' + viewConfig.uiViewClassName + '.' + prop + '` of native type `' + nativeProps[prop];
					} else {
						message = '`' + componentName + '` has no propType for native prop `' + viewConfig.uiViewClassName + '.' + prop + '` of native type `' + nativeProps[prop] + '`';
					}
					message += '\nIf you haven\'t changed this prop yourself, this usually means that ' + 'your versions of the native code and JavaScript code are out of sync. Updating both ' + 'should make this error go away.';
					throw new Error(message);
				}
			}
		}

		module.exports = verifyPropTypes;
	}, // Libraries/Components/ActivityIndicator/ActivityIndicatorIOS.ios.js
	function (__inner_require__, exports, module) {
		var ActivityIndicator = __inner_require__(1 /*Libraries/Components/ActivityIndicator/ActivityIndicator.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var ActivityIndicatorIOS = React.createClass({ displayName: 'ActivityIndicatorIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				animating: PropTypes.bool,

				color: PropTypes.string,

				hidesWhenStopped: PropTypes.bool,

				size: PropTypes.oneOf(['small', 'large']),

				onLayout: PropTypes.func }),

			componentDidMount: function componentDidMount() {
				console.warn('ActivityIndicatorIOS is deprecated. Use ActivityIndicator instead.');
			},

			render: function render() {
				return React.createElement(ActivityIndicator, this.props);
			} });

		module.exports = ActivityIndicatorIOS;
	}, // Libraries/ART/ReactNativeART.js
	function (__inner_require__, exports, module) {
		var Color = require('art@0.10/core/color.js');
		var Path = __inner_require__(78 /*Libraries/ART/ARTSerializablePath.js*/);
		var Transform = require('art@0.10/core/transform.js');

		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNativeViewAttributes = __inner_require__(49 /*Libraries/Components/View/ReactNativeViewAttributes.js*/);

		var createReactNativeComponentClass = __inner_require__(53 /*__react__/lib/createReactNativeComponentClass.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		function arrayDiffer(a, b) {
			if (a == null || b == null) {
				return true;
			}
			if (a.length !== b.length) {
				return true;
			}
			for (var i = 0; i < a.length; i++) {
				if (a[i] !== b[i]) {
					return true;
				}
			}
			return false;
		}

		function fontAndLinesDiffer(a, b) {
			if (a === b) {
				return false;
			}
			if (a.font !== b.font) {
				if (a.font === null) {
					return true;
				}
				if (b.font === null) {
					return true;
				}

				if (a.font.fontFamily !== b.font.fontFamily || a.font.fontSize !== b.font.fontSize || a.font.fontWeight !== b.font.fontWeight || a.font.fontStyle !== b.font.fontStyle) {
					return true;
				}
			}
			return arrayDiffer(a.lines, b.lines);
		}

		var SurfaceViewAttributes = merge(ReactNativeViewAttributes.UIView, {});

		var NodeAttributes = {
			transform: { diff: arrayDiffer },
			opacity: true };

		var GroupAttributes = merge(NodeAttributes, {
			clipping: { diff: arrayDiffer } });

		var RenderableAttributes = merge(NodeAttributes, {
			fill: { diff: arrayDiffer },
			stroke: { diff: arrayDiffer },
			strokeWidth: true,
			strokeCap: true,
			strokeJoin: true,
			strokeDash: { diff: arrayDiffer } });

		var ShapeAttributes = merge(RenderableAttributes, {
			d: { diff: arrayDiffer } });

		var TextAttributes = merge(RenderableAttributes, {
			alignment: true,
			frame: { diff: fontAndLinesDiffer },
			path: { diff: arrayDiffer } });

		var NativeSurfaceView = createReactNativeComponentClass({
			validAttributes: SurfaceViewAttributes,
			uiViewClassName: 'ARTSurfaceView' });

		var NativeGroup = createReactNativeComponentClass({
			validAttributes: GroupAttributes,
			uiViewClassName: 'ARTGroup' });

		var NativeShape = createReactNativeComponentClass({
			validAttributes: ShapeAttributes,
			uiViewClassName: 'ARTShape' });

		var NativeText = createReactNativeComponentClass({
			validAttributes: TextAttributes,
			uiViewClassName: 'ARTText' });

		function childrenAsString(children) {
			if (!children) {
				return '';
			}
			if (typeof children === 'string') {
				return children;
			}
			if (children.length) {
				return children.join('\n');
			}
			return '';
		}var Surface = function (_React$Component) {
			babelHelpers.inherits(Surface, _React$Component);function Surface() {
				babelHelpers.classCallCheck(this, Surface);return babelHelpers.possibleConstructorReturn(this, (Surface.__proto__ || Object.getPrototypeOf(Surface)).apply(this, arguments));
			}babelHelpers.createClass(Surface, [{ key: 'render', value: function render() {
					var props = this.props;
					var w = extractNumber(props.width, 0);
					var h = extractNumber(props.height, 0);
					return React.createElement(NativeSurfaceView, { style: [props.style, { width: w, height: h }] }, this.props.children);
				} }]);return Surface;
		}(React.Component);

		function extractNumber(value, defaultValue) {
			if (value == null) {
				return defaultValue;
			}
			return +value;
		}

		var pooledTransform = new Transform();

		function extractTransform(props) {
			var scaleX = props.scaleX != null ? props.scaleX : props.scale != null ? props.scale : 1;
			var scaleY = props.scaleY != null ? props.scaleY : props.scale != null ? props.scale : 1;

			pooledTransform.transformTo(1, 0, 0, 1, 0, 0).move(props.x || 0, props.y || 0).rotate(props.rotation || 0, props.originX, props.originY).scale(scaleX, scaleY, props.originX, props.originY);

			if (props.transform != null) {
				pooledTransform.transform(props.transform);
			}

			return [pooledTransform.xx, pooledTransform.yx, pooledTransform.xy, pooledTransform.yy, pooledTransform.x, pooledTransform.y];
		}

		function extractOpacity(props) {

			if (props.visible === false) {
				return 0;
			}
			if (props.opacity == null) {
				return 1;
			}
			return +props.opacity;
		}var Group = function (_React$Component2) {
			babelHelpers.inherits(Group, _React$Component2);function Group() {
				babelHelpers.classCallCheck(this, Group);return babelHelpers.possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).apply(this, arguments));
			}babelHelpers.createClass(Group, [{ key: 'render', value: function render() {
					var props = this.props;
					return React.createElement(NativeGroup, {
						opacity: extractOpacity(props),
						transform: extractTransform(props) }, this.props.children);
				} }]);return Group;
		}(React.Component);var ClippingRectangle = function (_React$Component3) {
			babelHelpers.inherits(ClippingRectangle, _React$Component3);function ClippingRectangle() {
				babelHelpers.classCallCheck(this, ClippingRectangle);return babelHelpers.possibleConstructorReturn(this, (ClippingRectangle.__proto__ || Object.getPrototypeOf(ClippingRectangle)).apply(this, arguments));
			}babelHelpers.createClass(ClippingRectangle, [{ key: 'render', value: function render() {
					var props = this.props;
					var x = extractNumber(props.x, 0);
					var y = extractNumber(props.y, 0);
					var w = extractNumber(props.width, 0);
					var h = extractNumber(props.height, 0);
					var clipping = [x, y, w, h];

					var propsExcludingXAndY = merge(props);
					delete propsExcludingXAndY.x;
					delete propsExcludingXAndY.y;
					return React.createElement(NativeGroup, {
						clipping: clipping,
						opacity: extractOpacity(props),
						transform: extractTransform(propsExcludingXAndY) }, this.props.children);
				} }]);return ClippingRectangle;
		}(React.Component);

		var SOLID_COLOR = 0;
		var LINEAR_GRADIENT = 1;
		var RADIAL_GRADIENT = 2;
		var PATTERN = 3;

		function insertColorIntoArray(color, targetArray, atIndex) {
			var c = new Color(color);
			targetArray[atIndex + 0] = c.red / 255;
			targetArray[atIndex + 1] = c.green / 255;
			targetArray[atIndex + 2] = c.blue / 255;
			targetArray[atIndex + 3] = c.alpha;
		}

		function insertColorsIntoArray(stops, targetArray, atIndex) {
			var i = 0;
			if ('length' in stops) {
				while (i < stops.length) {
					insertColorIntoArray(stops[i], targetArray, atIndex + i * 4);
					i++;
				}
			} else {
				for (var offset in stops) {
					insertColorIntoArray(stops[offset], targetArray, atIndex + i * 4);
					i++;
				}
			}
			return atIndex + i * 4;
		}

		function insertOffsetsIntoArray(stops, targetArray, atIndex, multi, reverse) {
			var offsetNumber;
			var i = 0;
			if ('length' in stops) {
				while (i < stops.length) {
					offsetNumber = i / (stops.length - 1) * multi;
					targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
					i++;
				}
			} else {
				for (var offsetString in stops) {
					offsetNumber = +offsetString * multi;
					targetArray[atIndex + i] = reverse ? 1 - offsetNumber : offsetNumber;
					i++;
				}
			}
			return atIndex + i;
		}

		function insertColorStopsIntoArray(stops, targetArray, atIndex) {
			var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
			insertOffsetsIntoArray(stops, targetArray, lastIndex, 1, false);
		}

		function insertDoubleColorStopsIntoArray(stops, targetArray, atIndex) {
			var lastIndex = insertColorsIntoArray(stops, targetArray, atIndex);
			lastIndex = insertColorsIntoArray(stops, targetArray, lastIndex);
			lastIndex = insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, false);
			insertOffsetsIntoArray(stops, targetArray, lastIndex, 0.5, true);
		}

		function applyBoundingBoxToBrushData(brushData, props) {
			var type = brushData[0];
			var width = +props.width;
			var height = +props.height;
			if (type === LINEAR_GRADIENT) {
				brushData[1] *= width;
				brushData[2] *= height;
				brushData[3] *= width;
				brushData[4] *= height;
			} else if (type === RADIAL_GRADIENT) {
				brushData[1] *= width;
				brushData[2] *= height;
				brushData[3] *= width;
				brushData[4] *= height;
				brushData[5] *= width;
				brushData[6] *= height;
			} else if (type === PATTERN) {}
		}

		function extractBrush(colorOrBrush, props) {
			if (colorOrBrush == null) {
				return null;
			}
			if (colorOrBrush._brush) {
				if (colorOrBrush._bb) {

					applyBoundingBoxToBrushData(colorOrBrush._brush, props);
					colorOrBrush._bb = false;
				}
				return colorOrBrush._brush;
			}
			var c = new Color(colorOrBrush);
			return [SOLID_COLOR, c.red / 255, c.green / 255, c.blue / 255, c.alpha];
		}

		function extractColor(color) {
			if (color == null) {
				return null;
			}
			var c = new Color(color);
			return [c.red / 255, c.green / 255, c.blue / 255, c.alpha];
		}

		function extractStrokeCap(strokeCap) {
			switch (strokeCap) {
				case 'butt':
					return 0;
				case 'square':
					return 2;
				default:
					return 1;}
		}

		function extractStrokeJoin(strokeJoin) {
			switch (strokeJoin) {
				case 'miter':
					return 0;
				case 'bevel':
					return 2;
				default:
					return 1;}
		}var Shape = function (_React$Component4) {
			babelHelpers.inherits(Shape, _React$Component4);function Shape() {
				babelHelpers.classCallCheck(this, Shape);return babelHelpers.possibleConstructorReturn(this, (Shape.__proto__ || Object.getPrototypeOf(Shape)).apply(this, arguments));
			}babelHelpers.createClass(Shape, [{ key: 'render', value: function render() {
					var props = this.props;
					var path = props.d || childrenAsString(props.children);
					var d = new Path(path).toJSON();
					return React.createElement(NativeShape, {
						fill: extractBrush(props.fill, props),
						opacity: extractOpacity(props),
						stroke: extractColor(props.stroke),
						strokeCap: extractStrokeCap(props.strokeCap),
						strokeDash: props.strokeDash || null,
						strokeJoin: extractStrokeJoin(props.strokeJoin),
						strokeWidth: extractNumber(props.strokeWidth, 1),
						transform: extractTransform(props),

						d: d });
				} }]);return Shape;
		}(React.Component);

		var cachedFontObjectsFromString = {};

		var fontFamilyPrefix = /^[\s"']*/;
		var fontFamilySuffix = /[\s"']*$/;

		function extractSingleFontFamily(fontFamilyString) {

			return fontFamilyString.split(',')[0].replace(fontFamilyPrefix, '').replace(fontFamilySuffix, '');
		}

		function parseFontString(font) {
			if (cachedFontObjectsFromString.hasOwnProperty(font)) {
				return cachedFontObjectsFromString[font];
			}
			var regexp = /^\s*((?:(?:normal|bold|italic)\s+)*)(?:(\d+(?:\.\d+)?)[ptexm\%]*(?:\s*\/.*?)?\s+)?\s*\"?([^\"]*)/i;
			var match = regexp.exec(font);
			if (!match) {
				return null;
			}
			var fontFamily = extractSingleFontFamily(match[3]);
			var fontSize = +match[2] || 12;
			var isBold = /bold/.exec(match[1]);
			var isItalic = /italic/.exec(match[1]);
			cachedFontObjectsFromString[font] = {
				fontFamily: fontFamily,
				fontSize: fontSize,
				fontWeight: isBold ? 'bold' : 'normal',
				fontStyle: isItalic ? 'italic' : 'normal' };

			return cachedFontObjectsFromString[font];
		}

		function extractFont(font) {
			if (font == null) {
				return null;
			}
			if (typeof font === 'string') {
				return parseFontString(font);
			}
			var fontFamily = extractSingleFontFamily(font.fontFamily);
			var fontSize = +font.fontSize || 12;
			return {

				fontFamily: fontFamily,
				fontSize: fontSize,
				fontWeight: font.fontWeight,
				fontStyle: font.fontStyle };
		}

		var newLine = /\n/g;
		function extractFontAndLines(font, text) {
			return { font: extractFont(font), lines: text.split(newLine) };
		}

		function extractAlignment(alignment) {
			switch (alignment) {
				case 'right':
					return 1;
				case 'center':
					return 2;
				default:
					return 0;}
		}var Text = function (_React$Component5) {
			babelHelpers.inherits(Text, _React$Component5);function Text() {
				babelHelpers.classCallCheck(this, Text);return babelHelpers.possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));
			}babelHelpers.createClass(Text, [{ key: 'render', value: function render() {
					var props = this.props;
					var textPath = props.path ? new Path(props.path).toJSON() : null;
					var textFrame = extractFontAndLines(props.font, childrenAsString(props.children));

					return React.createElement(NativeText, {
						fill: extractBrush(props.fill, props),
						opacity: extractOpacity(props),
						stroke: extractColor(props.stroke),
						strokeCap: extractStrokeCap(props.strokeCap),
						strokeDash: props.strokeDash || null,
						strokeJoin: extractStrokeJoin(props.strokeJoin),
						strokeWidth: extractNumber(props.strokeWidth, 1),
						transform: extractTransform(props),

						alignment: extractAlignment(props.alignment),
						frame: textFrame,
						path: textPath });
				} }]);return Text;
		}(React.Component);

		function LinearGradient(stops, x1, y1, x2, y2) {
			var type = LINEAR_GRADIENT;

			if (arguments.length < 5) {
				var angle = (x1 == null ? 270 : x1) * Math.PI / 180;

				var x = Math.cos(angle);
				var y = -Math.sin(angle);
				var l = (Math.abs(x) + Math.abs(y)) / 2;

				x *= l;y *= l;

				x1 = 0.5 - x;
				x2 = 0.5 + x;
				y1 = 0.5 - y;
				y2 = 0.5 + y;
				this._bb = true;
			} else {
				this._bb = false;
			}

			var brushData = [type, +x1, +y1, +x2, +y2];
			insertColorStopsIntoArray(stops, brushData, 5);
			this._brush = brushData;
		}

		function RadialGradient(stops, fx, fy, rx, ry, cx, cy) {
			if (ry == null) {
				ry = rx;
			}
			if (cx == null) {
				cx = fx;
			}
			if (cy == null) {
				cy = fy;
			}
			if (fx == null) {

				fx = fy = rx = ry = cx = cy = 0.5;
				this._bb = true;
			} else {
				this._bb = false;
			}

			var brushData = [RADIAL_GRADIENT, +fx, +fy, +rx * 2, +ry * 2, +cx, +cy];
			insertDoubleColorStopsIntoArray(stops, brushData, 7);
			this._brush = brushData;
		}

		function Pattern(url, width, height, left, top) {
			this._brush = [PATTERN, url, +left || 0, +top || 0, +width, +height];
		}

		var ReactART = {
			LinearGradient: LinearGradient,
			RadialGradient: RadialGradient,
			Pattern: Pattern,
			Transform: Transform,
			Path: Path,
			Surface: Surface,
			Group: Group,
			ClippingRectangle: ClippingRectangle,
			Shape: Shape,
			Text: Text };

		module.exports = ReactART;
	}, // Libraries/ART/ARTSerializablePath.js
	function (__inner_require__, exports, module) {
		var Class = require('art@0.10/core/class.js');
		var Path = require('art@0.10/core/path.js');

		var MOVE_TO = 0;
		var CLOSE = 1;
		var LINE_TO = 2;
		var CURVE_TO = 3;
		var ARC = 4;

		var SerializablePath = Class(Path, {

			initialize: function initialize(path) {
				this.reset();
				if (path instanceof SerializablePath) {
					this.path = path.path.slice(0);
				} else if (path) {
					if (path.applyToPath) {
						path.applyToPath(this);
					} else {
						this.push(path);
					}
				}
			},

			onReset: function onReset() {
				this.path = [];
			},

			onMove: function onMove(sx, sy, x, y) {
				this.path.push(MOVE_TO, x, y);
			},

			onLine: function onLine(sx, sy, x, y) {
				this.path.push(LINE_TO, x, y);
			},

			onBezierCurve: function onBezierCurve(sx, sy, p1x, p1y, p2x, p2y, x, y) {
				this.path.push(CURVE_TO, p1x, p1y, p2x, p2y, x, y);
			},

			_arcToBezier: Path.prototype.onArc,

			onArc: function onArc(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation) {
				if (rx !== ry || rotation) {
					return this._arcToBezier(sx, sy, ex, ey, cx, cy, rx, ry, sa, ea, ccw, rotation);
				}
				this.path.push(ARC, cx, cy, rx, sa, ea, ccw ? 0 : 1);
			},

			onClose: function onClose() {
				this.path.push(CLOSE);
			},

			toJSON: function toJSON() {
				return this.path;
			} });

		module.exports = SerializablePath;
	}, // Libraries/Components/DatePicker/DatePickerIOS.ios.js
	function (__inner_require__, exports, module) {
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var DatePickerIOS = React.createClass({ displayName: 'DatePickerIOS',

			_picker: undefined,

			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				date: PropTypes.instanceOf(Date).isRequired,

				onDateChange: PropTypes.func.isRequired,

				maximumDate: PropTypes.instanceOf(Date),

				minimumDate: PropTypes.instanceOf(Date),

				mode: PropTypes.oneOf(['date', 'time', 'datetime']),

				minuteInterval: PropTypes.oneOf([1, 2, 3, 4, 5, 6, 10, 12, 15, 20, 30]),

				timeZoneOffsetInMinutes: PropTypes.number }),

			getDefaultProps: function getDefaultProps() {
				return {
					mode: 'datetime' };
			},

			_onChange: function _onChange(event) {
				var nativeTimeStamp = event.nativeEvent.timestamp;
				this.props.onDateChange && this.props.onDateChange(new Date(nativeTimeStamp));

				this.props.onChange && this.props.onChange(event);

				var propsTimeStamp = this.props.date.getTime();
				if (this._picker && nativeTimeStamp !== propsTimeStamp) {
					this._picker.setNativeProps({
						date: propsTimeStamp });
				}
			},

			render: function render() {
				var _this = this;
				var props = this.props;
				return React.createElement(View, { style: props.style }, React.createElement(RCTDatePickerIOS, {
					ref: function ref(picker) {
						_this._picker = picker;
					},
					style: styles.datePickerIOS,
					date: props.date.getTime(),
					maximumDate: props.maximumDate ? props.maximumDate.getTime() : undefined,

					minimumDate: props.minimumDate ? props.minimumDate.getTime() : undefined,

					mode: props.mode,
					minuteInterval: props.minuteInterval,
					timeZoneOffsetInMinutes: props.timeZoneOffsetInMinutes,
					onChange: this._onChange }));
			} });

		var styles = StyleSheet.create({
			datePickerIOS: {
				height: 216 } });

		var RCTDatePickerIOS = requireNativeComponent('RCTDatePicker', {
			propTypes: babelHelpers.extends({}, DatePickerIOS.propTypes, {
				date: PropTypes.number,
				minimumDate: PropTypes.number,
				maximumDate: PropTypes.number,
				onDateChange: function onDateChange() {
					return null;
				},
				onChange: PropTypes.func }) });

		module.exports = DatePickerIOS;
	}, // Libraries/Components/DrawerAndroid/DrawerLayoutAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Image/Image.ios.js
	function (__inner_require__, exports, module) {
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var ImageResizeMode = __inner_require__(31 /*Libraries/Image/ImageResizeMode.js*/);
		var ImageSourcePropType = __inner_require__(82 /*Libraries/Image/ImageSourcePropType.js*/);
		var ImageStylePropTypes = __inner_require__(30 /*Libraries/Image/ImageStylePropTypes.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var NativeModules = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNativeViewAttributes = __inner_require__(49 /*Libraries/Components/View/ReactNativeViewAttributes.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);

		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);
		var resolveAssetSource = __inner_require__(71 /*Libraries/Image/resolveAssetSource.js*/);

		var ImageViewManager = NativeModules.ImageViewManager;

		var Image = React.createClass({ displayName: 'Image',
			propTypes: {

				style: StyleSheetPropType(ImageStylePropTypes),

				source: ImageSourcePropType,

				defaultSource: PropTypes.oneOfType([PropTypes.shape({
					uri: PropTypes.string,
					width: PropTypes.number,
					height: PropTypes.number,
					scale: PropTypes.number }), PropTypes.number]),

				accessible: PropTypes.bool,

				accessibilityLabel: PropTypes.string,

				blurRadius: PropTypes.number,

				capInsets: EdgeInsetsPropType,

				resizeMode: PropTypes.oneOf(['cover', 'contain', 'stretch', 'repeat', 'center']),

				testID: PropTypes.string,

				onLayout: PropTypes.func,

				onLoadStart: PropTypes.func,

				onProgress: PropTypes.func,

				onError: PropTypes.func,

				onLoad: PropTypes.func,

				onLoadEnd: PropTypes.func },

			statics: {
				resizeMode: ImageResizeMode,

				getSize: function getSize(uri, success, failure) {
					ImageViewManager.getSize(uri, success, failure || function () {
						console.warn('Failed to get size for image: ' + uri);
					});
				},

				prefetch: function prefetch(url) {
					return ImageViewManager.prefetchImage(url);
				} },

			mixins: [NativeMethodsMixin],

			viewConfig: {
				uiViewClassName: 'UIView',
				validAttributes: ReactNativeViewAttributes.UIView },

			render: function render() {
				var source = resolveAssetSource(this.props.source) || { uri: undefined, width: undefined, height: undefined };

				var sources = void 0;
				var style = void 0;
				if (Array.isArray(source)) {
					style = flattenStyle([styles.base, this.props.style]) || {};
					sources = source;
				} else {
					var _width = source.width,
					    _height = source.height,
					    uri = source.uri;
					style = flattenStyle([{ width: _width, height: _height }, styles.base, this.props.style]) || {};
					sources = [source];

					if (uri === '') {
						console.warn('source.uri should not be an empty string');
					}
				}

				var resizeMode = this.props.resizeMode || (style || {}).resizeMode || 'cover';
				var tintColor = (style || {}).tintColor;

				if (this.props.src) {
					console.warn('The <Image> component requires a `source` property rather than `src`.');
				}

				return React.createElement(RCTImageView, babelHelpers.extends({}, this.props, {
					style: style,
					resizeMode: resizeMode,
					tintColor: tintColor,
					source: sources }));
			} });

		var styles = StyleSheet.create({
			base: {
				overflow: 'hidden' } });

		var RCTImageView = requireNativeComponent('RCTImageView', Image);

		module.exports = Image;
	}, // Libraries/Image/ImageSourcePropType.js
	function (__inner_require__, exports, module) {
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);

		var ImageURISourcePropType = PropTypes.shape({

			uri: PropTypes.string,

			method: PropTypes.string,

			headers: PropTypes.objectOf(PropTypes.string),

			body: PropTypes.string,

			width: PropTypes.number,
			height: PropTypes.number,

			scale: PropTypes.number });

		var ImageSourcePropType = PropTypes.oneOfType([ImageURISourcePropType, PropTypes.number, PropTypes.arrayOf(ImageURISourcePropType)]);

		module.exports = ImageSourcePropType;
	}, // Libraries/Image/ImageEditor.js
	function (__inner_require__, exports, module) {
		var RCTImageEditingManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').ImageEditingManager;var ImageEditor = function () {
			function ImageEditor() {
				babelHelpers.classCallCheck(this, ImageEditor);
			}babelHelpers.createClass(ImageEditor, null, [{ key: 'cropImage', value: function cropImage(uri, cropData, success, failure) {
					RCTImageEditingManager.cropImage(uri, cropData, success, failure);
				} }]);return ImageEditor;
		}();

		module.exports = ImageEditor;
	}, // Libraries/Image/ImageStore.js
	function (__inner_require__, exports, module) {
		var RCTImageStoreManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').ImageStoreManager;var ImageStore = function () {
			function ImageStore() {
				babelHelpers.classCallCheck(this, ImageStore);
			}babelHelpers.createClass(ImageStore, null, [{ key: 'hasImageForTag', value: function hasImageForTag(uri, callback) {
					if (RCTImageStoreManager.hasImageForTag) {
						RCTImageStoreManager.hasImageForTag(uri, callback);
					} else {
						console.warn('hasImageForTag() not implemented');
					}
				} }, { key: 'removeImageForTag', value: function removeImageForTag(uri) {
					if (RCTImageStoreManager.removeImageForTag) {
						RCTImageStoreManager.removeImageForTag(uri);
					} else {
						console.warn('removeImageForTag() not implemented');
					}
				} }, { key: 'addImageFromBase64', value: function addImageFromBase64(base64ImageData, success, failure) {
					RCTImageStoreManager.addImageFromBase64(base64ImageData, success, failure);
				} }, { key: 'getBase64ForTag', value: function getBase64ForTag(uri, success, failure) {
					RCTImageStoreManager.getBase64ForTag(uri, success, failure);
				} }]);return ImageStore;
		}();

		module.exports = ImageStore;
	}, // Libraries/Components/Keyboard/KeyboardAvoidingView.js
	function (__inner_require__, exports, module) {
		var Keyboard = require('react-native@0.33/Libraries/Components/Keyboard/Keyboard.js');
		var LayoutAnimation = __inner_require__(86 /*Libraries/LayoutAnimation/LayoutAnimation.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var viewRef = 'VIEW';

		var KeyboardAvoidingView = React.createClass({ displayName: 'KeyboardAvoidingView',
			mixins: [TimerMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {
				behavior: PropTypes.oneOf(['height', 'position', 'padding']),

				contentContainerStyle: View.propTypes.style,

				keyboardVerticalOffset: PropTypes.number.isRequired }),

			getDefaultProps: function getDefaultProps() {
				return {
					keyboardVerticalOffset: 0 };
			},

			getInitialState: function getInitialState() {
				return {
					bottom: 0 };
			},

			subscriptions: [],
			frame: null,

			relativeKeyboardHeight: function relativeKeyboardHeight(keyboardFrame) {
				var frame = this.frame;
				if (!frame) {
					return 0;
				}

				var y1 = Math.max(frame.y, keyboardFrame.screenY - this.props.keyboardVerticalOffset);
				var y2 = Math.min(frame.y + frame.height, keyboardFrame.screenY + keyboardFrame.height - this.props.keyboardVerticalOffset);
				return Math.max(y2 - y1, 0);
			},

			onKeyboardChange: function onKeyboardChange(event) {
				if (!event) {
					this.setState({ bottom: 0 });
					return;
				}var duration = event.duration,
				    easing = event.easing,
				    endCoordinates = event.endCoordinates;
				var height = this.relativeKeyboardHeight(endCoordinates);

				if (duration && easing) {
					LayoutAnimation.configureNext({
						duration: duration,
						update: {
							duration: duration,
							type: LayoutAnimation.Types[easing] || 'keyboard' } });
				}
				this.setState({ bottom: height });
			},

			onLayout: function onLayout(event) {
				this.frame = event.nativeEvent.layout;
			},

			componentWillUpdate: function componentWillUpdate(nextProps, nextState, nextContext) {
				if (nextState.bottom === this.state.bottom && this.props.behavior === 'height' && nextProps.behavior === 'height') {

					nextState.bottom = 0;
				}
			},

			componentWillMount: function componentWillMount() {
				if (Platform.OS === 'ios') {
					this.subscriptions = [Keyboard.addListener('keyboardWillChangeFrame', this.onKeyboardChange)];
				} else {
					this.subscriptions = [Keyboard.addListener('keyboardDidHide', this.onKeyboardChange), Keyboard.addListener('keyboardDidShow', this.onKeyboardChange)];
				}
			},

			componentWillUnmount: function componentWillUnmount() {
				this.subscriptions.forEach(function (sub) {
					return sub.remove();
				});
			},

			render: function render() {
				var _props = this.props,
				    behavior = _props.behavior,
				    children = _props.children,
				    style = _props.style,
				    props = babelHelpers.objectWithoutProperties(_props, ['behavior', 'children', 'style']);

				switch (behavior) {
					case 'height':
						var heightStyle = void 0;
						if (this.frame) {

							heightStyle = { height: this.frame.height - this.state.bottom, flex: 0 };
						}
						return React.createElement(View, babelHelpers.extends({ ref: viewRef, style: [style, heightStyle], onLayout: this.onLayout }, props), children);

					case 'position':
						var positionStyle = { bottom: this.state.bottom };var contentContainerStyle = this.props.contentContainerStyle;

						return React.createElement(View, babelHelpers.extends({ ref: viewRef, style: style, onLayout: this.onLayout }, props), React.createElement(View, { style: [contentContainerStyle, positionStyle] }, children));

					case 'padding':
						var paddingStyle = { paddingBottom: this.state.bottom };
						return React.createElement(View, babelHelpers.extends({ ref: viewRef, style: [style, paddingStyle], onLayout: this.onLayout }, props), children);

					default:
						return React.createElement(View, babelHelpers.extends({ ref: viewRef, onLayout: this.onLayout, style: style }, props), children);}
			} });

		module.exports = KeyboardAvoidingView;
	}, // Libraries/LayoutAnimation/LayoutAnimation.js
	function (__inner_require__, exports, module) {
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');

		var createStrictShapeTypeChecker = __inner_require__(40 /*Libraries/Utilities/createStrictShapeTypeChecker.js*/);
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var TypesEnum = {
			spring: true,
			linear: true,
			easeInEaseOut: true,
			easeIn: true,
			easeOut: true,
			keyboard: true };

		var Types = keyMirror(TypesEnum);

		var PropertiesEnum = {
			opacity: true,
			scaleXY: true };

		var Properties = keyMirror(PropertiesEnum);

		var animChecker = createStrictShapeTypeChecker({
			duration: PropTypes.number,
			delay: PropTypes.number,
			springDamping: PropTypes.number,
			initialVelocity: PropTypes.number,
			type: PropTypes.oneOf(Object.keys(Types)).isRequired,
			property: PropTypes.oneOf(Object.keys(Properties)) });

		var configChecker = createStrictShapeTypeChecker({
			duration: PropTypes.number.isRequired,
			create: animChecker,
			update: animChecker,
			delete: animChecker });

		function configureNext(config, onAnimationDidEnd) {
			configChecker({ config: config }, 'config', 'LayoutAnimation.configureNext');
			UIManager.configureNextLayoutAnimation(config, onAnimationDidEnd || function () {}, function () {});
		}

		function create(duration, type, creationProp) {
			return {
				duration: duration,
				create: {
					type: type,
					property: creationProp },

				update: {
					type: type },

				delete: {
					type: type,
					property: creationProp } };
		}

		var Presets = {
			easeInEaseOut: create(300, Types.easeInEaseOut, Properties.opacity),

			linear: create(500, Types.linear, Properties.opacity),

			spring: {
				duration: 700,
				create: {
					type: Types.linear,
					property: Properties.opacity },

				update: {
					type: Types.spring,
					springDamping: 0.4 },

				delete: {
					type: Types.linear,
					property: Properties.opacity } } };

		var LayoutAnimation = {

			configureNext: configureNext,

			create: create,
			Types: Types,
			Properties: Properties,
			configChecker: configChecker,
			Presets: Presets,
			easeInEaseOut: configureNext.bind(null, Presets.easeInEaseOut),

			linear: configureNext.bind(null, Presets.linear),

			spring: configureNext.bind(null, Presets.spring) };

		module.exports = LayoutAnimation;
	}, // Libraries/CustomComponents/ListView/ListView.js
	function (__inner_require__, exports, module) {
		var ListViewDataSource = __inner_require__(88 /*Libraries/CustomComponents/ListView/ListViewDataSource.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var RCTScrollViewManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').ScrollViewManager;
		var ScrollView = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
		var ScrollResponder = __inner_require__(114 /*Libraries/Components/ScrollResponder.js*/);
		var StaticRenderer = __inner_require__(118 /*Libraries/Components/StaticRenderer.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');

		var cloneReferencedElement = require('react-clone-referenced-element@1/cloneReferencedElement.js');
		var isEmpty = __inner_require__(89 /*Libraries/vendor/core/isEmpty.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		var PropTypes = React.PropTypes;

		var DEFAULT_PAGE_SIZE = 1;
		var DEFAULT_INITIAL_ROWS = 10;
		var DEFAULT_SCROLL_RENDER_AHEAD = 1000;
		var DEFAULT_END_REACHED_THRESHOLD = 1000;
		var DEFAULT_SCROLL_CALLBACK_THROTTLE = 50;

		var ListView = React.createClass({ displayName: 'ListView',
			_childFrames: [],
			_sentEndForContentLength: null,
			_scrollComponent: null,
			_prevRenderedRowsCount: 0,
			_visibleRows: {},
			scrollProperties: {},

			mixins: [ScrollResponder.Mixin, TimerMixin],

			statics: {
				DataSource: ListViewDataSource },

			propTypes: babelHelpers.extends({}, ScrollView.propTypes, {

				dataSource: PropTypes.instanceOf(ListViewDataSource).isRequired,

				renderSeparator: PropTypes.func,

				renderRow: PropTypes.func.isRequired,

				initialListSize: PropTypes.number.isRequired,

				onEndReached: PropTypes.func,

				onEndReachedThreshold: PropTypes.number.isRequired,

				pageSize: PropTypes.number.isRequired,

				renderFooter: PropTypes.func,
				renderHeader: PropTypes.func,

				renderSectionHeader: PropTypes.func,

				renderScrollComponent: React.PropTypes.func.isRequired,

				scrollRenderAheadDistance: React.PropTypes.number.isRequired,

				onChangeVisibleRows: React.PropTypes.func,

				removeClippedSubviews: React.PropTypes.bool,

				stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number).isRequired,

				enableEmptySections: PropTypes.bool }),

			getMetrics: function getMetrics() {
				return {
					contentLength: this.scrollProperties.contentLength,
					totalRows: this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount(),
					renderedRows: this.state.curRenderedRowsCount,
					visibleRows: Object.keys(this._visibleRows).length };
			},

			getScrollResponder: function getScrollResponder() {
				if (this._scrollComponent && this._scrollComponent.getScrollResponder) {
					return this._scrollComponent.getScrollResponder();
				}
			},

			scrollTo: function scrollTo() {
				if (this._scrollComponent && this._scrollComponent.scrollTo) {
					var _scrollComponent;
					(_scrollComponent = this._scrollComponent).scrollTo.apply(_scrollComponent, arguments);
				}
			},

			setNativeProps: function setNativeProps(props) {
				if (this._scrollComponent) {
					this._scrollComponent.setNativeProps(props);
				}
			},

			getDefaultProps: function getDefaultProps() {
				return {
					initialListSize: DEFAULT_INITIAL_ROWS,
					pageSize: DEFAULT_PAGE_SIZE,
					renderScrollComponent: function renderScrollComponent(props) {
						return React.createElement(ScrollView, props);
					},
					scrollRenderAheadDistance: DEFAULT_SCROLL_RENDER_AHEAD,
					onEndReachedThreshold: DEFAULT_END_REACHED_THRESHOLD,
					stickyHeaderIndices: [] };
			},

			getInitialState: function getInitialState() {
				return {
					curRenderedRowsCount: this.props.initialListSize,
					highlightedRow: {} };
			},

			getInnerViewNode: function getInnerViewNode() {
				return this._scrollComponent.getInnerViewNode();
			},

			componentWillMount: function componentWillMount() {

				this.scrollProperties = {
					visibleLength: null,
					contentLength: null,
					offset: 0 };

				this._childFrames = [];
				this._visibleRows = {};
				this._prevRenderedRowsCount = 0;
				this._sentEndForContentLength = null;
			},

			componentDidMount: function componentDidMount() {
				var _this = this;

				this.requestAnimationFrame(function () {
					_this._measureAndUpdateScrollProps();
				});
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
				var _this2 = this;
				if (this.props.dataSource !== nextProps.dataSource || this.props.initialListSize !== nextProps.initialListSize) {
					this.setState(function (state, props) {
						_this2._prevRenderedRowsCount = 0;
						return {
							curRenderedRowsCount: Math.min(Math.max(state.curRenderedRowsCount, props.initialListSize), props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount()) };
					}, function () {
						return _this2._renderMoreRowsIfNeeded();
					});
				}
			},

			componentDidUpdate: function componentDidUpdate() {
				var _this3 = this;
				this.requestAnimationFrame(function () {
					_this3._measureAndUpdateScrollProps();
				});
			},

			_onRowHighlighted: function _onRowHighlighted(sectionID, rowID) {
				this.setState({ highlightedRow: { sectionID: sectionID, rowID: rowID } });
			},

			render: function render() {
				var bodyComponents = [];

				var dataSource = this.props.dataSource;
				var allRowIDs = dataSource.rowIdentities;
				var rowCount = 0;
				var sectionHeaderIndices = [];

				var header = this.props.renderHeader && this.props.renderHeader();
				var footer = this.props.renderFooter && this.props.renderFooter();
				var totalIndex = header ? 1 : 0;

				for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
					var sectionID = dataSource.sectionIdentities[sectionIdx];
					var rowIDs = allRowIDs[sectionIdx];
					if (rowIDs.length === 0) {
						if (this.props.enableEmptySections === undefined) {
							var warning = require('react-native@0.33/__fbjs__/lib/warning.js');
							warning(false, 'In next release empty section headers will be rendered.' + ' In this release you can use \'enableEmptySections\' flag to render empty section headers.');
							continue;
						} else {
							var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
							invariant(this.props.enableEmptySections, 'In next release \'enableEmptySections\' flag will be deprecated, empty section headers will always be rendered.' + ' If empty section headers are not desirable their indices should be excluded from sectionIDs object.' + ' In this release \'enableEmptySections\' may only have value \'true\' to allow empty section headers rendering.');
						}
					}

					if (this.props.renderSectionHeader) {
						var shouldUpdateHeader = rowCount >= this._prevRenderedRowsCount && dataSource.sectionHeaderShouldUpdate(sectionIdx);
						bodyComponents.push(React.createElement(StaticRenderer, {
							key: 's_' + sectionID,
							shouldUpdate: !!shouldUpdateHeader,
							render: this.props.renderSectionHeader.bind(null, dataSource.getSectionHeaderData(sectionIdx), sectionID) }));

						sectionHeaderIndices.push(totalIndex++);
					}

					for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
						var rowID = rowIDs[rowIdx];
						var comboID = sectionID + '_' + rowID;
						var shouldUpdateRow = rowCount >= this._prevRenderedRowsCount && dataSource.rowShouldUpdate(sectionIdx, rowIdx);
						var row = React.createElement(StaticRenderer, {
							key: 'r_' + comboID,
							shouldUpdate: !!shouldUpdateRow,
							render: this.props.renderRow.bind(null, dataSource.getRowData(sectionIdx, rowIdx), sectionID, rowID, this._onRowHighlighted) });

						bodyComponents.push(row);
						totalIndex++;

						if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
							var adjacentRowHighlighted = this.state.highlightedRow.sectionID === sectionID && (this.state.highlightedRow.rowID === rowID || this.state.highlightedRow.rowID === rowIDs[rowIdx + 1]);

							var separator = this.props.renderSeparator(sectionID, rowID, adjacentRowHighlighted);

							if (separator) {
								bodyComponents.push(separator);
								totalIndex++;
							}
						}
						if (++rowCount === this.state.curRenderedRowsCount) {
							break;
						}
					}
					if (rowCount >= this.state.curRenderedRowsCount) {
						break;
					}
				}var _props = this.props,
				    renderScrollComponent = _props.renderScrollComponent,
				    props = babelHelpers.objectWithoutProperties(_props, ['renderScrollComponent']);
				if (!props.scrollEventThrottle) {
					props.scrollEventThrottle = DEFAULT_SCROLL_CALLBACK_THROTTLE;
				}
				if (props.removeClippedSubviews === undefined) {
					props.removeClippedSubviews = true;
				}
				babelHelpers.extends(props, {
					onScroll: this._onScroll,
					stickyHeaderIndices: this.props.stickyHeaderIndices.concat(sectionHeaderIndices),

					onKeyboardWillShow: undefined,
					onKeyboardWillHide: undefined,
					onKeyboardDidShow: undefined,
					onKeyboardDidHide: undefined });

				return cloneReferencedElement(renderScrollComponent(props), {
					ref: this._setScrollComponentRef,
					onContentSizeChange: this._onContentSizeChange,
					onLayout: this._onLayout }, header, bodyComponents, footer);
			},

			_measureAndUpdateScrollProps: function _measureAndUpdateScrollProps() {
				var scrollComponent = this.getScrollResponder();
				if (!scrollComponent || !scrollComponent.getInnerViewNode) {
					return;
				}

				RCTScrollViewManager && RCTScrollViewManager.calculateChildFrames && RCTScrollViewManager.calculateChildFrames(ReactNative.findNodeHandle(scrollComponent), this._updateVisibleRows);
			},

			_setScrollComponentRef: function _setScrollComponentRef(scrollComponent) {
				this._scrollComponent = scrollComponent;
			},

			_onContentSizeChange: function _onContentSizeChange(width, height) {
				var contentLength = !this.props.horizontal ? height : width;
				if (contentLength !== this.scrollProperties.contentLength) {
					this.scrollProperties.contentLength = contentLength;
					this._updateVisibleRows();
					this._renderMoreRowsIfNeeded();
				}
				this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
			},

			_onLayout: function _onLayout(event) {
				var _event$nativeEvent$la = event.nativeEvent.layout,
				    width = _event$nativeEvent$la.width,
				    height = _event$nativeEvent$la.height;
				var visibleLength = !this.props.horizontal ? height : width;
				if (visibleLength !== this.scrollProperties.visibleLength) {
					this.scrollProperties.visibleLength = visibleLength;
					this._updateVisibleRows();
					this._renderMoreRowsIfNeeded();
				}
				this.props.onLayout && this.props.onLayout(event);
			},

			_maybeCallOnEndReached: function _maybeCallOnEndReached(event) {
				if (this.props.onEndReached && this.scrollProperties.contentLength !== this._sentEndForContentLength && this._getDistanceFromEnd(this.scrollProperties) < this.props.onEndReachedThreshold && this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
					this._sentEndForContentLength = this.scrollProperties.contentLength;
					this.props.onEndReached(event);
					return true;
				}
				return false;
			},

			_renderMoreRowsIfNeeded: function _renderMoreRowsIfNeeded() {
				if (this.scrollProperties.contentLength === null || this.scrollProperties.visibleLength === null || this.state.curRenderedRowsCount === (this.props.enableEmptySections ? this.props.dataSource.getRowAndSectionCount() : this.props.dataSource.getRowCount())) {
					this._maybeCallOnEndReached();
					return;
				}

				var distanceFromEnd = this._getDistanceFromEnd(this.scrollProperties);
				if (distanceFromEnd < this.props.scrollRenderAheadDistance) {
					this._pageInNewRows();
				}
			},

			_pageInNewRows: function _pageInNewRows() {
				var _this4 = this;
				this.setState(function (state, props) {
					var rowsToRender = Math.min(state.curRenderedRowsCount + props.pageSize, props.enableEmptySections ? props.dataSource.getRowAndSectionCount() : props.dataSource.getRowCount());

					_this4._prevRenderedRowsCount = state.curRenderedRowsCount;
					return {
						curRenderedRowsCount: rowsToRender };
				}, function () {
					_this4._measureAndUpdateScrollProps();
					_this4._prevRenderedRowsCount = _this4.state.curRenderedRowsCount;
				});
			},

			_getDistanceFromEnd: function _getDistanceFromEnd(scrollProperties) {
				return scrollProperties.contentLength - scrollProperties.visibleLength - scrollProperties.offset;
			},

			_updateVisibleRows: function _updateVisibleRows(updatedFrames) {
				var _this5 = this;
				if (!this.props.onChangeVisibleRows) {
					return;
				}
				if (updatedFrames) {
					updatedFrames.forEach(function (newFrame) {
						_this5._childFrames[newFrame.index] = merge(newFrame);
					});
				}
				var isVertical = !this.props.horizontal;
				var dataSource = this.props.dataSource;
				var visibleMin = this.scrollProperties.offset;
				var visibleMax = visibleMin + this.scrollProperties.visibleLength;
				var allRowIDs = dataSource.rowIdentities;

				var header = this.props.renderHeader && this.props.renderHeader();
				var totalIndex = header ? 1 : 0;
				var visibilityChanged = false;
				var changedRows = {};
				for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
					var rowIDs = allRowIDs[sectionIdx];
					if (rowIDs.length === 0) {
						continue;
					}
					var sectionID = dataSource.sectionIdentities[sectionIdx];
					if (this.props.renderSectionHeader) {
						totalIndex++;
					}
					var visibleSection = this._visibleRows[sectionID];
					if (!visibleSection) {
						visibleSection = {};
					}
					for (var rowIdx = 0; rowIdx < rowIDs.length; rowIdx++) {
						var rowID = rowIDs[rowIdx];
						var frame = this._childFrames[totalIndex];
						totalIndex++;
						if (this.props.renderSeparator && (rowIdx !== rowIDs.length - 1 || sectionIdx === allRowIDs.length - 1)) {
							totalIndex++;
						}
						if (!frame) {
							break;
						}
						var rowVisible = visibleSection[rowID];
						var min = isVertical ? frame.y : frame.x;
						var max = min + (isVertical ? frame.height : frame.width);
						if (!min && !max || min === max) {
							break;
						}
						if (min > visibleMax || max < visibleMin) {
							if (rowVisible) {
								visibilityChanged = true;
								delete visibleSection[rowID];
								if (!changedRows[sectionID]) {
									changedRows[sectionID] = {};
								}
								changedRows[sectionID][rowID] = false;
							}
						} else if (!rowVisible) {
							visibilityChanged = true;
							visibleSection[rowID] = true;
							if (!changedRows[sectionID]) {
								changedRows[sectionID] = {};
							}
							changedRows[sectionID][rowID] = true;
						}
					}
					if (!isEmpty(visibleSection)) {
						this._visibleRows[sectionID] = visibleSection;
					} else if (this._visibleRows[sectionID]) {
						delete this._visibleRows[sectionID];
					}
				}
				visibilityChanged && this.props.onChangeVisibleRows(this._visibleRows, changedRows);
			},

			_onScroll: function _onScroll(e) {
				var isVertical = !this.props.horizontal;
				this.scrollProperties.visibleLength = e.nativeEvent.layoutMeasurement[isVertical ? 'height' : 'width'];

				this.scrollProperties.contentLength = e.nativeEvent.contentSize[isVertical ? 'height' : 'width'];

				this.scrollProperties.offset = e.nativeEvent.contentOffset[isVertical ? 'y' : 'x'];

				this._updateVisibleRows(e.nativeEvent.updatedChildFrames);
				if (!this._maybeCallOnEndReached(e)) {
					this._renderMoreRowsIfNeeded();
				}

				if (this.props.onEndReached && this._getDistanceFromEnd(this.scrollProperties) > this.props.onEndReachedThreshold) {

					this._sentEndForContentLength = null;
				}

				this.props.onScroll && this.props.onScroll(e);
			} });

		module.exports = ListView;
	}, // Libraries/CustomComponents/ListView/ListViewDataSource.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var isEmpty = __inner_require__(89 /*Libraries/vendor/core/isEmpty.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function defaultGetRowData(dataBlob, sectionID, rowID) {
			return dataBlob[sectionID][rowID];
		}

		function defaultGetSectionHeaderData(dataBlob, sectionID) {
			return dataBlob[sectionID];
		}var ListViewDataSource = function () {

			function ListViewDataSource(params) {
				babelHelpers.classCallCheck(this, ListViewDataSource);
				invariant(params && typeof params.rowHasChanged === 'function', 'Must provide a rowHasChanged function.');

				this._rowHasChanged = params.rowHasChanged;
				this._getRowData = params.getRowData || defaultGetRowData;
				this._sectionHeaderHasChanged = params.sectionHeaderHasChanged;
				this._getSectionHeaderData = params.getSectionHeaderData || defaultGetSectionHeaderData;

				this._dataBlob = null;
				this._dirtyRows = [];
				this._dirtySections = [];
				this._cachedRowCount = 0;

				this.rowIdentities = [];
				this.sectionIdentities = [];
			}babelHelpers.createClass(ListViewDataSource, [{ key: 'cloneWithRows', value: function cloneWithRows(dataBlob, rowIdentities) {
					var rowIds = rowIdentities ? [rowIdentities] : null;
					if (!this._sectionHeaderHasChanged) {
						this._sectionHeaderHasChanged = function () {
							return false;
						};
					}
					return this.cloneWithRowsAndSections({ s1: dataBlob }, ['s1'], rowIds);
				} }, { key: 'cloneWithRowsAndSections', value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
					invariant(typeof this._sectionHeaderHasChanged === 'function', 'Must provide a sectionHeaderHasChanged function with section data.');

					invariant(!sectionIdentities || !rowIdentities || sectionIdentities.length === rowIdentities.length, 'row and section ids lengths must be the same');

					var newSource = new ListViewDataSource({
						getRowData: this._getRowData,
						getSectionHeaderData: this._getSectionHeaderData,
						rowHasChanged: this._rowHasChanged,
						sectionHeaderHasChanged: this._sectionHeaderHasChanged });

					newSource._dataBlob = dataBlob;
					if (sectionIdentities) {
						newSource.sectionIdentities = sectionIdentities;
					} else {
						newSource.sectionIdentities = Object.keys(dataBlob);
					}
					if (rowIdentities) {
						newSource.rowIdentities = rowIdentities;
					} else {
						newSource.rowIdentities = [];
						newSource.sectionIdentities.forEach(function (sectionID) {
							newSource.rowIdentities.push(Object.keys(dataBlob[sectionID]));
						});
					}
					newSource._cachedRowCount = countRows(newSource.rowIdentities);

					newSource._calculateDirtyArrays(this._dataBlob, this.sectionIdentities, this.rowIdentities);

					return newSource;
				} }, { key: 'getRowCount', value: function getRowCount() {
					return this._cachedRowCount;
				} }, { key: 'getRowAndSectionCount', value: function getRowAndSectionCount() {
					return this._cachedRowCount + this.sectionIdentities.length;
				} }, { key: 'rowShouldUpdate', value: function rowShouldUpdate(sectionIndex, rowIndex) {
					var needsUpdate = this._dirtyRows[sectionIndex][rowIndex];
					warning(needsUpdate !== undefined, 'missing dirtyBit for section, row: ' + sectionIndex + ', ' + rowIndex);
					return needsUpdate;
				} }, { key: 'getRowData', value: function getRowData(sectionIndex, rowIndex) {
					var sectionID = this.sectionIdentities[sectionIndex];
					var rowID = this.rowIdentities[sectionIndex][rowIndex];
					warning(sectionID !== undefined && rowID !== undefined, 'rendering invalid section, row: ' + sectionIndex + ', ' + rowIndex);

					return this._getRowData(this._dataBlob, sectionID, rowID);
				} }, { key: 'getRowIDForFlatIndex', value: function getRowIDForFlatIndex(index) {
					var accessIndex = index;
					for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
						if (accessIndex >= this.rowIdentities[ii].length) {
							accessIndex -= this.rowIdentities[ii].length;
						} else {
							return this.rowIdentities[ii][accessIndex];
						}
					}
					return null;
				} }, { key: 'getSectionIDForFlatIndex', value: function getSectionIDForFlatIndex(index) {
					var accessIndex = index;
					for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
						if (accessIndex >= this.rowIdentities[ii].length) {
							accessIndex -= this.rowIdentities[ii].length;
						} else {
							return this.sectionIdentities[ii];
						}
					}
					return null;
				} }, { key: 'getSectionLengths', value: function getSectionLengths() {
					var results = [];
					for (var ii = 0; ii < this.sectionIdentities.length; ii++) {
						results.push(this.rowIdentities[ii].length);
					}
					return results;
				} }, { key: 'sectionHeaderShouldUpdate', value: function sectionHeaderShouldUpdate(sectionIndex) {
					var needsUpdate = this._dirtySections[sectionIndex];
					warning(needsUpdate !== undefined, 'missing dirtyBit for section: ' + sectionIndex);
					return needsUpdate;
				} }, { key: 'getSectionHeaderData', value: function getSectionHeaderData(sectionIndex) {
					if (!this._getSectionHeaderData) {
						return null;
					}
					var sectionID = this.sectionIdentities[sectionIndex];
					warning(sectionID !== undefined, 'renderSection called on invalid section: ' + sectionIndex);
					return this._getSectionHeaderData(this._dataBlob, sectionID);
				} }, { key: '_calculateDirtyArrays', value: function _calculateDirtyArrays(prevDataBlob, prevSectionIDs, prevRowIDs) {

					var prevSectionsHash = keyedDictionaryFromArray(prevSectionIDs);
					var prevRowsHash = {};
					for (var ii = 0; ii < prevRowIDs.length; ii++) {
						var sectionID = prevSectionIDs[ii];
						warning(!prevRowsHash[sectionID], 'SectionID appears more than once: ' + sectionID);

						prevRowsHash[sectionID] = keyedDictionaryFromArray(prevRowIDs[ii]);
					}

					this._dirtySections = [];
					this._dirtyRows = [];

					var dirty;
					for (var sIndex = 0; sIndex < this.sectionIdentities.length; sIndex++) {
						var sectionID = this.sectionIdentities[sIndex];

						dirty = !prevSectionsHash[sectionID];
						var sectionHeaderHasChanged = this._sectionHeaderHasChanged;
						if (!dirty && sectionHeaderHasChanged) {
							dirty = sectionHeaderHasChanged(this._getSectionHeaderData(prevDataBlob, sectionID), this._getSectionHeaderData(this._dataBlob, sectionID));
						}
						this._dirtySections.push(!!dirty);

						this._dirtyRows[sIndex] = [];
						for (var rIndex = 0; rIndex < this.rowIdentities[sIndex].length; rIndex++) {
							var rowID = this.rowIdentities[sIndex][rIndex];

							dirty = !prevSectionsHash[sectionID] || !prevRowsHash[sectionID][rowID] || this._rowHasChanged(this._getRowData(prevDataBlob, sectionID, rowID), this._getRowData(this._dataBlob, sectionID, rowID));

							this._dirtyRows[sIndex].push(!!dirty);
						}
					}
				} }]);return ListViewDataSource;
		}();

		function countRows(allRowIDs) {
			var totalRows = 0;
			for (var sectionIdx = 0; sectionIdx < allRowIDs.length; sectionIdx++) {
				var rowIDs = allRowIDs[sectionIdx];
				totalRows += rowIDs.length;
			}
			return totalRows;
		}

		function keyedDictionaryFromArray(arr) {
			if (isEmpty(arr)) {
				return {};
			}
			var result = {};
			for (var ii = 0; ii < arr.length; ii++) {
				var key = arr[ii];
				warning(!result[key], 'Value appears more than once in array: ' + key);
				result[key] = true;
			}
			return result;
		}

		module.exports = ListViewDataSource;
	}, // Libraries/vendor/core/isEmpty.js
	function (__inner_require__, exports, module) {
		function isEmpty(obj) {
			if (Array.isArray(obj)) {
				return obj.length === 0;
			} else if (typeof obj === 'object') {
				for (var i in obj) {
					return false;
				}
				return true;
			} else {
				return !obj;
			}
		}

		module.exports = isEmpty;
	}, // __react__/lib/ReactNative.js
	function (__inner_require__, exports, module) {
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactNativeDefaultInjection = __inner_require__(91 /*__react__/lib/ReactNativeDefaultInjection.js*/);

		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactNativeMount = require('react-native@0.33/__react__/lib/ReactNativeMount.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var findNodeHandle = require('react-native@0.33/__react__/lib/findNodeHandle.js');

		ReactNativeDefaultInjection.inject();

		var render = function render(element, mountInto, callback) {
			return ReactNativeMount.renderComponent(element, mountInto, callback);
		};

		var ReactNative = {
			hasReactNativeInitialized: false,
			findNodeHandle: findNodeHandle,
			render: render,
			unmountComponentAtNode: ReactNativeMount.unmountComponentAtNode,

			unstable_batchedUpdates: ReactUpdates.batchedUpdates,

			unmountComponentAtNodeAndRemoveContainer: ReactNativeMount.unmountComponentAtNodeAndRemoveContainer };

		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
			__REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
				ComponentTree: {
					getClosestInstanceFromNode: function getClosestInstanceFromNode(node) {
						return ReactNativeComponentTree.getClosestInstanceFromNode(node);
					},
					getNodeFromInstance: function getNodeFromInstance(inst) {

						while (inst._renderedComponent) {
							inst = inst._renderedComponent;
						}
						if (inst) {
							return ReactNativeComponentTree.getNodeFromInstance(inst);
						} else {
							return null;
						}
					} },

				Mount: ReactNativeMount,
				Reconciler: require('react-native@0.33/__react__/lib/ReactReconciler.js') });
		}

		module.exports = ReactNative;
	}, // __react__/lib/ReactNativeDefaultInjection.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		__inner_require__(92 /*lib/InitializeJavaScriptAppEngine.js*/);

		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);
		var RCTEventEmitter = __inner_require__(93 /*lib/RCTEventEmitter.js*/);
		var ReactComponentEnvironment = require('react-native@0.33/__react__/lib/ReactComponentEnvironment.js');
		var ReactDefaultBatchingStrategy = __inner_require__(95 /*__react__/lib/ReactDefaultBatchingStrategy.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactEmptyComponent = require('react-native@0.33/__react__/lib/ReactEmptyComponent.js');
		var ReactNativeBridgeEventPlugin = __inner_require__(96 /*__react__/lib/ReactNativeBridgeEventPlugin.js*/);
		var ReactHostComponent = require('react-native@0.33/__react__/lib/ReactHostComponent.js');
		var ReactNativeComponentEnvironment = __inner_require__(99 /*__react__/lib/ReactNativeComponentEnvironment.js*/);
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactNativeEventEmitter = __inner_require__(55 /*__react__/lib/ReactNativeEventEmitter.js*/);
		var ReactNativeEventPluginOrder = __inner_require__(102 /*__react__/lib/ReactNativeEventPluginOrder.js*/);
		var ReactNativeGlobalResponderHandler = __inner_require__(103 /*__react__/lib/ReactNativeGlobalResponderHandler.js*/);
		var ReactNativeTextComponent = __inner_require__(104 /*__react__/lib/ReactNativeTextComponent.js*/);
		var ReactNativeTreeTraversal = __inner_require__(105 /*__react__/lib/ReactNativeTreeTraversal.js*/);
		var ReactSimpleEmptyComponent = __inner_require__(106 /*__react__/lib/ReactSimpleEmptyComponent.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');
		var ResponderEventPlugin = __inner_require__(107 /*__react__/lib/ResponderEventPlugin.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function inject() {

			RCTEventEmitter.register(ReactNativeEventEmitter);

			EventPluginHub.injection.injectEventPluginOrder(ReactNativeEventPluginOrder);
			EventPluginUtils.injection.injectComponentTree(ReactNativeComponentTree);
			EventPluginUtils.injection.injectTreeTraversal(ReactNativeTreeTraversal);

			ResponderEventPlugin.injection.injectGlobalResponderHandler(ReactNativeGlobalResponderHandler);

			EventPluginHub.injection.injectEventPluginsByName({
				'ResponderEventPlugin': ResponderEventPlugin,
				'ReactNativeBridgeEventPlugin': ReactNativeBridgeEventPlugin });

			ReactUpdates.injection.injectReconcileTransaction(ReactNativeComponentEnvironment.ReactReconcileTransaction);

			ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);

			ReactComponentEnvironment.injection.injectEnvironment(ReactNativeComponentEnvironment);

			var EmptyComponent = function EmptyComponent(instantiate) {

				var View = __inner_require__(111 /*lib/View.js*/);
				return new ReactSimpleEmptyComponent(ReactElement.createElement(View, {
					collapsable: true,
					style: { position: 'absolute' } }), instantiate);
			};

			ReactEmptyComponent.injection.injectEmptyComponentFactory(EmptyComponent);

			ReactHostComponent.injection.injectTextComponentClass(ReactNativeTextComponent);
			ReactHostComponent.injection.injectGenericComponentClass(function (tag) {

				var info = '';
				if (typeof tag === 'string' && /^[a-z]/.test(tag)) {
					info += ' Each component name should start with an uppercase letter.';
				}
				!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected a component class, got %s.%s', tag, info) : _prodInvariant('18', tag, info) : void 0;
			});
		}

		module.exports = {
			inject: inject };
	}, // lib/InitializeJavaScriptAppEngine.js
	function (__inner_require__, exports, module) {
		module.exports = require('react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/InitializeJavaScriptAppEngine.js');
	}, // lib/RCTEventEmitter.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(94 /*Libraries/BatchedBridge/BatchedBridgedModules/RCTEventEmitter.js*/);
	}, // Libraries/BatchedBridge/BatchedBridgedModules/RCTEventEmitter.js
	function (__inner_require__, exports, module) {
		var BatchedBridge = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridge.js');

		var RCTEventEmitter = {
			register: function register(eventEmitter) {
				BatchedBridge.registerCallableModule('RCTEventEmitter', eventEmitter);
			} };

		module.exports = RCTEventEmitter;
	}, // __react__/lib/ReactDefaultBatchingStrategy.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');
		var Transaction = require('react-native@0.33/__react__/lib/Transaction.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');

		var RESET_BATCHED_UPDATES = {
			initialize: emptyFunction,
			close: function close() {
				ReactDefaultBatchingStrategy.isBatchingUpdates = false;
			} };

		var FLUSH_BATCHED_UPDATES = {
			initialize: emptyFunction,
			close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates) };

		var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

		function ReactDefaultBatchingStrategyTransaction() {
			this.reinitializeTransaction();
		}

		_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
			getTransactionWrappers: function getTransactionWrappers() {
				return TRANSACTION_WRAPPERS;
			} });

		var transaction = new ReactDefaultBatchingStrategyTransaction();

		var ReactDefaultBatchingStrategy = {
			isBatchingUpdates: false,

			batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
				var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

				ReactDefaultBatchingStrategy.isBatchingUpdates = true;

				if (alreadyBatchingUpdates) {
					callback(a, b, c, d, e);
				} else {
					transaction.perform(callback, null, a, b, c, d, e);
				}
			} };

		module.exports = ReactDefaultBatchingStrategy;
	}, // __react__/lib/ReactNativeBridgeEventPlugin.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var _extends = _assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}return target;
		};

		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var customBubblingEventTypes = UIManager.customBubblingEventTypes;
		var customDirectEventTypes = UIManager.customDirectEventTypes;

		var allTypesByEventName = {};

		for (var bubblingTypeName in customBubblingEventTypes) {
			allTypesByEventName[bubblingTypeName] = customBubblingEventTypes[bubblingTypeName];
		}

		for (var directTypeName in customDirectEventTypes) {
			process.env.NODE_ENV !== 'production' ? warning(!customBubblingEventTypes[directTypeName], 'Event cannot be both direct and bubbling: %s', directTypeName) : void 0;
			allTypesByEventName[directTypeName] = customDirectEventTypes[directTypeName];
		}

		var ReactNativeBridgeEventPlugin = {

			eventTypes: _extends({}, customBubblingEventTypes, customDirectEventTypes),

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				var bubbleDispatchConfig = customBubblingEventTypes[topLevelType];
				var directDispatchConfig = customDirectEventTypes[topLevelType];
				var event = SyntheticEvent.getPooled(bubbleDispatchConfig || directDispatchConfig, targetInst, nativeEvent, nativeEventTarget);
				if (bubbleDispatchConfig) {
					EventPropagators.accumulateTwoPhaseDispatches(event);
				} else if (directDispatchConfig) {
					EventPropagators.accumulateDirectDispatches(event);
				} else {
					return null;
				}
				return event;
			} };

		module.exports = ReactNativeBridgeEventPlugin;
	}, // __react__/lib/EventPropagators.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);

		var accumulateInto = __inner_require__(60 /*__react__/lib/accumulateInto.js*/);
		var forEachAccumulated = __inner_require__(61 /*__react__/lib/forEachAccumulated.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var PropagationPhases = EventConstants.PropagationPhases;
		var getListener = EventPluginHub.getListener;

		function listenerAtPhase(inst, event, propagationPhase) {
			var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
			return getListener(inst, registrationName);
		}

		function accumulateDirectionalDispatches(inst, upwards, event) {
			if (process.env.NODE_ENV !== 'production') {
				process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
			}
			var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
			var listener = listenerAtPhase(inst, event, phase);
			if (listener) {
				event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
				event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
			}
		}

		function accumulateTwoPhaseDispatchesSingle(event) {
			if (event && event.dispatchConfig.phasedRegistrationNames) {
				EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
			}
		}

		function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
			if (event && event.dispatchConfig.phasedRegistrationNames) {
				var targetInst = event._targetInst;
				var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
				EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
			}
		}

		function accumulateDispatches(inst, ignoredDirection, event) {
			if (event && event.dispatchConfig.registrationName) {
				var registrationName = event.dispatchConfig.registrationName;
				var listener = getListener(inst, registrationName);
				if (listener) {
					event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
					event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
				}
			}
		}

		function accumulateDirectDispatchesSingle(event) {
			if (event && event.dispatchConfig.registrationName) {
				accumulateDispatches(event._targetInst, null, event);
			}
		}

		function accumulateTwoPhaseDispatches(events) {
			forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
		}

		function accumulateTwoPhaseDispatchesSkipTarget(events) {
			forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
		}

		function accumulateEnterLeaveDispatches(leave, enter, from, to) {
			EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
		}

		function accumulateDirectDispatches(events) {
			forEachAccumulated(events, accumulateDirectDispatchesSingle);
		}

		var EventPropagators = {
			accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
			accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
			accumulateDirectDispatches: accumulateDirectDispatches,
			accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches };

		module.exports = EventPropagators;
	}, // __react__/lib/SyntheticEvent.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var didWarnForAddedNewProperty = false;
		var isProxySupported = typeof Proxy === 'function';

		var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

		var EventInterface = {
			type: null,
			target: null,

			currentTarget: emptyFunction.thatReturnsNull,
			eventPhase: null,
			bubbles: null,
			cancelable: null,
			timeStamp: function timeStamp(event) {
				return event.timeStamp || Date.now();
			},
			defaultPrevented: null,
			isTrusted: null };

		function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
			if (process.env.NODE_ENV !== 'production') {

				delete this.nativeEvent;
				delete this.preventDefault;
				delete this.stopPropagation;
			}

			this.dispatchConfig = dispatchConfig;
			this._targetInst = targetInst;
			this.nativeEvent = nativeEvent;

			var Interface = this.constructor.Interface;
			for (var propName in Interface) {
				if (!Interface.hasOwnProperty(propName)) {
					continue;
				}
				if (process.env.NODE_ENV !== 'production') {
					delete this[propName];
				}
				var normalize = Interface[propName];
				if (normalize) {
					this[propName] = normalize(nativeEvent);
				} else {
					if (propName === 'target') {
						this.target = nativeEventTarget;
					} else {
						this[propName] = nativeEvent[propName];
					}
				}
			}

			var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
			if (defaultPrevented) {
				this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
			} else {
				this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
			}
			this.isPropagationStopped = emptyFunction.thatReturnsFalse;
			return this;
		}

		_assign(SyntheticEvent.prototype, {

			preventDefault: function preventDefault() {
				this.defaultPrevented = true;
				var event = this.nativeEvent;
				if (!event) {
					return;
				}

				if (event.preventDefault) {
					event.preventDefault();
				} else if (typeof event.returnValue !== 'unknown') {

					event.returnValue = false;
				}
				this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
			},

			stopPropagation: function stopPropagation() {
				var event = this.nativeEvent;
				if (!event) {
					return;
				}

				if (event.stopPropagation) {
					event.stopPropagation();
				} else if (typeof event.cancelBubble !== 'unknown') {

					event.cancelBubble = true;
				}

				this.isPropagationStopped = emptyFunction.thatReturnsTrue;
			},

			persist: function persist() {
				this.isPersistent = emptyFunction.thatReturnsTrue;
			},

			isPersistent: emptyFunction.thatReturnsFalse,

			destructor: function destructor() {
				var Interface = this.constructor.Interface;
				for (var propName in Interface) {
					if (process.env.NODE_ENV !== 'production') {
						Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
					} else {
						this[propName] = null;
					}
				}
				for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
					this[shouldBeReleasedProperties[i]] = null;
				}
				if (process.env.NODE_ENV !== 'production') {
					Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
					Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
					Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
				}
			} });

		SyntheticEvent.Interface = EventInterface;

		if (process.env.NODE_ENV !== 'production') {
			if (isProxySupported) {

				SyntheticEvent = new Proxy(SyntheticEvent, {
					construct: function construct(target, args) {
						return this.apply(target, Object.create(target.prototype), args);
					},
					apply: function apply(constructor, that, args) {
						return new Proxy(constructor.apply(that, args), {
							set: function set(target, prop, value) {
								if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
									process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
									didWarnForAddedNewProperty = true;
								}
								target[prop] = value;
								return true;
							} });
					} });
			}
		}

		SyntheticEvent.augmentClass = function (Class, Interface) {
			var Super = this;

			var E = function E() {};
			E.prototype = Super.prototype;
			var prototype = new E();

			_assign(prototype, Class.prototype);
			Class.prototype = prototype;
			Class.prototype.constructor = Class;

			Class.Interface = _assign({}, Super.Interface, Interface);
			Class.augmentClass = Super.augmentClass;

			PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
		};

		PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

		module.exports = SyntheticEvent;

		function getPooledWarningPropertyDefinition(propName, getVal) {
			var isFunction = typeof getVal === 'function';
			return {
				configurable: true,
				set: set,
				get: get };

			function set(val) {
				var action = isFunction ? 'setting the method' : 'setting the property';
				warn(action, 'This is effectively a no-op');
				return val;
			}

			function get() {
				var action = isFunction ? 'accessing the method' : 'accessing the property';
				var result = isFunction ? 'This is a no-op function' : 'This is set to null';
				warn(action, result);
				return getVal;
			}

			function warn(action, result) {
				var warningCondition = false;
				process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
			}
		}
	}, // __react__/lib/ReactNativeComponentEnvironment.js
	function (__inner_require__, exports, module) {
		var ReactNativeDOMIDOperations = __inner_require__(100 /*__react__/lib/ReactNativeDOMIDOperations.js*/);
		var ReactNativeReconcileTransaction = __inner_require__(101 /*__react__/lib/ReactNativeReconcileTransaction.js*/);

		var ReactNativeComponentEnvironment = {

			processChildrenUpdates: ReactNativeDOMIDOperations.dangerouslyProcessChildrenUpdates,

			replaceNodeWithMarkup: ReactNativeDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,

			clearNode: function clearNode() {},

			ReactReconcileTransaction: ReactNativeReconcileTransaction };

		module.exports = ReactNativeComponentEnvironment;
	}, // __react__/lib/ReactNativeDOMIDOperations.js
	function (__inner_require__, exports, module) {
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactMultiChildUpdateTypes = __inner_require__(64 /*__react__/lib/ReactMultiChildUpdateTypes.js*/);
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var dangerouslyProcessChildrenUpdates = function dangerouslyProcessChildrenUpdates(inst, childrenUpdates) {
			if (!childrenUpdates.length) {
				return;
			}

			var containerTag = ReactNativeComponentTree.getNodeFromInstance(inst);

			var moveFromIndices;
			var moveToIndices;
			var addChildTags;
			var addAtIndices;
			var removeAtIndices;

			for (var i = 0; i < childrenUpdates.length; i++) {
				var update = childrenUpdates[i];
				if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING) {
					(moveFromIndices || (moveFromIndices = [])).push(update.fromIndex);
					(moveToIndices || (moveToIndices = [])).push(update.toIndex);
				} else if (update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
					(removeAtIndices || (removeAtIndices = [])).push(update.fromIndex);
				} else if (update.type === ReactMultiChildUpdateTypes.INSERT_MARKUP) {
					var mountImage = update.content;
					var tag = mountImage;
					(addAtIndices || (addAtIndices = [])).push(update.toIndex);
					(addChildTags || (addChildTags = [])).push(tag);
				}
			}

			UIManager.manageChildren(containerTag, moveFromIndices, moveToIndices, addChildTags, addAtIndices, removeAtIndices);
		};

		var ReactNativeDOMIDOperations = {
			dangerouslyProcessChildrenUpdates: dangerouslyProcessChildrenUpdates,

			dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, mountImage) {
				var oldTag = id;
				UIManager.replaceExistingNonRootView(oldTag, mountImage);
			} };

		module.exports = ReactNativeDOMIDOperations;
	}, // __react__/lib/ReactNativeReconcileTransaction.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var CallbackQueue = require('react-native@0.33/__react__/lib/CallbackQueue.js');
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');
		var Transaction = require('react-native@0.33/__react__/lib/Transaction.js');
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var ReactUpdateQueue = require('react-native@0.33/__react__/lib/ReactUpdateQueue.js');

		var ON_DOM_READY_QUEUEING = {

			initialize: function initialize() {
				this.reactMountReady.reset();
			},

			close: function close() {
				this.reactMountReady.notifyAll();
			} };

		var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];

		if (process.env.NODE_ENV !== 'production') {
			TRANSACTION_WRAPPERS.push({
				initialize: ReactInstrumentation.debugTool.onBeginFlush,
				close: ReactInstrumentation.debugTool.onEndFlush });
		}

		function ReactNativeReconcileTransaction() {
			this.reinitializeTransaction();
			this.reactMountReady = CallbackQueue.getPooled(null);
		}

		var Mixin = {

			getTransactionWrappers: function getTransactionWrappers() {
				return TRANSACTION_WRAPPERS;
			},

			getReactMountReady: function getReactMountReady() {
				return this.reactMountReady;
			},

			getUpdateQueue: function getUpdateQueue() {
				return ReactUpdateQueue;
			},

			checkpoint: function checkpoint() {

				return this.reactMountReady.checkpoint();
			},

			rollback: function rollback(checkpoint) {
				this.reactMountReady.rollback(checkpoint);
			},

			destructor: function destructor() {
				CallbackQueue.release(this.reactMountReady);
				this.reactMountReady = null;
			} };

		_assign(ReactNativeReconcileTransaction.prototype, Transaction.Mixin, ReactNativeReconcileTransaction, Mixin);

		PooledClass.addPoolingTo(ReactNativeReconcileTransaction);

		module.exports = ReactNativeReconcileTransaction;
	}, // __react__/lib/ReactNativeEventPluginOrder.js
	function (__inner_require__, exports, module) {
		var ReactNativeEventPluginOrder = ['ResponderEventPlugin', 'ReactNativeBridgeEventPlugin'];

		module.exports = ReactNativeEventPluginOrder;
	}, // __react__/lib/ReactNativeGlobalResponderHandler.js
	function (__inner_require__, exports, module) {
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var ReactNativeGlobalResponderHandler = {
			onChange: function onChange(from, to, blockNativeResponder) {
				if (to !== null) {
					UIManager.setJSResponder(to._rootNodeID, blockNativeResponder);
				} else {
					UIManager.clearJSResponder();
				}
			} };

		module.exports = ReactNativeGlobalResponderHandler;
	}, // __react__/lib/ReactNativeTextComponent.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');
		var ReactNativeTagHandles = require('react-native@0.33/__react__/lib/ReactNativeTagHandles.js');
		var UIManager = require('react-native@0.33/lib/UIManager.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var ReactNativeTextComponent = function ReactNativeTextComponent(text) {

			this._currentElement = text;
			this._stringText = '' + text;
			this._hostParent = null;
			this._rootNodeID = 0;
		};

		_assign(ReactNativeTextComponent.prototype, {

			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {

				!context.isInAParentText ? process.env.NODE_ENV !== 'production' ? invariant(false, 'RawText "%s" must be wrapped in an explicit <Text> component.', this._stringText) : _prodInvariant('20', this._stringText) : void 0;
				this._hostParent = hostParent;
				var tag = ReactNativeTagHandles.allocateTag();
				this._rootNodeID = tag;
				var nativeTopRootTag = hostContainerInfo._tag;
				UIManager.createView(tag, 'RCTRawText', nativeTopRootTag, { text: this._stringText });

				ReactNativeComponentTree.precacheNode(this, tag);

				return tag;
			},

			getHostNode: function getHostNode() {
				return this._rootNodeID;
			},

			receiveComponent: function receiveComponent(nextText, transaction, context) {
				if (nextText !== this._currentElement) {
					this._currentElement = nextText;
					var nextStringText = '' + nextText;
					if (nextStringText !== this._stringText) {
						this._stringText = nextStringText;
						UIManager.updateView(this._rootNodeID, 'RCTRawText', { text: this._stringText });
					}
				}
			},

			unmountComponent: function unmountComponent() {
				ReactNativeComponentTree.uncacheNode(this);
				this._currentElement = null;
				this._stringText = null;
				this._rootNodeID = 0;
			} });

		module.exports = ReactNativeTextComponent;
	}, // __react__/lib/ReactNativeTreeTraversal.js
	function (__inner_require__, exports, module) {
		function getLowestCommonAncestor(instA, instB) {
			var depthA = 0;
			for (var tempA = instA; tempA; tempA = tempA._hostParent) {
				depthA++;
			}
			var depthB = 0;
			for (var tempB = instB; tempB; tempB = tempB._hostParent) {
				depthB++;
			}

			while (depthA - depthB > 0) {
				instA = instA._hostParent;
				depthA--;
			}

			while (depthB - depthA > 0) {
				instB = instB._hostParent;
				depthB--;
			}

			var depth = depthA;
			while (depth--) {
				if (instA === instB) {
					return instA;
				}
				instA = instA._hostParent;
				instB = instB._hostParent;
			}
			return null;
		}

		function isAncestor(instA, instB) {
			while (instB) {
				if (instB === instA) {
					return true;
				}
				instB = instB._hostParent;
			}
			return false;
		}

		function getParentInstance(inst) {
			return inst._hostParent;
		}

		function traverseTwoPhase(inst, fn, arg) {
			var path = [];
			while (inst) {
				path.push(inst);
				inst = inst._hostParent;
			}
			var i;
			for (i = path.length; i-- > 0;) {
				fn(path[i], false, arg);
			}
			for (i = 0; i < path.length; i++) {
				fn(path[i], true, arg);
			}
		}

		function traverseEnterLeave(from, to, fn, argFrom, argTo) {
			var common = from && to ? getLowestCommonAncestor(from, to) : null;
			var pathFrom = [];
			while (from && from !== common) {
				pathFrom.push(from);
				from = from._hostParent;
			}
			var pathTo = [];
			while (to && to !== common) {
				pathTo.push(to);
				to = to._hostParent;
			}
			var i;
			for (i = 0; i < pathFrom.length; i++) {
				fn(pathFrom[i], true, argFrom);
			}
			for (i = pathTo.length; i-- > 0;) {
				fn(pathTo[i], false, argTo);
			}
		}

		module.exports = {
			isAncestor: isAncestor,
			getLowestCommonAncestor: getLowestCommonAncestor,
			getParentInstance: getParentInstance,
			traverseTwoPhase: traverseTwoPhase,
			traverseEnterLeave: traverseEnterLeave };
	}, // __react__/lib/ReactSimpleEmptyComponent.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');

		var ReactSimpleEmptyComponent = function ReactSimpleEmptyComponent(placeholderElement, instantiate) {
			this._currentElement = null;
			this._renderedComponent = instantiate(placeholderElement);
		};
		_assign(ReactSimpleEmptyComponent.prototype, {
			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID) {
				return ReactReconciler.mountComponent(this._renderedComponent, transaction, hostParent, hostContainerInfo, context, parentDebugID);
			},
			receiveComponent: function receiveComponent() {},
			getHostNode: function getHostNode() {
				return ReactReconciler.getHostNode(this._renderedComponent);
			},
			unmountComponent: function unmountComponent() {
				ReactReconciler.unmountComponent(this._renderedComponent);
				this._renderedComponent = null;
			} });

		module.exports = ReactSimpleEmptyComponent;
	}, // __react__/lib/ResponderEventPlugin.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ResponderSyntheticEvent = __inner_require__(108 /*__react__/lib/ResponderSyntheticEvent.js*/);
		var ResponderTouchHistoryStore = __inner_require__(109 /*__react__/lib/ResponderTouchHistoryStore.js*/);

		var accumulate = __inner_require__(110 /*__react__/lib/accumulate.js*/);
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var isStartish = EventPluginUtils.isStartish;
		var isMoveish = EventPluginUtils.isMoveish;
		var isEndish = EventPluginUtils.isEndish;
		var executeDirectDispatch = EventPluginUtils.executeDirectDispatch;
		var hasDispatches = EventPluginUtils.hasDispatches;
		var executeDispatchesInOrderStopAtTrue = EventPluginUtils.executeDispatchesInOrderStopAtTrue;

		var responderInst = null;

		var trackedTouchCount = 0;

		var previousActiveTouches = 0;

		var changeResponder = function changeResponder(nextResponderInst, blockHostResponder) {
			var oldResponderInst = responderInst;
			responderInst = nextResponderInst;
			if (ResponderEventPlugin.GlobalResponderHandler !== null) {
				ResponderEventPlugin.GlobalResponderHandler.onChange(oldResponderInst, nextResponderInst, blockHostResponder);
			}
		};

		var eventTypes = {

			startShouldSetResponder: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onStartShouldSetResponder: null }),
					captured: keyOf({ onStartShouldSetResponderCapture: null }) } },

			scrollShouldSetResponder: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onScrollShouldSetResponder: null }),
					captured: keyOf({ onScrollShouldSetResponderCapture: null }) } },

			selectionChangeShouldSetResponder: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSelectionChangeShouldSetResponder: null }),
					captured: keyOf({ onSelectionChangeShouldSetResponderCapture: null }) } },

			moveShouldSetResponder: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMoveShouldSetResponder: null }),
					captured: keyOf({ onMoveShouldSetResponderCapture: null }) } },

			responderStart: { registrationName: keyOf({ onResponderStart: null }) },
			responderMove: { registrationName: keyOf({ onResponderMove: null }) },
			responderEnd: { registrationName: keyOf({ onResponderEnd: null }) },
			responderRelease: { registrationName: keyOf({ onResponderRelease: null }) },
			responderTerminationRequest: {
				registrationName: keyOf({ onResponderTerminationRequest: null }) },

			responderGrant: { registrationName: keyOf({ onResponderGrant: null }) },
			responderReject: { registrationName: keyOf({ onResponderReject: null }) },
			responderTerminate: { registrationName: keyOf({ onResponderTerminate: null }) } };

		function setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
			var shouldSetEventType = isStartish(topLevelType) ? eventTypes.startShouldSetResponder : isMoveish(topLevelType) ? eventTypes.moveShouldSetResponder : topLevelType === EventConstants.topLevelTypes.topSelectionChange ? eventTypes.selectionChangeShouldSetResponder : eventTypes.scrollShouldSetResponder;

			var bubbleShouldSetFrom = !responderInst ? targetInst : EventPluginUtils.getLowestCommonAncestor(responderInst, targetInst);

			var skipOverBubbleShouldSetFrom = bubbleShouldSetFrom === responderInst;
			var shouldSetEvent = ResponderSyntheticEvent.getPooled(shouldSetEventType, bubbleShouldSetFrom, nativeEvent, nativeEventTarget);
			shouldSetEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
			if (skipOverBubbleShouldSetFrom) {
				EventPropagators.accumulateTwoPhaseDispatchesSkipTarget(shouldSetEvent);
			} else {
				EventPropagators.accumulateTwoPhaseDispatches(shouldSetEvent);
			}
			var wantsResponderInst = executeDispatchesInOrderStopAtTrue(shouldSetEvent);
			if (!shouldSetEvent.isPersistent()) {
				shouldSetEvent.constructor.release(shouldSetEvent);
			}

			if (!wantsResponderInst || wantsResponderInst === responderInst) {
				return null;
			}
			var extracted;
			var grantEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderGrant, wantsResponderInst, nativeEvent, nativeEventTarget);
			grantEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;

			EventPropagators.accumulateDirectDispatches(grantEvent);
			var blockHostResponder = executeDirectDispatch(grantEvent) === true;
			if (responderInst) {

				var terminationRequestEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminationRequest, responderInst, nativeEvent, nativeEventTarget);
				terminationRequestEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
				EventPropagators.accumulateDirectDispatches(terminationRequestEvent);
				var shouldSwitch = !hasDispatches(terminationRequestEvent) || executeDirectDispatch(terminationRequestEvent);
				if (!terminationRequestEvent.isPersistent()) {
					terminationRequestEvent.constructor.release(terminationRequestEvent);
				}

				if (shouldSwitch) {
					var terminateEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderTerminate, responderInst, nativeEvent, nativeEventTarget);
					terminateEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
					EventPropagators.accumulateDirectDispatches(terminateEvent);
					extracted = accumulate(extracted, [grantEvent, terminateEvent]);
					changeResponder(wantsResponderInst, blockHostResponder);
				} else {
					var rejectEvent = ResponderSyntheticEvent.getPooled(eventTypes.responderReject, wantsResponderInst, nativeEvent, nativeEventTarget);
					rejectEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
					EventPropagators.accumulateDirectDispatches(rejectEvent);
					extracted = accumulate(extracted, rejectEvent);
				}
			} else {
				extracted = accumulate(extracted, grantEvent);
				changeResponder(wantsResponderInst, blockHostResponder);
			}
			return extracted;
		}

		function canTriggerTransfer(topLevelType, topLevelInst, nativeEvent) {
			return topLevelInst && (topLevelType === EventConstants.topLevelTypes.topScroll && !nativeEvent.responderIgnoreScroll || trackedTouchCount > 0 && topLevelType === EventConstants.topLevelTypes.topSelectionChange || isStartish(topLevelType) || isMoveish(topLevelType));
		}

		function noResponderTouches(nativeEvent) {
			var touches = nativeEvent.touches;
			if (!touches || touches.length === 0) {
				return true;
			}
			for (var i = 0; i < touches.length; i++) {
				var activeTouch = touches[i];
				var target = activeTouch.target;
				if (target !== null && target !== undefined && target !== 0) {

					var targetInst = EventPluginUtils.getInstanceFromNode(target);
					if (EventPluginUtils.isAncestor(responderInst, targetInst)) {
						return false;
					}
				}
			}
			return true;
		}

		var ResponderEventPlugin = {

			_getResponderID: function _getResponderID() {
				return responderInst ? responderInst._rootNodeID : null;
			},

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				if (isStartish(topLevelType)) {
					trackedTouchCount += 1;
				} else if (isEndish(topLevelType)) {
					if (trackedTouchCount >= 0) {
						trackedTouchCount -= 1;
					} else {
						console.error('Ended a touch event which was not counted in `trackedTouchCount`.');
						return null;
					}
				}

				ResponderTouchHistoryStore.recordTouchTrack(topLevelType, nativeEvent);

				var extracted = canTriggerTransfer(topLevelType, targetInst, nativeEvent) ? setResponderAndExtractTransfer(topLevelType, targetInst, nativeEvent, nativeEventTarget) : null;

				var isResponderTouchStart = responderInst && isStartish(topLevelType);
				var isResponderTouchMove = responderInst && isMoveish(topLevelType);
				var isResponderTouchEnd = responderInst && isEndish(topLevelType);
				var incrementalTouch = isResponderTouchStart ? eventTypes.responderStart : isResponderTouchMove ? eventTypes.responderMove : isResponderTouchEnd ? eventTypes.responderEnd : null;

				if (incrementalTouch) {
					var gesture = ResponderSyntheticEvent.getPooled(incrementalTouch, responderInst, nativeEvent, nativeEventTarget);
					gesture.touchHistory = ResponderTouchHistoryStore.touchHistory;
					EventPropagators.accumulateDirectDispatches(gesture);
					extracted = accumulate(extracted, gesture);
				}

				var isResponderTerminate = responderInst && topLevelType === EventConstants.topLevelTypes.topTouchCancel;
				var isResponderRelease = responderInst && !isResponderTerminate && isEndish(topLevelType) && noResponderTouches(nativeEvent);
				var finalTouch = isResponderTerminate ? eventTypes.responderTerminate : isResponderRelease ? eventTypes.responderRelease : null;
				if (finalTouch) {
					var finalEvent = ResponderSyntheticEvent.getPooled(finalTouch, responderInst, nativeEvent, nativeEventTarget);
					finalEvent.touchHistory = ResponderTouchHistoryStore.touchHistory;
					EventPropagators.accumulateDirectDispatches(finalEvent);
					extracted = accumulate(extracted, finalEvent);
					changeResponder(null);
				}

				var numberActiveTouches = ResponderTouchHistoryStore.touchHistory.numberActiveTouches;
				if (ResponderEventPlugin.GlobalInteractionHandler && numberActiveTouches !== previousActiveTouches) {
					ResponderEventPlugin.GlobalInteractionHandler.onChange(numberActiveTouches);
				}
				previousActiveTouches = numberActiveTouches;

				return extracted;
			},

			GlobalResponderHandler: null,
			GlobalInteractionHandler: null,

			injection: {

				injectGlobalResponderHandler: function injectGlobalResponderHandler(GlobalResponderHandler) {
					ResponderEventPlugin.GlobalResponderHandler = GlobalResponderHandler;
				},

				injectGlobalInteractionHandler: function injectGlobalInteractionHandler(GlobalInteractionHandler) {
					ResponderEventPlugin.GlobalInteractionHandler = GlobalInteractionHandler;
				} } };

		module.exports = ResponderEventPlugin;
	}, // __react__/lib/ResponderSyntheticEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var ResponderEventInterface = {
			touchHistory: function touchHistory(nativeEvent) {
				return null;
			} };

		function ResponderSyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(ResponderSyntheticEvent, ResponderEventInterface);

		module.exports = ResponderSyntheticEvent;
	}, // __react__/lib/ResponderTouchHistoryStore.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var isEndish = EventPluginUtils.isEndish;
		var isMoveish = EventPluginUtils.isMoveish;
		var isStartish = EventPluginUtils.isStartish;

		var MAX_TOUCH_BANK = 20;
		var touchBank = [];
		var touchHistory = {
			touchBank: touchBank,
			numberActiveTouches: 0,

			indexOfSingleActiveTouch: -1,
			mostRecentTimeStamp: 0 };

		function timestampForTouch(touch) {

			return touch.timeStamp || touch.timestamp;
		}

		function createTouchRecord(touch) {
			return {
				touchActive: true,
				startPageX: touch.pageX,
				startPageY: touch.pageY,
				startTimeStamp: timestampForTouch(touch),
				currentPageX: touch.pageX,
				currentPageY: touch.pageY,
				currentTimeStamp: timestampForTouch(touch),
				previousPageX: touch.pageX,
				previousPageY: touch.pageY,
				previousTimeStamp: timestampForTouch(touch) };
		}

		function resetTouchRecord(touchRecord, touch) {
			touchRecord.touchActive = true;
			touchRecord.startPageX = touch.pageX;
			touchRecord.startPageY = touch.pageY;
			touchRecord.startTimeStamp = timestampForTouch(touch);
			touchRecord.currentPageX = touch.pageX;
			touchRecord.currentPageY = touch.pageY;
			touchRecord.currentTimeStamp = timestampForTouch(touch);
			touchRecord.previousPageX = touch.pageX;
			touchRecord.previousPageY = touch.pageY;
			touchRecord.previousTimeStamp = timestampForTouch(touch);
		}

		function getTouchIdentifier(_ref) {
			var identifier = _ref.identifier;

			!(identifier != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Touch object is missing identifier.') : _prodInvariant('138') : void 0;
			process.env.NODE_ENV !== 'production' ? warning(identifier <= MAX_TOUCH_BANK, 'Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK) : void 0;
			return identifier;
		}

		function recordTouchStart(touch) {
			var identifier = getTouchIdentifier(touch);
			var touchRecord = touchBank[identifier];
			if (touchRecord) {
				resetTouchRecord(touchRecord, touch);
			} else {
				touchBank[identifier] = createTouchRecord(touch);
			}
			touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
		}

		function recordTouchMove(touch) {
			var touchRecord = touchBank[getTouchIdentifier(touch)];
			if (touchRecord) {
				touchRecord.touchActive = true;
				touchRecord.previousPageX = touchRecord.currentPageX;
				touchRecord.previousPageY = touchRecord.currentPageY;
				touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
				touchRecord.currentPageX = touch.pageX;
				touchRecord.currentPageY = touch.pageY;
				touchRecord.currentTimeStamp = timestampForTouch(touch);
				touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
			} else {
				console.error('Cannot record touch move without a touch start.\n' + 'Touch Move: %s\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());
			}
		}

		function recordTouchEnd(touch) {
			var touchRecord = touchBank[getTouchIdentifier(touch)];
			if (touchRecord) {
				touchRecord.touchActive = false;
				touchRecord.previousPageX = touchRecord.currentPageX;
				touchRecord.previousPageY = touchRecord.currentPageY;
				touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;
				touchRecord.currentPageX = touch.pageX;
				touchRecord.currentPageY = touch.pageY;
				touchRecord.currentTimeStamp = timestampForTouch(touch);
				touchHistory.mostRecentTimeStamp = timestampForTouch(touch);
			} else {
				console.error('Cannot record touch end without a touch start.\n' + 'Touch End: %s\n', 'Touch Bank: %s', printTouch(touch), printTouchBank());
			}
		}

		function printTouch(touch) {
			return JSON.stringify({
				identifier: touch.identifier,
				pageX: touch.pageX,
				pageY: touch.pageY,
				timestamp: timestampForTouch(touch) });
		}

		function printTouchBank() {
			var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));
			if (touchBank.length > MAX_TOUCH_BANK) {
				printed += ' (original size: ' + touchBank.length + ')';
			}
			return printed;
		}

		var ResponderTouchHistoryStore = {
			recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {
				if (isMoveish(topLevelType)) {
					nativeEvent.changedTouches.forEach(recordTouchMove);
				} else if (isStartish(topLevelType)) {
					nativeEvent.changedTouches.forEach(recordTouchStart);
					touchHistory.numberActiveTouches = nativeEvent.touches.length;
					if (touchHistory.numberActiveTouches === 1) {
						touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;
					}
				} else if (isEndish(topLevelType)) {
					nativeEvent.changedTouches.forEach(recordTouchEnd);
					touchHistory.numberActiveTouches = nativeEvent.touches.length;
					if (touchHistory.numberActiveTouches === 1) {
						for (var i = 0; i < touchBank.length; i++) {
							var touchTrackToCheck = touchBank[i];
							if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {
								touchHistory.indexOfSingleActiveTouch = i;
								break;
							}
						}
						if (process.env.NODE_ENV !== 'production') {
							var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];
							process.env.NODE_ENV !== 'production' ? warning(activeRecord != null && activeRecord.touchActive, 'Cannot find single active touch.') : void 0;
						}
					}
				}
			},

			touchHistory: touchHistory };

		module.exports = ResponderTouchHistoryStore;
	}, // __react__/lib/accumulate.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function accumulate(current, next) {
			!(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulate(...): Accumulated items must be not be null or undefined.') : _prodInvariant('29') : void 0;

			if (current == null) {
				return next;
			}

			if (Array.isArray(current)) {
				return current.concat(next);
			}

			if (Array.isArray(next)) {
				return [current].concat(next);
			}

			return [current, next];
		}

		module.exports = accumulate;
	}, // lib/View.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(38 /*Libraries/Components/View/View.js*/);
	}, // Libraries/Components/ScrollView/ScrollView.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PointPropType = __inner_require__(113 /*Libraries/StyleSheet/PointPropType.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var ScrollResponder = __inner_require__(114 /*Libraries/Components/ScrollResponder.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var dismissKeyboard = __inner_require__(116 /*Libraries/Utilities/dismissKeyboard.js*/);
		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var processDecelerationRate = __inner_require__(117 /*Libraries/Components/ScrollView/processDecelerationRate.js*/);
		var PropTypes = React.PropTypes;
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var ScrollView = React.createClass({ displayName: 'ScrollView',
			propTypes: babelHelpers.extends({}, View.propTypes, {

				automaticallyAdjustContentInsets: PropTypes.bool,

				contentInset: EdgeInsetsPropType,

				contentOffset: PointPropType,

				bounces: PropTypes.bool,

				bouncesZoom: PropTypes.bool,

				alwaysBounceHorizontal: PropTypes.bool,

				alwaysBounceVertical: PropTypes.bool,

				centerContent: PropTypes.bool,

				contentContainerStyle: StyleSheetPropType(ViewStylePropTypes),

				decelerationRate: PropTypes.oneOfType([PropTypes.oneOf(['fast', 'normal']), PropTypes.number]),

				horizontal: PropTypes.bool,

				indicatorStyle: PropTypes.oneOf(['default', 'black', 'white']),

				directionalLockEnabled: PropTypes.bool,

				canCancelContentTouches: PropTypes.bool,

				keyboardDismissMode: PropTypes.oneOf(['none', 'interactive', 'on-drag']),

				keyboardShouldPersistTaps: PropTypes.bool,

				maximumZoomScale: PropTypes.number,

				minimumZoomScale: PropTypes.number,

				onScroll: PropTypes.func,

				onScrollAnimationEnd: PropTypes.func,

				onContentSizeChange: PropTypes.func,

				pagingEnabled: PropTypes.bool,

				scrollEnabled: PropTypes.bool,

				scrollEventThrottle: PropTypes.number,

				scrollIndicatorInsets: EdgeInsetsPropType,

				scrollsToTop: PropTypes.bool,

				showsHorizontalScrollIndicator: PropTypes.bool,

				showsVerticalScrollIndicator: PropTypes.bool,

				stickyHeaderIndices: PropTypes.arrayOf(PropTypes.number),
				style: StyleSheetPropType(ViewStylePropTypes),

				snapToInterval: PropTypes.number,

				snapToAlignment: PropTypes.oneOf(['start', 'center', 'end']),

				removeClippedSubviews: PropTypes.bool,

				zoomScale: PropTypes.number,

				refreshControl: PropTypes.element,

				endFillColor: ColorPropType,

				scrollPerfTag: PropTypes.string }),

			mixins: [ScrollResponder.Mixin],

			getInitialState: function getInitialState() {
				return this.scrollResponderMixinGetInitialState();
			},

			setNativeProps: function setNativeProps(props) {
				this._scrollViewRef && this._scrollViewRef.setNativeProps(props);
			},

			getScrollResponder: function getScrollResponder() {
				return this;
			},

			getScrollableNode: function getScrollableNode() {
				return ReactNative.findNodeHandle(this._scrollViewRef);
			},

			getInnerViewNode: function getInnerViewNode() {
				return ReactNative.findNodeHandle(this._innerViewRef);
			},

			scrollTo: function scrollTo(y, x, animated) {
				if (typeof y === 'number') {
					console.warn('`scrollTo(y, x, animated)` is deprecated. Use `scrollTo({x: 5, y: 5, animated: true})` instead.');
				} else {
					var _ref = y || {};x = _ref.x;y = _ref.y;animated = _ref.animated;
				}
				this.getScrollResponder().scrollResponderScrollTo({ x: x || 0, y: y || 0, animated: animated !== false });
			},

			scrollWithoutAnimationTo: function scrollWithoutAnimationTo() {
				var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
				console.warn('`scrollWithoutAnimationTo` is deprecated. Use `scrollTo` instead');
				this.scrollTo({ x: x, y: y, animated: false });
			},

			_handleScroll: function _handleScroll(e) {
				if (__DEV__) {
					if (this.props.onScroll && !this.props.scrollEventThrottle && Platform.OS === 'ios') {
						console.log('You specified `onScroll` on a <ScrollView> but not ' + '`scrollEventThrottle`. You will only receive one event. ' + 'Using `16` you get all the events but be aware that it may ' + 'cause frame drops, use a bigger number if you don\'t need as ' + 'much precision.');
					}
				}
				if (Platform.OS === 'android') {
					if (this.props.keyboardDismissMode === 'on-drag') {
						dismissKeyboard();
					}
				}
				this.scrollResponderHandleScroll(e);
			},

			_handleContentOnLayout: function _handleContentOnLayout(e) {
				var _e$nativeEvent$layout = e.nativeEvent.layout,
				    width = _e$nativeEvent$layout.width,
				    height = _e$nativeEvent$layout.height;
				this.props.onContentSizeChange && this.props.onContentSizeChange(width, height);
			},

			_scrollViewRef: null,
			_setScrollViewRef: function _setScrollViewRef(ref) {
				this._scrollViewRef = ref;
			},

			_innerViewRef: null,
			_setInnerViewRef: function _setInnerViewRef(ref) {
				this._innerViewRef = ref;
			},

			render: function render() {
				var contentContainerStyle = [this.props.horizontal && styles.contentContainerHorizontal, this.props.contentContainerStyle];

				var style = void 0,
				    childLayoutProps = void 0;
				if (__DEV__ && this.props.style) {
					style = flattenStyle(this.props.style);
					childLayoutProps = ['alignItems', 'justifyContent'].filter(function (prop) {
						return style && style[prop] !== undefined;
					});
					invariant(childLayoutProps.length === 0, 'ScrollView child layout (' + JSON.stringify(childLayoutProps) + ') must be applied through the contentContainerStyle prop.');
				}

				var contentSizeChangeProps = {};
				if (this.props.onContentSizeChange) {
					contentSizeChangeProps = {
						onLayout: this._handleContentOnLayout };
				}

				var contentContainer = React.createElement(View, babelHelpers.extends({}, contentSizeChangeProps, {
					ref: this._setInnerViewRef,
					style: contentContainerStyle,
					removeClippedSubviews: this.props.removeClippedSubviews,
					collapsable: false }), this.props.children);

				var alwaysBounceHorizontal = this.props.alwaysBounceHorizontal !== undefined ? this.props.alwaysBounceHorizontal : this.props.horizontal;

				var alwaysBounceVertical = this.props.alwaysBounceVertical !== undefined ? this.props.alwaysBounceVertical : !this.props.horizontal;

				var baseStyle = this.props.horizontal ? styles.baseHorizontal : styles.baseVertical;
				var props = babelHelpers.extends({}, this.props, {
					alwaysBounceHorizontal: alwaysBounceHorizontal,
					alwaysBounceVertical: alwaysBounceVertical,
					style: [baseStyle, this.props.style],
					onTouchStart: this.scrollResponderHandleTouchStart,
					onTouchMove: this.scrollResponderHandleTouchMove,
					onTouchEnd: this.scrollResponderHandleTouchEnd,
					onScrollBeginDrag: this.scrollResponderHandleScrollBeginDrag,
					onScrollEndDrag: this.scrollResponderHandleScrollEndDrag,
					onMomentumScrollBegin: this.scrollResponderHandleMomentumScrollBegin,
					onMomentumScrollEnd: this.scrollResponderHandleMomentumScrollEnd,
					onStartShouldSetResponder: this.scrollResponderHandleStartShouldSetResponder,
					onStartShouldSetResponderCapture: this.scrollResponderHandleStartShouldSetResponderCapture,
					onScrollShouldSetResponder: this.scrollResponderHandleScrollShouldSetResponder,
					onScroll: this._handleScroll,
					onResponderGrant: this.scrollResponderHandleResponderGrant,
					onResponderTerminationRequest: this.scrollResponderHandleTerminationRequest,
					onResponderTerminate: this.scrollResponderHandleTerminate,
					onResponderRelease: this.scrollResponderHandleResponderRelease,
					onResponderReject: this.scrollResponderHandleResponderReject,
					sendMomentumEvents: this.props.onMomentumScrollBegin || this.props.onMomentumScrollEnd ? true : false });var decelerationRate = this.props.decelerationRate;
				if (decelerationRate) {
					props.decelerationRate = processDecelerationRate(decelerationRate);
				}

				var ScrollViewClass = void 0;
				if (Platform.OS === 'ios') {
					ScrollViewClass = RCTScrollView;
				} else if (Platform.OS === 'android') {
					if (this.props.horizontal) {
						ScrollViewClass = AndroidHorizontalScrollView;
					} else {
						ScrollViewClass = AndroidScrollView;
					}
				}
				invariant(ScrollViewClass !== undefined, 'ScrollViewClass must not be undefined');

				var refreshControl = this.props.refreshControl;
				if (refreshControl) {
					if (Platform.OS === 'ios') {

						return React.createElement(ScrollViewClass, babelHelpers.extends({}, props, { ref: this._setScrollViewRef }), refreshControl, contentContainer);
					} else if (Platform.OS === 'android') {

						return React.cloneElement(refreshControl, { style: props.style }, React.createElement(ScrollViewClass, babelHelpers.extends({}, props, { style: baseStyle, ref: this._setScrollViewRef }), contentContainer));
					}
				}
				return React.createElement(ScrollViewClass, babelHelpers.extends({}, props, { ref: this._setScrollViewRef }), contentContainer);
			} });

		var styles = StyleSheet.create({
			baseVertical: {
				flex: 1,
				flexDirection: 'column' },

			baseHorizontal: {
				flex: 1,
				flexDirection: 'row' },

			contentContainerHorizontal: {
				flexDirection: 'row' } });

		var nativeOnlyProps = void 0,
		    AndroidScrollView = void 0,
		    AndroidHorizontalScrollView = void 0,
		    RCTScrollView = void 0;
		if (Platform.OS === 'android') {
			nativeOnlyProps = {
				nativeOnly: {
					sendMomentumEvents: true } };

			AndroidScrollView = requireNativeComponent('RCTScrollView', ScrollView, nativeOnlyProps);
			AndroidHorizontalScrollView = requireNativeComponent('AndroidHorizontalScrollView', ScrollView, nativeOnlyProps);
		} else if (Platform.OS === 'ios') {
			nativeOnlyProps = {
				nativeOnly: {
					onMomentumScrollBegin: true,
					onMomentumScrollEnd: true,
					onScrollBeginDrag: true,
					onScrollEndDrag: true } };

			RCTScrollView = requireNativeComponent('RCTScrollView', ScrollView, nativeOnlyProps);
		}

		module.exports = ScrollView;
	}, // Libraries/StyleSheet/PointPropType.js
	function (__inner_require__, exports, module) {
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);

		var createStrictShapeTypeChecker = __inner_require__(40 /*Libraries/Utilities/createStrictShapeTypeChecker.js*/);

		var PointPropType = createStrictShapeTypeChecker({
			x: PropTypes.number,
			y: PropTypes.number });

		module.exports = PointPropType;
	}, // Libraries/Components/ScrollResponder.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var Keyboard = require('react-native@0.33/Libraries/Components/Keyboard/Keyboard.js');
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var Subscribable = __inner_require__(115 /*Libraries/Components/Subscribable.js*/);
		var TextInputState = __inner_require__(9 /*Libraries/Components/TextInput/TextInputState.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');var _require = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js'),
		    ScrollViewManager = _require.ScrollViewManager;

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;

		var ScrollResponderMixin = {
			mixins: [Subscribable.Mixin],
			scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {
				return {
					isTouching: false,
					lastMomentumScrollBeginTime: 0,
					lastMomentumScrollEndTime: 0,

					observedScrollSinceBecomingResponder: false,
					becameResponderWhileAnimating: false };
			},

			scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {
				return this.state.isTouching;
			},

			scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {
				return false;
			},

			scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {

				var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
				if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput) {
					return true;
				}
				return this.scrollResponderIsAnimating();
			},

			scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {},

			scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {
				return !this.state.observedScrollSinceBecomingResponder;
			},

			scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {
				var nativeEvent = e.nativeEvent;
				this.state.isTouching = nativeEvent.touches.length !== 0;
				this.props.onTouchEnd && this.props.onTouchEnd(e);
			},

			scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {
				this.props.onResponderRelease && this.props.onResponderRelease(e);

				var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();
				if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {
					this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);
					TextInputState.blurTextInput(currentlyFocusedTextInput);
				}
			},

			scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {
				this.state.observedScrollSinceBecomingResponder = true;
				this.props.onScroll && this.props.onScroll(e);
			},

			scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {
				this.state.observedScrollSinceBecomingResponder = false;
				this.props.onResponderGrant && this.props.onResponderGrant(e);
				this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();
			},

			scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {
				this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);
			},

			scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {
				this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);
			},

			scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {
				this.state.lastMomentumScrollBeginTime = Date.now();
				this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);
			},

			scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {
				this.state.lastMomentumScrollEndTime = Date.now();
				this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);
			},

			scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {
				this.state.isTouching = true;
				this.props.onTouchStart && this.props.onTouchStart(e);
			},

			scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {
				this.props.onTouchMove && this.props.onTouchMove(e);
			},

			scrollResponderIsAnimating: function scrollResponderIsAnimating() {
				var now = Date.now();
				var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;
				var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;
				return isAnimating;
			},

			scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {
				return this.getScrollableNode ? this.getScrollableNode() : ReactNative.findNodeHandle(this);
			},

			scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {
				if (typeof x === 'number') {
					console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');
				} else {
					var _ref = x || {};x = _ref.x;y = _ref.y;animated = _ref.animated;
				}
				UIManager.dispatchViewManagerCommand(this.scrollResponderGetScrollableNode(), UIManager.RCTScrollView.Commands.scrollTo, [x || 0, y || 0, animated !== false]);
			},

			scrollResponderScrollWithoutAnimationTo: function scrollResponderScrollWithoutAnimationTo(offsetX, offsetY) {
				console.warn('`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead');
				this.scrollResponderScrollTo({ x: offsetX, y: offsetY, animated: false });
			},

			scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) {
				if (Platform.OS === 'android') {
					invariant('zoomToRect is not implemented');
				} else {
					if ('animated' in rect) {
						var animated = rect.animated,
						    rect = babelHelpers.objectWithoutProperties(rect, ['animated']);
					} else if (typeof animated !== 'undefined') {
						console.warn('`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead');
					}
					ScrollViewManager.zoomToRect(this.scrollResponderGetScrollableNode(), rect, animated !== false);
				}
			},

			scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {
				this.additionalScrollOffset = additionalOffset || 0;
				this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;
				UIManager.measureLayout(nodeHandle, ReactNative.findNodeHandle(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);
			},

			scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {
				var keyboardScreenY = Dimensions.get('window').height;
				if (this.keyboardWillOpenTo) {
					keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;
				}
				var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset;

				if (this.preventNegativeScrollOffset) {
					scrollOffsetY = Math.max(0, scrollOffsetY);
				}
				this.scrollResponderScrollTo({ x: 0, y: scrollOffsetY, animated: true });

				this.additionalOffset = 0;
				this.preventNegativeScrollOffset = false;
			},

			scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {
				console.error('Error measuring text field: ', e);
			},

			componentWillMount: function componentWillMount() {
				this.keyboardWillOpenTo = null;
				this.additionalScrollOffset = 0;
				this.addListenerOn(Keyboard, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);
				this.addListenerOn(Keyboard, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);
				this.addListenerOn(Keyboard, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);
				this.addListenerOn(Keyboard, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);
			},

			scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {
				this.keyboardWillOpenTo = e;
				this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);
			},

			scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {
				this.keyboardWillOpenTo = null;
				this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);
			},

			scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {

				if (e) {
					this.keyboardWillOpenTo = e;
				}
				this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);
			},

			scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {
				this.keyboardWillOpenTo = null;
				this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);
			} };

		var ScrollResponder = {
			Mixin: ScrollResponderMixin };

		module.exports = ScrollResponder;
	}, // Libraries/Components/Subscribable.js
	function (__inner_require__, exports, module) {
		var Subscribable = {};

		Subscribable.Mixin = {

			componentWillMount: function componentWillMount() {
				this._subscribableSubscriptions = [];
			},

			componentWillUnmount: function componentWillUnmount() {
				this._subscribableSubscriptions.forEach(function (subscription) {
					return subscription.remove();
				});

				this._subscribableSubscriptions = null;
			},

			addListenerOn: function addListenerOn(eventEmitter, eventType, listener, context) {
				this._subscribableSubscriptions.push(eventEmitter.addListener(eventType, listener, context));
			} };

		module.exports = Subscribable;
	}, // Libraries/Utilities/dismissKeyboard.js
	function (__inner_require__, exports, module) {
		var TextInputState = __inner_require__(9 /*Libraries/Components/TextInput/TextInputState.js*/);

		function dismissKeyboard() {
			TextInputState.blurTextInput(TextInputState.currentlyFocusedField());
		}

		module.exports = dismissKeyboard;
	}, // Libraries/Components/ScrollView/processDecelerationRate.js
	function (__inner_require__, exports, module) {
		function processDecelerationRate(decelerationRate) {
			if (decelerationRate === 'normal') {
				decelerationRate = 0.998;
			} else if (decelerationRate === 'fast') {
				decelerationRate = 0.99;
			}
			return decelerationRate;
		}

		module.exports = processDecelerationRate;
	}, // Libraries/Components/StaticRenderer.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);var StaticRenderer = function (_React$Component) {
			babelHelpers.inherits(StaticRenderer, _React$Component);function StaticRenderer() {
				babelHelpers.classCallCheck(this, StaticRenderer);return babelHelpers.possibleConstructorReturn(this, (StaticRenderer.__proto__ || Object.getPrototypeOf(StaticRenderer)).apply(this, arguments));
			}babelHelpers.createClass(StaticRenderer, [{ key: 'shouldComponentUpdate', value: function shouldComponentUpdate(nextProps) {
					return nextProps.shouldUpdate;
				} }, { key: 'render', value: function render() {
					return this.props.render();
				} }]);return StaticRenderer;
		}(React.Component);StaticRenderer.propTypes = { shouldUpdate: React.PropTypes.bool.isRequired, render: React.PropTypes.func.isRequired };

		module.exports = StaticRenderer;
	}, // Libraries/Components/MapView/MapView.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var deprecatedPropType = __inner_require__(35 /*Libraries/Utilities/deprecatedPropType.js*/);
		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');
		var resolveAssetSource = __inner_require__(71 /*Libraries/Image/resolveAssetSource.js*/);
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var MapView = React.createClass({ displayName: 'MapView',

			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				style: View.propTypes.style,

				showsUserLocation: React.PropTypes.bool,

				followUserLocation: React.PropTypes.bool,

				showsPointsOfInterest: React.PropTypes.bool,

				showsCompass: React.PropTypes.bool,

				zoomEnabled: React.PropTypes.bool,

				rotateEnabled: React.PropTypes.bool,

				pitchEnabled: React.PropTypes.bool,

				scrollEnabled: React.PropTypes.bool,

				mapType: React.PropTypes.oneOf(['standard', 'satellite', 'hybrid']),

				region: React.PropTypes.shape({

					latitude: React.PropTypes.number.isRequired,
					longitude: React.PropTypes.number.isRequired,

					latitudeDelta: React.PropTypes.number,
					longitudeDelta: React.PropTypes.number }),

				annotations: React.PropTypes.arrayOf(React.PropTypes.shape({

					latitude: React.PropTypes.number.isRequired,
					longitude: React.PropTypes.number.isRequired,

					animateDrop: React.PropTypes.bool,

					draggable: React.PropTypes.bool,

					onDragStateChange: React.PropTypes.func,

					onFocus: React.PropTypes.func,

					onBlur: React.PropTypes.func,

					title: React.PropTypes.string,
					subtitle: React.PropTypes.string,

					leftCalloutView: React.PropTypes.element,
					rightCalloutView: React.PropTypes.element,
					detailCalloutView: React.PropTypes.element,

					tintColor: ColorPropType,

					image: Image.propTypes.source,

					view: React.PropTypes.element,

					id: React.PropTypes.string,

					hasLeftCallout: deprecatedPropType(React.PropTypes.bool, 'Use `leftCalloutView` instead.'),

					hasRightCallout: deprecatedPropType(React.PropTypes.bool, 'Use `rightCalloutView` instead.'),

					onLeftCalloutPress: deprecatedPropType(React.PropTypes.func, 'Use `leftCalloutView` instead.'),

					onRightCalloutPress: deprecatedPropType(React.PropTypes.func, 'Use `rightCalloutView` instead.') })),

				overlays: React.PropTypes.arrayOf(React.PropTypes.shape({

					coordinates: React.PropTypes.arrayOf(React.PropTypes.shape({
						latitude: React.PropTypes.number.isRequired,
						longitude: React.PropTypes.number.isRequired })),

					lineWidth: React.PropTypes.number,
					strokeColor: ColorPropType,
					fillColor: ColorPropType,

					id: React.PropTypes.string })),

				maxDelta: React.PropTypes.number,

				minDelta: React.PropTypes.number,

				legalLabelInsets: EdgeInsetsPropType,

				onRegionChange: React.PropTypes.func,

				onRegionChangeComplete: React.PropTypes.func,

				onAnnotationPress: React.PropTypes.func,

				active: React.PropTypes.bool }),

			statics: {

				PinColors: {
					RED: '#ff3b30',
					GREEN: '#4cd964',
					PURPLE: '#c969e0' } },

			render: function render() {
				var _this = this;
				var children = [],
				    _props = this.props,
				    annotations = _props.annotations,
				    overlays = _props.overlays,
				    followUserLocation = _props.followUserLocation;
				annotations = annotations && annotations.map(function (annotation) {
					var id = annotation.id,
					    image = annotation.image,
					    tintColor = annotation.tintColor,
					    view = annotation.view,
					    leftCalloutView = annotation.leftCalloutView,
					    rightCalloutView = annotation.rightCalloutView,
					    detailCalloutView = annotation.detailCalloutView;

					if (!view && image && tintColor) {
						view = React.createElement(Image, {
							style: {
								tintColor: processColor(tintColor) },

							source: image });

						image = undefined;
					}
					if (view) {
						if (image) {
							console.warn('`image` and `view` both set on annotation. Image will be ignored.');
						}
						var viewIndex = children.length;
						children.push(React.cloneElement(view, {

							style: [styles.annotationView, view.props.style || {}] }));
					}
					if (leftCalloutView) {
						var leftCalloutViewIndex = children.length;
						children.push(React.cloneElement(leftCalloutView, {
							style: [styles.calloutView, leftCalloutView.props.style || {}] }));
					}
					if (rightCalloutView) {
						var rightCalloutViewIndex = children.length;
						children.push(React.cloneElement(rightCalloutView, {
							style: [styles.calloutView, rightCalloutView.props.style || {}] }));
					}
					if (detailCalloutView) {
						var detailCalloutViewIndex = children.length;
						children.push(React.cloneElement(detailCalloutView, {
							style: [styles.calloutView, detailCalloutView.props.style || {}] }));
					}

					var result = babelHelpers.extends({}, annotation, {
						tintColor: tintColor && processColor(tintColor),
						image: image,
						viewIndex: viewIndex,
						leftCalloutViewIndex: leftCalloutViewIndex,
						rightCalloutViewIndex: rightCalloutViewIndex,
						detailCalloutViewIndex: detailCalloutViewIndex,
						view: undefined,
						leftCalloutView: undefined,
						rightCalloutView: undefined,
						detailCalloutView: undefined });

					result.id = id || encodeURIComponent(JSON.stringify(result));
					result.image = image && resolveAssetSource(image);
					return result;
				});
				overlays = overlays && overlays.map(function (overlay) {
					var id = overlay.id,
					    fillColor = overlay.fillColor,
					    strokeColor = overlay.strokeColor;
					var result = babelHelpers.extends({}, overlay, {
						strokeColor: strokeColor && processColor(strokeColor),
						fillColor: fillColor && processColor(fillColor) });

					result.id = id || encodeURIComponent(JSON.stringify(result));
					return result;
				});

				var findByAnnotationId = function findByAnnotationId(annotationId) {
					if (!annotations) {
						return null;
					}
					for (var i = 0, l = annotations.length; i < l; i++) {
						if (annotations[i].id === annotationId) {
							return annotations[i];
						}
					}
					return null;
				};

				var onPress = void 0,
				    onAnnotationDragStateChange = void 0,
				    onAnnotationFocus = void 0,
				    onAnnotationBlur = void 0;
				if (annotations) {
					onPress = function onPress(event) {
						if (event.nativeEvent.action === 'annotation-click') {

							_this.props.onAnnotationPress && _this.props.onAnnotationPress(event.nativeEvent.annotation);
						} else if (event.nativeEvent.action === 'callout-click') {
							var annotation = findByAnnotationId(event.nativeEvent.annotationId);
							if (annotation) {

								if (event.nativeEvent.side === 'left' && annotation.onLeftCalloutPress) {
									annotation.onLeftCalloutPress(event.nativeEvent);
								} else if (event.nativeEvent.side === 'right' && annotation.onRightCalloutPress) {
									annotation.onRightCalloutPress(event.nativeEvent);
								}
							}
						}
					};
					onAnnotationDragStateChange = function onAnnotationDragStateChange(event) {
						var annotation = findByAnnotationId(event.nativeEvent.annotationId);
						if (annotation) {

							annotation.onDragStateChange && annotation.onDragStateChange(event.nativeEvent);
						}
					};
					onAnnotationFocus = function onAnnotationFocus(event) {
						var annotation = findByAnnotationId(event.nativeEvent.annotationId);
						if (annotation && annotation.onFocus) {
							annotation.onFocus(event.nativeEvent);
						}
					};
					onAnnotationBlur = function onAnnotationBlur(event) {
						var annotation = findByAnnotationId(event.nativeEvent.annotationId);
						if (annotation && annotation.onBlur) {
							annotation.onBlur(event.nativeEvent);
						}
					};
				}

				if (this.props.onRegionChange || this.props.onRegionChangeComplete) {
					var onChange = function onChange(event) {
						if (event.nativeEvent.continuous) {
							_this.props.onRegionChange && _this.props.onRegionChange(event.nativeEvent.region);
						} else {
							_this.props.onRegionChangeComplete && _this.props.onRegionChangeComplete(event.nativeEvent.region);
						}
					};
				}

				if (followUserLocation === undefined) {
					followUserLocation = this.props.showUserLocation;
				}

				return React.createElement(RCTMap, babelHelpers.extends({}, this.props, {
					annotations: annotations,
					children: children,
					followUserLocation: followUserLocation,
					overlays: overlays,
					onPress: onPress,
					onChange: onChange,
					onAnnotationDragStateChange: onAnnotationDragStateChange,
					onAnnotationFocus: onAnnotationFocus,
					onAnnotationBlur: onAnnotationBlur }));
			} });

		var styles = StyleSheet.create({
			annotationView: {
				position: 'absolute',
				backgroundColor: 'transparent' },

			calloutView: {
				position: 'absolute',
				backgroundColor: 'white' } });

		var RCTMap = requireNativeComponent('RCTMap', MapView, {
			nativeOnly: {
				onAnnotationDragStateChange: true,
				onAnnotationFocus: true,
				onAnnotationBlur: true,
				onChange: true,
				onPress: true } });

		module.exports = MapView;
	}, // Libraries/Modal/Modal.js
	function (__inner_require__, exports, module) {
		var _container;

		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var deprecatedPropType = __inner_require__(35 /*Libraries/Utilities/deprecatedPropType.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);
		var RCTModalHostView = requireNativeComponent('RCTModalHostView', null);var Modal = function (_React$Component) {
			babelHelpers.inherits(Modal, _React$Component);function Modal() {
				babelHelpers.classCallCheck(this, Modal);return babelHelpers.possibleConstructorReturn(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).apply(this, arguments));
			}babelHelpers.createClass(Modal, [{ key: 'render', value: function render() {
					if (this.props.visible === false) {
						return null;
					}

					var containerStyles = {
						backgroundColor: this.props.transparent ? 'transparent' : 'white',
						top: Platform.OS === 'android' && Platform.Version >= 19 ? UIManager.RCTModalHostView.Constants.StatusBarHeight : 0 };

					var animationType = this.props.animationType;
					if (!animationType) {

						animationType = 'none';
						if (this.props.animated) {
							animationType = 'slide';
						}
					}

					return React.createElement(RCTModalHostView, {
						animationType: animationType,
						transparent: this.props.transparent,
						onRequestClose: this.props.onRequestClose,
						onShow: this.props.onShow,
						style: styles.modal,
						onStartShouldSetResponder: this._shouldSetResponder }, React.createElement(View, { style: [styles.container, containerStyles] }, this.props.children));
				} }, { key: '_shouldSetResponder', value: function _shouldSetResponder() {
					return true;
				} }]);return Modal;
		}(React.Component);Modal.propTypes = { animationType: PropTypes.oneOf(['none', 'slide', 'fade']), transparent: PropTypes.bool, visible: PropTypes.bool, onRequestClose: Platform.OS === 'android' ? PropTypes.func.isRequired : PropTypes.func, onShow: PropTypes.func, animated: deprecatedPropType(PropTypes.bool, 'Use the `animationType` prop instead.') };Modal.defaultProps = { visible: true };

		var side = I18nManager.isRTL ? 'right' : 'left';
		var styles = StyleSheet.create({
			modal: {
				position: 'absolute' },

			container: (_container = {
				position: 'absolute' }, babelHelpers.defineProperty(_container, side, 0), babelHelpers.defineProperty(_container, 'top', 0), _container) });

		module.exports = Modal;
	}, // Libraries/Utilities/I18nManager.js
	function (__inner_require__, exports, module) {
		var I18nManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').I18nManager || {
			isRTL: false,
			allowRTL: function allowRTL() {},
			forceRTL: function forceRTL() {} };

		module.exports = I18nManager;
	}, // Libraries/CustomComponents/Navigator/Navigator.js
	function (__inner_require__, exports, module) {
		var AnimationsDebugModule = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').AnimationsDebugModule;
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var InteractionMixin = __inner_require__(123 /*Libraries/Interaction/InteractionMixin.js*/);
		var NavigationContext = __inner_require__(127 /*Libraries/CustomComponents/Navigator/Navigation/NavigationContext.js*/);
		var NavigatorBreadcrumbNavigationBar = __inner_require__(131 /*Libraries/CustomComponents/Navigator/NavigatorBreadcrumbNavigationBar.js*/);
		var NavigatorNavigationBar = __inner_require__(136 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBar.js*/);
		var NavigatorSceneConfigs = __inner_require__(137 /*Libraries/CustomComponents/Navigator/NavigatorSceneConfigs.js*/);
		var PanResponder = __inner_require__(138 /*Libraries/Interaction/PanResponder.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Subscribable = __inner_require__(115 /*Libraries/Components/Subscribable.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var clamp = __inner_require__(140 /*Libraries/Utilities/clamp.js*/);
		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var rebound = require('rebound@0.0.13/rebound.js');

		var PropTypes = React.PropTypes;

		var SCREEN_WIDTH = Dimensions.get('window').width;
		var SCREEN_HEIGHT = Dimensions.get('window').height;
		var SCENE_DISABLED_NATIVE_PROPS = {
			pointerEvents: 'none',
			style: {
				top: SCREEN_HEIGHT,
				bottom: -SCREEN_HEIGHT,
				opacity: 0 } };

		var __uid = 0;
		function getuid() {
			return __uid++;
		}

		function getRouteID(route) {
			if (route === null || typeof route !== 'object') {
				return String(route);
			}

			var key = '__navigatorRouteID';

			if (!route.hasOwnProperty(key)) {
				Object.defineProperty(route, key, {
					enumerable: false,
					configurable: false,
					writable: false,
					value: getuid() });
			}
			return route[key];
		}

		var styles = StyleSheet.create({
			container: {
				flex: 1,
				overflow: 'hidden' },

			defaultSceneStyle: {
				position: 'absolute',
				left: 0,
				right: 0,
				bottom: 0,
				top: 0 },

			baseScene: {
				position: 'absolute',
				overflow: 'hidden',
				left: 0,
				right: 0,
				bottom: 0,
				top: 0 },

			disabledScene: {
				top: SCREEN_HEIGHT,
				bottom: -SCREEN_HEIGHT },

			transitioner: {
				flex: 1,
				backgroundColor: 'transparent',
				overflow: 'hidden' } });

		var GESTURE_ACTIONS = ['pop', 'jumpBack', 'jumpForward'];

		var Navigator = React.createClass({ displayName: 'Navigator',

			propTypes: {

				configureScene: PropTypes.func,

				renderScene: PropTypes.func.isRequired,

				initialRoute: PropTypes.object,

				initialRouteStack: PropTypes.arrayOf(PropTypes.object),

				onWillFocus: PropTypes.func,

				onDidFocus: PropTypes.func,

				navigationBar: PropTypes.node,

				navigator: PropTypes.object,

				sceneStyle: View.propTypes.style },

			statics: {
				BreadcrumbNavigationBar: NavigatorBreadcrumbNavigationBar,
				NavigationBar: NavigatorNavigationBar,
				SceneConfigs: NavigatorSceneConfigs },

			mixins: [TimerMixin, InteractionMixin, Subscribable.Mixin],

			getDefaultProps: function getDefaultProps() {
				return {
					configureScene: function configureScene() {
						return NavigatorSceneConfigs.PushFromRight;
					},
					sceneStyle: styles.defaultSceneStyle };
			},

			getInitialState: function getInitialState() {
				var _this = this;
				this._navigationBarNavigator = this.props.navigationBarNavigator || this;

				this._renderedSceneMap = new Map();

				var routeStack = this.props.initialRouteStack || [this.props.initialRoute];
				invariant(routeStack.length >= 1, 'Navigator requires props.initialRoute or props.initialRouteStack.');

				var initialRouteIndex = routeStack.length - 1;
				if (this.props.initialRoute) {
					initialRouteIndex = routeStack.indexOf(this.props.initialRoute);
					invariant(initialRouteIndex !== -1, 'initialRoute is not in initialRouteStack.');
				}
				return {
					sceneConfigStack: routeStack.map(function (route) {
						return _this.props.configureScene(route, routeStack);
					}),

					routeStack: routeStack,
					presentedIndex: initialRouteIndex,
					transitionFromIndex: null,
					activeGesture: null,
					pendingGestureProgress: null,
					transitionQueue: [] };
			},

			componentWillMount: function componentWillMount() {
				var _this2 = this;

				this.__defineGetter__('navigationContext', this._getNavigationContext);

				this._subRouteFocus = [];
				this.parentNavigator = this.props.navigator;
				this._handlers = {};
				this.springSystem = new rebound.SpringSystem();
				this.spring = this.springSystem.createSpring();
				this.spring.setRestSpeedThreshold(0.05);
				this.spring.setCurrentValue(0).setAtRest();
				this.spring.addListener({
					onSpringEndStateChange: function onSpringEndStateChange() {
						if (!_this2._interactionHandle) {
							_this2._interactionHandle = _this2.createInteractionHandle();
						}
					},
					onSpringUpdate: function onSpringUpdate() {
						_this2._handleSpringUpdate();
					},
					onSpringAtRest: function onSpringAtRest() {
						_this2._completeTransition();
					} });

				this.panGesture = PanResponder.create({
					onMoveShouldSetPanResponder: this._handleMoveShouldSetPanResponder,
					onPanResponderRelease: this._handlePanResponderRelease,
					onPanResponderMove: this._handlePanResponderMove,
					onPanResponderTerminate: this._handlePanResponderTerminate });

				this._interactionHandle = null;
				this._emitWillFocus(this.state.routeStack[this.state.presentedIndex]);
			},

			componentDidMount: function componentDidMount() {
				this._handleSpringUpdate();
				this._emitDidFocus(this.state.routeStack[this.state.presentedIndex]);
			},

			componentWillUnmount: function componentWillUnmount() {
				if (this._navigationContext) {
					this._navigationContext.dispose();
					this._navigationContext = null;
				}

				this.spring.destroy();

				if (this._interactionHandle) {
					this.clearInteractionHandle(this._interactionHandle);
				}
			},

			immediatelyResetRouteStack: function immediatelyResetRouteStack(nextRouteStack) {
				var _this3 = this;
				var destIndex = nextRouteStack.length - 1;
				this.setState({
					routeStack: nextRouteStack,
					sceneConfigStack: nextRouteStack.map(function (route) {
						return _this3.props.configureScene(route, nextRouteStack);
					}),

					presentedIndex: destIndex,
					activeGesture: null,
					transitionFromIndex: null,
					transitionQueue: [] }, function () {
					_this3._handleSpringUpdate();
					_this3._navBar && _this3._navBar.immediatelyRefresh();
					_this3._emitDidFocus(_this3.state.routeStack[_this3.state.presentedIndex]);
				});
			},

			_transitionTo: function _transitionTo(destIndex, velocity, jumpSpringTo, cb) {
				if (this.state.presentedIndex === destIndex) {
					cb && cb();
					return;
				}

				if (this.state.transitionFromIndex !== null) {

					this.state.transitionQueue.push({
						destIndex: destIndex,
						velocity: velocity,
						cb: cb });

					return;
				}

				this.state.transitionFromIndex = this.state.presentedIndex;
				this.state.presentedIndex = destIndex;
				this.state.transitionCb = cb;
				this._onAnimationStart();
				if (AnimationsDebugModule) {
					AnimationsDebugModule.startRecordingFps();
				}
				var sceneConfig = this.state.sceneConfigStack[this.state.transitionFromIndex] || this.state.sceneConfigStack[this.state.presentedIndex];
				invariant(sceneConfig, 'Cannot configure scene at index ' + this.state.transitionFromIndex);

				if (jumpSpringTo != null) {
					this.spring.setCurrentValue(jumpSpringTo);
				}
				this.spring.setOvershootClampingEnabled(true);
				this.spring.getSpringConfig().friction = sceneConfig.springFriction;
				this.spring.getSpringConfig().tension = sceneConfig.springTension;
				this.spring.setVelocity(velocity || sceneConfig.defaultTransitionVelocity);
				this.spring.setEndValue(1);
			},

			_handleSpringUpdate: function _handleSpringUpdate() {
				if (!this.isMounted()) {
					return;
				}

				if (this.state.transitionFromIndex != null) {
					this._transitionBetween(this.state.transitionFromIndex, this.state.presentedIndex, this.spring.getCurrentValue());
				} else if (this.state.activeGesture != null) {
					var presentedToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
					this._transitionBetween(this.state.presentedIndex, presentedToIndex, this.spring.getCurrentValue());
				}
			},

			_completeTransition: function _completeTransition() {
				if (!this.isMounted()) {
					return;
				}

				if (this.spring.getCurrentValue() !== 1 && this.spring.getCurrentValue() !== 0) {

					if (this.state.pendingGestureProgress) {
						this.state.pendingGestureProgress = null;
					}
					return;
				}
				this._onAnimationEnd();
				var presentedIndex = this.state.presentedIndex;
				var didFocusRoute = this._subRouteFocus[presentedIndex] || this.state.routeStack[presentedIndex];

				if (AnimationsDebugModule) {
					AnimationsDebugModule.stopRecordingFps(Date.now());
				}
				this.state.transitionFromIndex = null;
				this.spring.setCurrentValue(0).setAtRest();
				this._hideScenes();
				if (this.state.transitionCb) {
					this.state.transitionCb();
					this.state.transitionCb = null;
				}

				this._emitDidFocus(didFocusRoute);

				if (this._interactionHandle) {
					this.clearInteractionHandle(this._interactionHandle);
					this._interactionHandle = null;
				}
				if (this.state.pendingGestureProgress) {

					var gestureToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
					this._enableScene(gestureToIndex);
					this.spring.setEndValue(this.state.pendingGestureProgress);
					return;
				}
				if (this.state.transitionQueue.length) {
					var queuedTransition = this.state.transitionQueue.shift();
					this._enableScene(queuedTransition.destIndex);
					this._emitWillFocus(this.state.routeStack[queuedTransition.destIndex]);
					this._transitionTo(queuedTransition.destIndex, queuedTransition.velocity, null, queuedTransition.cb);
				}
			},

			_emitDidFocus: function _emitDidFocus(route) {
				this.navigationContext.emit('didfocus', { route: route });

				if (this.props.onDidFocus) {
					this.props.onDidFocus(route);
				}
			},

			_emitWillFocus: function _emitWillFocus(route) {
				this.navigationContext.emit('willfocus', { route: route });

				var navBar = this._navBar;
				if (navBar && navBar.handleWillFocus) {
					navBar.handleWillFocus(route);
				}
				if (this.props.onWillFocus) {
					this.props.onWillFocus(route);
				}
			},

			_hideScenes: function _hideScenes() {
				var gesturingToIndex = null;
				if (this.state.activeGesture) {
					gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
				}
				for (var i = 0; i < this.state.routeStack.length; i++) {
					if (i === this.state.presentedIndex || i === this.state.transitionFromIndex || i === gesturingToIndex) {
						continue;
					}
					this._disableScene(i);
				}
			},

			_disableScene: function _disableScene(sceneIndex) {
				this.refs['scene_' + sceneIndex] && this.refs['scene_' + sceneIndex].setNativeProps(SCENE_DISABLED_NATIVE_PROPS);
			},

			_enableScene: function _enableScene(sceneIndex) {

				var sceneStyle = flattenStyle([styles.baseScene, this.props.sceneStyle]);

				var enabledSceneNativeProps = {
					pointerEvents: 'auto',
					style: {
						top: sceneStyle.top,
						bottom: sceneStyle.bottom } };

				if (sceneIndex !== this.state.transitionFromIndex && sceneIndex !== this.state.presentedIndex) {

					enabledSceneNativeProps.style.opacity = 0;
				}
				this.refs['scene_' + sceneIndex] && this.refs['scene_' + sceneIndex].setNativeProps(enabledSceneNativeProps);
			},

			_onAnimationStart: function _onAnimationStart() {
				var fromIndex = this.state.presentedIndex;
				var toIndex = this.state.presentedIndex;
				if (this.state.transitionFromIndex != null) {
					fromIndex = this.state.transitionFromIndex;
				} else if (this.state.activeGesture) {
					toIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
				}
				this._setRenderSceneToHardwareTextureAndroid(fromIndex, true);
				this._setRenderSceneToHardwareTextureAndroid(toIndex, true);
				var navBar = this._navBar;
				if (navBar && navBar.onAnimationStart) {
					navBar.onAnimationStart(fromIndex, toIndex);
				}
			},

			_onAnimationEnd: function _onAnimationEnd() {
				var max = this.state.routeStack.length - 1;
				for (var index = 0; index <= max; index++) {
					this._setRenderSceneToHardwareTextureAndroid(index, false);
				}

				var navBar = this._navBar;
				if (navBar && navBar.onAnimationEnd) {
					navBar.onAnimationEnd();
				}
			},

			_setRenderSceneToHardwareTextureAndroid: function _setRenderSceneToHardwareTextureAndroid(sceneIndex, shouldRenderToHardwareTexture) {
				var viewAtIndex = this.refs['scene_' + sceneIndex];
				if (viewAtIndex === null || viewAtIndex === undefined) {
					return;
				}
				viewAtIndex.setNativeProps({ renderToHardwareTextureAndroid: shouldRenderToHardwareTexture });
			},

			_handleTouchStart: function _handleTouchStart() {
				this._eligibleGestures = GESTURE_ACTIONS;
			},

			_handleMoveShouldSetPanResponder: function _handleMoveShouldSetPanResponder(e, gestureState) {
				var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
				if (!sceneConfig) {
					return false;
				}
				this._expectingGestureGrant = this._matchGestureAction(this._eligibleGestures, sceneConfig.gestures, gestureState);
				return !!this._expectingGestureGrant;
			},

			_doesGestureOverswipe: function _doesGestureOverswipe(gestureName) {
				var wouldOverswipeBack = this.state.presentedIndex <= 0 && (gestureName === 'pop' || gestureName === 'jumpBack');
				var wouldOverswipeForward = this.state.presentedIndex >= this.state.routeStack.length - 1 && gestureName === 'jumpForward';
				return wouldOverswipeForward || wouldOverswipeBack;
			},

			_deltaForGestureAction: function _deltaForGestureAction(gestureAction) {
				switch (gestureAction) {
					case 'pop':
					case 'jumpBack':
						return -1;
					case 'jumpForward':
						return 1;
					default:
						invariant(false, 'Unsupported gesture action ' + gestureAction);
						return;}
			},

			_handlePanResponderRelease: function _handlePanResponderRelease(e, gestureState) {
				var _this4 = this;
				var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
				var releaseGestureAction = this.state.activeGesture;
				if (!releaseGestureAction) {

					return;
				}
				var releaseGesture = sceneConfig.gestures[releaseGestureAction];
				var destIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
				if (this.spring.getCurrentValue() === 0) {

					this.spring.setCurrentValue(0).setAtRest();
					this._completeTransition();
					return;
				}
				var isTravelVertical = releaseGesture.direction === 'top-to-bottom' || releaseGesture.direction === 'bottom-to-top';
				var isTravelInverted = releaseGesture.direction === 'right-to-left' || releaseGesture.direction === 'bottom-to-top';
				var velocity, gestureDistance;
				if (isTravelVertical) {
					velocity = isTravelInverted ? -gestureState.vy : gestureState.vy;
					gestureDistance = isTravelInverted ? -gestureState.dy : gestureState.dy;
				} else {
					velocity = isTravelInverted ? -gestureState.vx : gestureState.vx;
					gestureDistance = isTravelInverted ? -gestureState.dx : gestureState.dx;
				}
				var transitionVelocity = clamp(-10, velocity, 10);
				if (Math.abs(velocity) < releaseGesture.notMoving) {

					var hasGesturedEnoughToComplete = gestureDistance > releaseGesture.fullDistance * releaseGesture.stillCompletionRatio;
					transitionVelocity = hasGesturedEnoughToComplete ? releaseGesture.snapVelocity : -releaseGesture.snapVelocity;
				}
				if (transitionVelocity < 0 || this._doesGestureOverswipe(releaseGestureAction)) {

					if (this.state.transitionFromIndex == null) {

						var transitionBackToPresentedIndex = this.state.presentedIndex;

						this.state.presentedIndex = destIndex;
						this._transitionTo(transitionBackToPresentedIndex, -transitionVelocity, 1 - this.spring.getCurrentValue());
					}
				} else {

					this._emitWillFocus(this.state.routeStack[destIndex]);
					this._transitionTo(destIndex, transitionVelocity, null, function () {
						if (releaseGestureAction === 'pop') {
							_this4._cleanScenesPastIndex(destIndex);
						}
					});
				}
				this._detachGesture();
			},

			_handlePanResponderTerminate: function _handlePanResponderTerminate(e, gestureState) {
				if (this.state.activeGesture == null) {
					return;
				}
				var destIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
				this._detachGesture();
				var transitionBackToPresentedIndex = this.state.presentedIndex;

				this.state.presentedIndex = destIndex;
				this._transitionTo(transitionBackToPresentedIndex, null, 1 - this.spring.getCurrentValue());
			},

			_attachGesture: function _attachGesture(gestureId) {
				this.state.activeGesture = gestureId;
				var gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
				this._enableScene(gesturingToIndex);
			},

			_detachGesture: function _detachGesture() {
				this.state.activeGesture = null;
				this.state.pendingGestureProgress = null;
				this._hideScenes();
			},

			_handlePanResponderMove: function _handlePanResponderMove(e, gestureState) {
				if (this._isMoveGestureAttached !== undefined) {
					invariant(this._expectingGestureGrant, 'Responder granted unexpectedly.');

					this._attachGesture(this._expectingGestureGrant);
					this._onAnimationStart();
					this._expectingGestureGrant = undefined;
				}

				var sceneConfig = this.state.sceneConfigStack[this.state.presentedIndex];
				if (this.state.activeGesture) {
					var gesture = sceneConfig.gestures[this.state.activeGesture];
					return this._moveAttachedGesture(gesture, gestureState);
				}
				var matchedGesture = this._matchGestureAction(GESTURE_ACTIONS, sceneConfig.gestures, gestureState);
				if (matchedGesture) {
					this._attachGesture(matchedGesture);
				}
			},

			_moveAttachedGesture: function _moveAttachedGesture(gesture, gestureState) {
				var isTravelVertical = gesture.direction === 'top-to-bottom' || gesture.direction === 'bottom-to-top';
				var isTravelInverted = gesture.direction === 'right-to-left' || gesture.direction === 'bottom-to-top';
				var distance = isTravelVertical ? gestureState.dy : gestureState.dx;
				distance = isTravelInverted ? -distance : distance;
				var gestureDetectMovement = gesture.gestureDetectMovement;
				var nextProgress = (distance - gestureDetectMovement) / (gesture.fullDistance - gestureDetectMovement);
				if (nextProgress < 0 && gesture.isDetachable) {
					var gesturingToIndex = this.state.presentedIndex + this._deltaForGestureAction(this.state.activeGesture);
					this._transitionBetween(this.state.presentedIndex, gesturingToIndex, 0);
					this._detachGesture();
					if (this.state.pendingGestureProgress != null) {
						this.spring.setCurrentValue(0);
					}
					return;
				}
				if (this._doesGestureOverswipe(this.state.activeGesture)) {
					var frictionConstant = gesture.overswipe.frictionConstant;
					var frictionByDistance = gesture.overswipe.frictionByDistance;
					var frictionRatio = 1 / (frictionConstant + Math.abs(nextProgress) * frictionByDistance);
					nextProgress *= frictionRatio;
				}
				nextProgress = clamp(0, nextProgress, 1);
				if (this.state.transitionFromIndex != null) {
					this.state.pendingGestureProgress = nextProgress;
				} else if (this.state.pendingGestureProgress) {
					this.spring.setEndValue(nextProgress);
				} else {
					this.spring.setCurrentValue(nextProgress);
				}
			},

			_matchGestureAction: function _matchGestureAction(eligibleGestures, gestures, gestureState) {
				var _this5 = this;
				if (!gestures || !eligibleGestures || !eligibleGestures.some) {
					return null;
				}
				var matchedGesture = null;
				eligibleGestures.some(function (gestureName, gestureIndex) {
					var gesture = gestures[gestureName];
					if (!gesture) {
						return;
					}
					if (gesture.overswipe == null && _this5._doesGestureOverswipe(gestureName)) {

						return false;
					}
					var isTravelVertical = gesture.direction === 'top-to-bottom' || gesture.direction === 'bottom-to-top';
					var isTravelInverted = gesture.direction === 'right-to-left' || gesture.direction === 'bottom-to-top';
					var startedLoc = isTravelVertical ? gestureState.y0 : gestureState.x0;
					var currentLoc = isTravelVertical ? gestureState.moveY : gestureState.moveX;
					var travelDist = isTravelVertical ? gestureState.dy : gestureState.dx;
					var oppositeAxisTravelDist = isTravelVertical ? gestureState.dx : gestureState.dy;
					var edgeHitWidth = gesture.edgeHitWidth;
					if (isTravelInverted) {
						startedLoc = -startedLoc;
						currentLoc = -currentLoc;
						travelDist = -travelDist;
						oppositeAxisTravelDist = -oppositeAxisTravelDist;
						edgeHitWidth = isTravelVertical ? -(SCREEN_HEIGHT - edgeHitWidth) : -(SCREEN_WIDTH - edgeHitWidth);
					}
					if (startedLoc === 0) {
						startedLoc = currentLoc;
					}
					var moveStartedInRegion = gesture.edgeHitWidth == null || startedLoc < edgeHitWidth;
					if (!moveStartedInRegion) {
						return false;
					}
					var moveTravelledFarEnough = travelDist >= gesture.gestureDetectMovement;
					if (!moveTravelledFarEnough) {
						return false;
					}
					var directionIsCorrect = Math.abs(travelDist) > Math.abs(oppositeAxisTravelDist) * gesture.directionRatio;
					if (directionIsCorrect) {
						matchedGesture = gestureName;
						return true;
					} else {
						_this5._eligibleGestures = _this5._eligibleGestures.slice().splice(gestureIndex, 1);
					}
				});
				return matchedGesture || null;
			},

			_transitionSceneStyle: function _transitionSceneStyle(fromIndex, toIndex, progress, index) {
				var viewAtIndex = this.refs['scene_' + index];
				if (viewAtIndex === null || viewAtIndex === undefined) {
					return;
				}

				var sceneConfigIndex = fromIndex < toIndex ? toIndex : fromIndex;
				var sceneConfig = this.state.sceneConfigStack[sceneConfigIndex];

				if (!sceneConfig) {
					sceneConfig = this.state.sceneConfigStack[sceneConfigIndex - 1];
				}
				var styleToUse = {};
				var useFn = index < fromIndex || index < toIndex ? sceneConfig.animationInterpolators.out : sceneConfig.animationInterpolators.into;
				var directionAdjustedProgress = fromIndex < toIndex ? progress : 1 - progress;
				var didChange = useFn(styleToUse, directionAdjustedProgress);
				if (didChange) {
					viewAtIndex.setNativeProps({ style: styleToUse });
				}
			},

			_transitionBetween: function _transitionBetween(fromIndex, toIndex, progress) {
				this._transitionSceneStyle(fromIndex, toIndex, progress, fromIndex);
				this._transitionSceneStyle(fromIndex, toIndex, progress, toIndex);
				var navBar = this._navBar;
				if (navBar && navBar.updateProgress && toIndex >= 0 && fromIndex >= 0) {
					navBar.updateProgress(progress, fromIndex, toIndex);
				}
			},

			_handleResponderTerminationRequest: function _handleResponderTerminationRequest() {
				return false;
			},

			_getDestIndexWithinBounds: function _getDestIndexWithinBounds(n) {
				var currentIndex = this.state.presentedIndex;
				var destIndex = currentIndex + n;
				invariant(destIndex >= 0, 'Cannot jump before the first route.');

				var maxIndex = this.state.routeStack.length - 1;
				invariant(maxIndex >= destIndex, 'Cannot jump past the last route.');

				return destIndex;
			},

			_jumpN: function _jumpN(n) {
				var destIndex = this._getDestIndexWithinBounds(n);
				this._enableScene(destIndex);
				this._emitWillFocus(this.state.routeStack[destIndex]);
				this._transitionTo(destIndex);
			},

			jumpTo: function jumpTo(route) {
				var destIndex = this.state.routeStack.indexOf(route);
				invariant(destIndex !== -1, 'Cannot jump to route that is not in the route stack');

				this._jumpN(destIndex - this.state.presentedIndex);
			},

			jumpForward: function jumpForward() {
				this._jumpN(1);
			},

			jumpBack: function jumpBack() {
				this._jumpN(-1);
			},

			push: function push(route) {
				var _this6 = this;
				invariant(!!route, 'Must supply route to push');
				var activeLength = this.state.presentedIndex + 1;
				var activeStack = this.state.routeStack.slice(0, activeLength);
				var activeAnimationConfigStack = this.state.sceneConfigStack.slice(0, activeLength);
				var nextStack = activeStack.concat([route]);
				var destIndex = nextStack.length - 1;
				var nextSceneConfig = this.props.configureScene(route, nextStack);
				var nextAnimationConfigStack = activeAnimationConfigStack.concat([nextSceneConfig]);
				this._emitWillFocus(nextStack[destIndex]);
				this.setState({
					routeStack: nextStack,
					sceneConfigStack: nextAnimationConfigStack }, function () {
					_this6._enableScene(destIndex);
					_this6._transitionTo(destIndex, nextSceneConfig.defaultTransitionVelocity);
				});
			},

			popN: function popN(n) {
				var _this7 = this;
				invariant(typeof n === 'number', 'Must supply a number to popN');
				n = parseInt(n, 10);
				if (n <= 0 || this.state.presentedIndex - n < 0) {
					return;
				}
				var popIndex = this.state.presentedIndex - n;
				var presentedRoute = this.state.routeStack[this.state.presentedIndex];
				var popSceneConfig = this.props.configureScene(presentedRoute);
				this._enableScene(popIndex);
				this._emitWillFocus(this.state.routeStack[popIndex]);
				this._transitionTo(popIndex, popSceneConfig.defaultTransitionVelocity, null, function () {
					_this7._cleanScenesPastIndex(popIndex);
				});
			},

			pop: function pop() {
				if (this.state.transitionQueue.length) {

					return;
				}

				this.popN(1);
			},

			replaceAtIndex: function replaceAtIndex(route, index, cb) {
				var _this8 = this;
				invariant(!!route, 'Must supply route to replace');
				if (index < 0) {
					index += this.state.routeStack.length;
				}

				if (this.state.routeStack.length <= index) {
					return;
				}

				var nextRouteStack = this.state.routeStack.slice();
				var nextAnimationModeStack = this.state.sceneConfigStack.slice();
				nextRouteStack[index] = route;
				nextAnimationModeStack[index] = this.props.configureScene(route, nextRouteStack);

				if (index === this.state.presentedIndex) {
					this._emitWillFocus(route);
				}
				this.setState({
					routeStack: nextRouteStack,
					sceneConfigStack: nextAnimationModeStack }, function () {
					if (index === _this8.state.presentedIndex) {
						_this8._emitDidFocus(route);
					}
					cb && cb();
				});
			},

			replace: function replace(route) {
				this.replaceAtIndex(route, this.state.presentedIndex);
			},

			replacePrevious: function replacePrevious(route) {
				this.replaceAtIndex(route, this.state.presentedIndex - 1);
			},

			popToTop: function popToTop() {
				this.popToRoute(this.state.routeStack[0]);
			},

			popToRoute: function popToRoute(route) {
				var indexOfRoute = this.state.routeStack.indexOf(route);
				invariant(indexOfRoute !== -1, 'Calling popToRoute for a route that doesn\'t exist!');

				var numToPop = this.state.presentedIndex - indexOfRoute;
				this.popN(numToPop);
			},

			replacePreviousAndPop: function replacePreviousAndPop(route) {
				if (this.state.routeStack.length < 2) {
					return;
				}
				this.replacePrevious(route);
				this.pop();
			},

			resetTo: function resetTo(route) {
				var _this9 = this;
				invariant(!!route, 'Must supply route to push');
				this.replaceAtIndex(route, 0, function () {

					_this9.popN(_this9.state.presentedIndex);
				});
			},

			getCurrentRoutes: function getCurrentRoutes() {

				return this.state.routeStack.slice();
			},

			_cleanScenesPastIndex: function _cleanScenesPastIndex(index) {
				var newStackLength = index + 1;

				if (newStackLength < this.state.routeStack.length) {
					this.setState({
						sceneConfigStack: this.state.sceneConfigStack.slice(0, newStackLength),
						routeStack: this.state.routeStack.slice(0, newStackLength) });
				}
			},

			_renderScene: function _renderScene(route, i) {
				var _this10 = this;
				var disabledSceneStyle = null;
				var disabledScenePointerEvents = 'auto';
				if (i !== this.state.presentedIndex) {
					disabledSceneStyle = styles.disabledScene;
					disabledScenePointerEvents = 'none';
				}
				return React.createElement(View, {
					key: 'scene_' + getRouteID(route),
					ref: 'scene_' + i,
					onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture() {
						return _this10.state.transitionFromIndex != null || _this10.state.transitionFromIndex != null;
					},
					pointerEvents: disabledScenePointerEvents,
					style: [styles.baseScene, this.props.sceneStyle, disabledSceneStyle] }, this.props.renderScene(route, this));
			},

			_renderNavigationBar: function _renderNavigationBar() {
				var _this11 = this;var navigationBar = this.props.navigationBar;
				if (!navigationBar) {
					return null;
				}
				return React.cloneElement(navigationBar, {
					ref: function ref(navBar) {
						_this11._navBar = navBar;
						if (navigationBar && typeof navigationBar.ref === 'function') {
							navigationBar.ref(navBar);
						}
					},
					navigator: this._navigationBarNavigator,
					navState: this.state });
			},

			render: function render() {
				var _this12 = this;
				var newRenderedSceneMap = new Map();
				var scenes = this.state.routeStack.map(function (route, index) {
					var renderedScene;
					if (_this12._renderedSceneMap.has(route) && index !== _this12.state.presentedIndex) {
						renderedScene = _this12._renderedSceneMap.get(route);
					} else {
						renderedScene = _this12._renderScene(route, index);
					}
					newRenderedSceneMap.set(route, renderedScene);
					return renderedScene;
				});
				this._renderedSceneMap = newRenderedSceneMap;
				return React.createElement(View, { style: [styles.container, this.props.style] }, React.createElement(View, babelHelpers.extends({
					style: styles.transitioner }, this.panGesture.panHandlers, {
					onTouchStart: this._handleTouchStart,
					onResponderTerminationRequest: this._handleResponderTerminationRequest }), scenes), this._renderNavigationBar());
			},

			_getNavigationContext: function _getNavigationContext() {
				if (!this._navigationContext) {
					this._navigationContext = new NavigationContext();
				}
				return this._navigationContext;
			} });

		module.exports = Navigator;
	}, // Libraries/Interaction/InteractionMixin.js
	function (__inner_require__, exports, module) {
		var InteractionManager = __inner_require__(124 /*Libraries/Interaction/InteractionManager.js*/);

		var InteractionMixin = {
			componentWillUnmount: function componentWillUnmount() {
				while (this._interactionMixinHandles.length) {
					InteractionManager.clearInteractionHandle(this._interactionMixinHandles.pop());
				}
			},

			_interactionMixinHandles: [],

			createInteractionHandle: function createInteractionHandle() {
				var handle = InteractionManager.createInteractionHandle();
				this._interactionMixinHandles.push(handle);
				return handle;
			},

			clearInteractionHandle: function clearInteractionHandle(clearHandle) {
				InteractionManager.clearInteractionHandle(clearHandle);
				this._interactionMixinHandles = this._interactionMixinHandles.filter(function (handle) {
					return handle !== clearHandle;
				});
			},

			runAfterInteractions: function runAfterInteractions(callback) {
				InteractionManager.runAfterInteractions(callback);
			} };

		module.exports = InteractionMixin;
	}, // Libraries/Interaction/InteractionManager.js
	function (__inner_require__, exports, module) {
		var BatchedBridge = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridge.js');
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var Set = require('react-native@0.33/Libraries/vendor/core/Set.js');
		var TaskQueue = __inner_require__(125 /*Libraries/Interaction/TaskQueue.js*/);

		var infoLog = __inner_require__(126 /*Libraries/Utilities/infoLog.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');

		var _emitter = new EventEmitter();

		var DEBUG_DELAY = 0;
		var DEBUG = false;

		var InteractionManager = {
			Events: keyMirror({
				interactionStart: true,
				interactionComplete: true }),

			runAfterInteractions: function runAfterInteractions(task) {
				var tasks = [];
				var promise = new Promise(function (resolve) {
					_scheduleUpdate();
					if (task) {
						tasks.push(task);
					}
					tasks.push({ run: resolve, name: 'resolve ' + (task && task.name || '?') });
					_taskQueue.enqueueTasks(tasks);
				});
				return {
					then: promise.then.bind(promise),
					done: promise.done.bind(promise),
					cancel: function cancel() {
						_taskQueue.cancelTasks(tasks);
					} };
			},

			createInteractionHandle: function createInteractionHandle() {
				DEBUG && infoLog('create interaction handle');
				_scheduleUpdate();
				var handle = ++_inc;
				_addInteractionSet.add(handle);
				return handle;
			},

			clearInteractionHandle: function clearInteractionHandle(handle) {
				DEBUG && infoLog('clear interaction handle');
				invariant(!!handle, 'Must provide a handle to clear.');

				_scheduleUpdate();
				_addInteractionSet.delete(handle);
				_deleteInteractionSet.add(handle);
			},

			addListener: _emitter.addListener.bind(_emitter),

			setDeadline: function setDeadline(deadline) {
				_deadline = deadline;
			} };

		var _interactionSet = new Set();
		var _addInteractionSet = new Set();
		var _deleteInteractionSet = new Set();
		var _taskQueue = new TaskQueue({ onMoreTasks: _scheduleUpdate });
		var _nextUpdateHandle = 0;
		var _inc = 0;
		var _deadline = -1;

		function _scheduleUpdate() {
			if (!_nextUpdateHandle) {
				if (_deadline > 0) {
					_nextUpdateHandle = setTimeout(_processUpdate, 0 + DEBUG_DELAY);
				} else {
					_nextUpdateHandle = setImmediate(_processUpdate);
				}
			}
		}

		function _processUpdate() {
			_nextUpdateHandle = 0;

			var interactionCount = _interactionSet.size;
			_addInteractionSet.forEach(function (handle) {
				return _interactionSet.add(handle);
			});

			_deleteInteractionSet.forEach(function (handle) {
				return _interactionSet.delete(handle);
			});

			var nextInteractionCount = _interactionSet.size;

			if (interactionCount !== 0 && nextInteractionCount === 0) {

				_emitter.emit(InteractionManager.Events.interactionComplete);
			} else if (interactionCount === 0 && nextInteractionCount !== 0) {

				_emitter.emit(InteractionManager.Events.interactionStart);
			}

			if (nextInteractionCount === 0) {
				while (_taskQueue.hasTasksToProcess()) {
					_taskQueue.processNext();
					if (_deadline > 0 && BatchedBridge.getEventLoopRunningTime() >= _deadline) {

						_scheduleUpdate();
						break;
					}
				}
			}
			_addInteractionSet.clear();
			_deleteInteractionSet.clear();
		}

		module.exports = InteractionManager;
	}, // Libraries/Interaction/TaskQueue.js
	function (__inner_require__, exports, module) {
		var infoLog = __inner_require__(126 /*Libraries/Utilities/infoLog.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var DEBUG = false;var TaskQueue = function () {

			function TaskQueue(_ref) {
				var onMoreTasks = _ref.onMoreTasks;babelHelpers.classCallCheck(this, TaskQueue);
				this._onMoreTasks = onMoreTasks;
				this._queueStack = [{ tasks: [], popable: false }];
			}babelHelpers.createClass(TaskQueue, [{ key: 'enqueue', value: function enqueue(task) {
					this._getCurrentQueue().push(task);
				} }, { key: 'enqueueTasks', value: function enqueueTasks(tasks) {
					var _this = this;
					tasks.forEach(function (task) {
						return _this.enqueue(task);
					});
				} }, { key: 'cancelTasks', value: function cancelTasks(tasksToCancel) {

					this._queueStack = this._queueStack.map(function (queue) {
						return babelHelpers.extends({}, queue, {
							tasks: queue.tasks.filter(function (task) {
								return tasksToCancel.indexOf(task) === -1;
							}) });
					}).filter(function (queue, idx) {
						return queue.tasks.length > 0 || idx === 0;
					});
				} }, { key: 'hasTasksToProcess', value: function hasTasksToProcess() {
					return this._getCurrentQueue().length > 0;
				} }, { key: 'processNext', value: function processNext() {
					var queue = this._getCurrentQueue();
					if (queue.length) {
						var task = queue.shift();
						try {
							if (task.gen) {
								DEBUG && infoLog('genPromise for task ' + task.name);
								this._genPromise(task);
							} else if (task.run) {
								DEBUG && infoLog('run task ' + task.name);
								task.run();
							} else {
								invariant(typeof task === 'function', 'Expected Function, SimpleTask, or PromiseTask, but got:\n' + JSON.stringify(task, null, 2));

								DEBUG && infoLog('run anonymous task');
								task();
							}
						} catch (e) {
							e.message = 'TaskQueue: Error with task ' + (task.name || '') + ': ' + e.message;
							throw e;
						}
					}
				} }, { key: '_getCurrentQueue', value: function _getCurrentQueue() {
					var stackIdx = this._queueStack.length - 1;
					var queue = this._queueStack[stackIdx];
					if (queue.popable && queue.tasks.length === 0 && this._queueStack.length > 1) {
						this._queueStack.pop();
						DEBUG && infoLog('popped queue: ', { stackIdx: stackIdx, queueStackSize: this._queueStack.length });
						return this._getCurrentQueue();
					} else {
						return queue.tasks;
					}
				} }, { key: '_genPromise', value: function _genPromise(task) {
					var _this2 = this;

					this._queueStack.push({ tasks: [], popable: false });
					var stackIdx = this._queueStack.length - 1;
					DEBUG && infoLog('push new queue: ', { stackIdx: stackIdx });
					DEBUG && infoLog('exec gen task ' + task.name);
					task.gen().then(function () {
						DEBUG && infoLog('onThen for gen task ' + task.name, { stackIdx: stackIdx, queueStackSize: _this2._queueStack.length });

						_this2._queueStack[stackIdx].popable = true;
						_this2.hasTasksToProcess() && _this2._onMoreTasks();
					}).catch(function (ex) {
						ex.message = 'TaskQueue: Error resolving Promise in task ' + task.name + ': ' + ex.message;
						throw ex;
					}).done();
				} }]);return TaskQueue;
		}();

		module.exports = TaskQueue;
	}, // Libraries/Utilities/infoLog.js
	function (__inner_require__, exports, module) {
		function infoLog() {
			var _console;
			return (_console = console).log.apply(_console, arguments);
		}

		module.exports = infoLog;
	}, // Libraries/CustomComponents/Navigator/Navigation/NavigationContext.js
	function (__inner_require__, exports, module) {
		var NavigationEvent = __inner_require__(128 /*Libraries/CustomComponents/Navigator/Navigation/NavigationEvent.js*/);
		var NavigationEventEmitter = __inner_require__(129 /*Libraries/CustomComponents/Navigator/Navigation/NavigationEventEmitter.js*/);
		var NavigationTreeNode = __inner_require__(130 /*Libraries/CustomComponents/Navigator/Navigation/NavigationTreeNode.js*/);

		var Set = require('react-native@0.33/Libraries/vendor/core/Set.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');var AT_TARGET = NavigationEvent.AT_TARGET,
		    BUBBLING_PHASE = NavigationEvent.BUBBLING_PHASE,
		    CAPTURING_PHASE = NavigationEvent.CAPTURING_PHASE;

		var LegacyEventTypes = new Set(['willfocus', 'didfocus']);var NavigationContext = function () {

			function NavigationContext() {
				babelHelpers.classCallCheck(this, NavigationContext);
				this._bubbleEventEmitter = new NavigationEventEmitter(this);
				this._captureEventEmitter = new NavigationEventEmitter(this);
				this._currentRoute = null;

				this.__node = new NavigationTreeNode(this);

				this._emitCounter = 0;
				this._emitQueue = [];

				this.addListener('willfocus', this._onFocus);
				this.addListener('didfocus', this._onFocus);
			}babelHelpers.createClass(NavigationContext, [{ key: 'appendChild', value: function appendChild(childContext) {
					this.__node.appendChild(childContext.__node);
				} }, { key: 'addListener', value: function addListener(eventType, listener, useCapture) {
					if (LegacyEventTypes.has(eventType)) {
						useCapture = false;
					}

					var emitter = useCapture ? this._captureEventEmitter : this._bubbleEventEmitter;

					if (emitter) {
						return emitter.addListener(eventType, listener, this);
					} else {
						return { remove: emptyFunction };
					}
				} }, { key: 'emit', value: function emit(eventType, data, didEmitCallback) {
					var _this = this;
					if (this._emitCounter > 0) {

						var args = Array.prototype.slice.call(arguments);
						this._emitQueue.push(args);
						return;
					}

					this._emitCounter++;

					if (LegacyEventTypes.has(eventType)) {

						this.__emit(eventType, data, null, {
							defaultPrevented: false,
							eventPhase: AT_TARGET,
							propagationStopped: true,
							target: this });
					} else {
						var targets = [this];
						var parentTarget = this.parent;
						while (parentTarget) {
							targets.unshift(parentTarget);
							parentTarget = parentTarget.parent;
						}

						var propagationStopped = false;
						var defaultPrevented = false;
						var callback = function callback(event) {
							propagationStopped = propagationStopped || event.isPropagationStopped();
							defaultPrevented = defaultPrevented || event.defaultPrevented;
						};

						targets.some(function (currentTarget) {
							if (propagationStopped) {
								return true;
							}

							var extraInfo = {
								defaultPrevented: defaultPrevented,
								eventPhase: CAPTURING_PHASE,
								propagationStopped: propagationStopped,
								target: _this };

							currentTarget.__emit(eventType, data, callback, extraInfo);
						}, this);

						targets.reverse().some(function (currentTarget) {
							if (propagationStopped) {
								return true;
							}
							var extraInfo = {
								defaultPrevented: defaultPrevented,
								eventPhase: BUBBLING_PHASE,
								propagationStopped: propagationStopped,
								target: _this };

							currentTarget.__emit(eventType, data, callback, extraInfo);
						}, this);
					}

					if (didEmitCallback) {
						var event = NavigationEvent.pool(eventType, this, data);
						propagationStopped && event.stopPropagation();
						defaultPrevented && event.preventDefault();
						didEmitCallback.call(this, event);
						event.dispose();
					}

					this._emitCounter--;
					while (this._emitQueue.length) {
						var args = this._emitQueue.shift();
						this.emit.apply(this, args);
					}
				} }, { key: 'dispose', value: function dispose() {

					this._bubbleEventEmitter && this._bubbleEventEmitter.removeAllListeners();
					this._captureEventEmitter && this._captureEventEmitter.removeAllListeners();
					this._bubbleEventEmitter = null;
					this._captureEventEmitter = null;
					this._currentRoute = null;
				} }, { key: '__emit', value: function __emit(eventType, data, didEmitCallback, extraInfo) {
					var emitter;
					switch (extraInfo.eventPhase) {
						case CAPTURING_PHASE:
							emitter = this._captureEventEmitter;
							break;

						case AT_TARGET:
							emitter = this._bubbleEventEmitter;
							break;

						case BUBBLING_PHASE:
							emitter = this._bubbleEventEmitter;
							break;

						default:
							invariant(false, 'invalid event phase %s', extraInfo.eventPhase);}

					if (extraInfo.target === this) {

						extraInfo.eventPhase = AT_TARGET;
					}

					if (emitter) {
						emitter.emit(eventType, data, didEmitCallback, extraInfo);
					}
				} }, { key: '_onFocus', value: function _onFocus(event) {
					invariant(event.data && event.data.hasOwnProperty('route'), 'event type "%s" should provide route', event.type);

					this._currentRoute = event.data.route;
				} }, { key: 'parent', get: function get() {
					var parent = this.__node.getParent();return parent ? parent.getValue() : null;
				} }, { key: 'top', get: function get() {
					var result = null;var parentNode = this.__node.getParent();while (parentNode) {
						result = parentNode.getValue();parentNode = parentNode.getParent();
					}return result;
				} }, { key: 'currentRoute', get: function get() {
					return this._currentRoute;
				} }]);return NavigationContext;
		}();

		module.exports = NavigationContext;
	}, // Libraries/CustomComponents/Navigator/Navigation/NavigationEvent.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');var NavigationEventPool = function () {

			function NavigationEventPool() {
				babelHelpers.classCallCheck(this, NavigationEventPool);
				this._list = [];
			}babelHelpers.createClass(NavigationEventPool, [{ key: 'get', value: function get(type, currentTarget, data) {
					var event = void 0;
					if (this._list.length > 0) {
						event = this._list.pop();
						event.constructor.call(event, type, currentTarget, data);
					} else {
						event = new NavigationEvent(type, currentTarget, data);
					}
					return event;
				} }, { key: 'put', value: function put(event) {
					this._list.push(event);
				} }]);return NavigationEventPool;
		}();

		var _navigationEventPool = new NavigationEventPool();var NavigationEvent = function () {
			babelHelpers.createClass(NavigationEvent, null, [{ key: 'pool', value: function pool(type, currentTarget, data) {
					return _navigationEventPool.get(type, currentTarget, data);
				} }]);

			function NavigationEvent(type, currentTarget, data) {
				babelHelpers.classCallCheck(this, NavigationEvent);
				this.target = currentTarget;
				this.eventPhase = NavigationEvent.NONE;

				this._type = type;
				this._currentTarget = currentTarget;
				this._data = data;
				this._defaultPrevented = false;
				this._disposed = false;
				this._propagationStopped = false;
			}babelHelpers.createClass(NavigationEvent, [{ key: 'preventDefault', value: function preventDefault() {
					this._defaultPrevented = true;
				} }, { key: 'stopPropagation', value: function stopPropagation() {
					this._propagationStopped = true;
				} }, { key: 'stop', value: function stop() {
					this.preventDefault();
					this.stopPropagation();
				} }, { key: 'isPropagationStopped', value: function isPropagationStopped() {
					return this._propagationStopped;
				} }, { key: 'dispose', value: function dispose() {
					invariant(!this._disposed, 'NavigationEvent is already disposed');
					this._disposed = true;

					this.target = null;
					this.eventPhase = NavigationEvent.NONE;
					this._type = '';
					this._currentTarget = null;
					this._data = null;
					this._defaultPrevented = false;

					_navigationEventPool.put(this);
				} }, { key: 'type', get: function get() {
					return this._type;
				} }, { key: 'currentTarget', get: function get() {
					return this._currentTarget;
				} }, { key: 'data', get: function get() {
					return this._data;
				} }, { key: 'defaultPrevented', get: function get() {
					return this._defaultPrevented;
				} }]);return NavigationEvent;
		}();

		NavigationEvent.NONE = 0;

		NavigationEvent.CAPTURING_PHASE = 1;

		NavigationEvent.AT_TARGET = 2;

		NavigationEvent.BUBBLING_PHASE = 3;

		module.exports = NavigationEvent;
	}, // Libraries/CustomComponents/Navigator/Navigation/NavigationEventEmitter.js
	function (__inner_require__, exports, module) {
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var NavigationEvent = __inner_require__(128 /*Libraries/CustomComponents/Navigator/Navigation/NavigationEvent.js*/);var NavigationEventEmitter = function (_EventEmitter) {
			babelHelpers.inherits(NavigationEventEmitter, _EventEmitter);

			function NavigationEventEmitter(target) {
				babelHelpers.classCallCheck(this, NavigationEventEmitter);var _this = babelHelpers.possibleConstructorReturn(this, (NavigationEventEmitter.__proto__ || Object.getPrototypeOf(NavigationEventEmitter)).call(this));

				_this._emitting = false;
				_this._emitQueue = [];
				_this._target = target;return _this;
			}babelHelpers.createClass(NavigationEventEmitter, [{ key: 'emit', value: function emit(eventType, data, didEmitCallback, extraInfo) {
					if (this._emitting) {

						var args = Array.prototype.slice.call(arguments);
						this._emitQueue.push(args);
						return;
					}

					this._emitting = true;

					var event = NavigationEvent.pool(eventType, this._target, data);

					if (extraInfo) {
						if (extraInfo.target) {
							event.target = extraInfo.target;
						}

						if (extraInfo.eventPhase) {
							event.eventPhase = extraInfo.eventPhase;
						}

						if (extraInfo.defaultPrevented) {
							event.preventDefault();
						}

						if (extraInfo.propagationStopped) {
							event.stopPropagation();
						}
					}

					babelHelpers.get(NavigationEventEmitter.prototype.__proto__ || Object.getPrototypeOf(NavigationEventEmitter.prototype), 'emit', this).call(this, String(eventType), event);

					if (typeof didEmitCallback === 'function') {
						didEmitCallback.call(this._target, event);
					}
					event.dispose();

					this._emitting = false;

					while (this._emitQueue.length) {
						var args = this._emitQueue.shift();
						this.emit.apply(this, args);
					}
				} }]);return NavigationEventEmitter;
		}(EventEmitter);

		module.exports = NavigationEventEmitter;
	}, // Libraries/CustomComponents/Navigator/Navigation/NavigationTreeNode.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var immutable = require('immutable@3/dist/immutable.js');var List = immutable.List;var NavigationTreeNode = function () {

			function NavigationTreeNode(value) {
				babelHelpers.classCallCheck(this, NavigationTreeNode);
				this.__parent = null;
				this._children = new List();
				this._value = value;
			}babelHelpers.createClass(NavigationTreeNode, [{ key: 'getValue', value: function getValue() {
					return this._value;
				} }, { key: 'getParent', value: function getParent() {
					return this.__parent;
				} }, { key: 'getChildrenCount', value: function getChildrenCount() {
					return this._children.size;
				} }, { key: 'getChildAt', value: function getChildAt(index) {
					return index > -1 && index < this._children.size ? this._children.get(index) : null;
				} }, { key: 'appendChild', value: function appendChild(child) {
					if (child.__parent) {
						child.__parent.removeChild(child);
					}
					child.__parent = this;
					this._children = this._children.push(child);
				} }, { key: 'removeChild', value: function removeChild(child) {
					var index = this._children.indexOf(child);

					invariant(index > -1, 'The node to be removed is not a child of this node.');

					child.__parent = null;

					this._children = this._children.splice(index, 1);
				} }, { key: 'indexOf', value: function indexOf(child) {
					return this._children.indexOf(child);
				} }, { key: 'forEach', value: function forEach(callback, context) {
					this._children.forEach(callback, context);
				} }, { key: 'map', value: function map(callback, context) {
					return this._children.map(callback, context).toJS();
				} }, { key: 'some', value: function some(callback, context) {
					return this._children.some(callback, context);
				} }]);return NavigationTreeNode;
		}();

		module.exports = NavigationTreeNode;
	}, // Libraries/CustomComponents/Navigator/NavigatorBreadcrumbNavigationBar.js
	function (__inner_require__, exports, module) {
		var NavigatorBreadcrumbNavigationBarStyles = __inner_require__(132 /*Libraries/CustomComponents/Navigator/NavigatorBreadcrumbNavigationBarStyles.ios.js*/);
		var NavigatorNavigationBarStylesAndroid = __inner_require__(135 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesAndroid.js*/);
		var NavigatorNavigationBarStylesIOS = __inner_require__(133 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesIOS.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var _require = require('immutable@3/dist/immutable.js'),
		    Map = _require.Map;

		var guid = require('react-native@0.33/Libraries/vendor/core/guid.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var Interpolators = NavigatorBreadcrumbNavigationBarStyles.Interpolators;
		var NavigatorNavigationBarStyles = Platform.OS === 'android' ? NavigatorNavigationBarStylesAndroid : NavigatorNavigationBarStylesIOS;
		var PropTypes = React.PropTypes;

		var CRUMB_PROPS = Interpolators.map(function () {
			return { style: {} };
		});
		var ICON_PROPS = Interpolators.map(function () {
			return { style: {} };
		});
		var SEPARATOR_PROPS = Interpolators.map(function () {
			return { style: {} };
		});
		var TITLE_PROPS = Interpolators.map(function () {
			return { style: {} };
		});
		var RIGHT_BUTTON_PROPS = Interpolators.map(function () {
			return { style: {} };
		});

		var navStatePresentedIndex = function navStatePresentedIndex(navState) {
			if (navState.presentedIndex !== undefined) {
				return navState.presentedIndex;
			}

			return navState.observedTopOfStack;
		};

		var initStyle = function initStyle(index, presentedIndex) {
			return index === presentedIndex ? NavigatorBreadcrumbNavigationBarStyles.Center[index] : index < presentedIndex ? NavigatorBreadcrumbNavigationBarStyles.Left[index] : NavigatorBreadcrumbNavigationBarStyles.Right[index];
		};var NavigatorBreadcrumbNavigationBar = function (_React$Component) {
			babelHelpers.inherits(NavigatorBreadcrumbNavigationBar, _React$Component);function NavigatorBreadcrumbNavigationBar() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, NavigatorBreadcrumbNavigationBar);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = NavigatorBreadcrumbNavigationBar.__proto__ || Object.getPrototypeOf(NavigatorBreadcrumbNavigationBar)).call.apply(_ref, [this].concat(args))), _this), _this._updateIndexProgress = function (progress, index, fromIndex, toIndex) {
					var amount = toIndex > fromIndex ? progress : 1 - progress;
					var oldDistToCenter = index - fromIndex;
					var newDistToCenter = index - toIndex;
					var interpolate;
					invariant(Interpolators[index], 'Cannot find breadcrumb interpolators for ' + index);

					if (oldDistToCenter > 0 && newDistToCenter === 0 || newDistToCenter > 0 && oldDistToCenter === 0) {
						interpolate = Interpolators[index].RightToCenter;
					} else if (oldDistToCenter < 0 && newDistToCenter === 0 || newDistToCenter < 0 && oldDistToCenter === 0) {
						interpolate = Interpolators[index].CenterToLeft;
					} else if (oldDistToCenter === newDistToCenter) {
						interpolate = Interpolators[index].RightToCenter;
					} else {
						interpolate = Interpolators[index].RightToLeft;
					}

					if (interpolate.Crumb(CRUMB_PROPS[index].style, amount)) {
						_this._setPropsIfExists('crumb_' + index, CRUMB_PROPS[index]);
					}
					if (interpolate.Icon(ICON_PROPS[index].style, amount)) {
						_this._setPropsIfExists('icon_' + index, ICON_PROPS[index]);
					}
					if (interpolate.Separator(SEPARATOR_PROPS[index].style, amount)) {
						_this._setPropsIfExists('separator_' + index, SEPARATOR_PROPS[index]);
					}
					if (interpolate.Title(TITLE_PROPS[index].style, amount)) {
						_this._setPropsIfExists('title_' + index, TITLE_PROPS[index]);
					}
					var right = _this.refs['right_' + index];

					var rightButtonStyle = RIGHT_BUTTON_PROPS[index].style;
					if (right && interpolate.RightItem(rightButtonStyle, amount)) {
						right.setNativeProps({
							style: rightButtonStyle,
							pointerEvents: rightButtonStyle.opacity === 0 ? 'none' : 'auto' });
					}
				}, _this.updateProgress = function (progress, fromIndex, toIndex) {
					var max = Math.max(fromIndex, toIndex);
					var min = Math.min(fromIndex, toIndex);
					for (var index = min; index <= max; index++) {
						_this._updateIndexProgress(progress, index, fromIndex, toIndex);
					}
				}, _this.onAnimationStart = function (fromIndex, toIndex) {
					var max = Math.max(fromIndex, toIndex);
					var min = Math.min(fromIndex, toIndex);
					for (var index = min; index <= max; index++) {
						_this._setRenderViewsToHardwareTextureAndroid(index, true);
					}
				}, _this.onAnimationEnd = function () {
					var max = _this.props.navState.routeStack.length - 1;
					for (var index = 0; index <= max; index++) {
						_this._setRenderViewsToHardwareTextureAndroid(index, false);
					}
				}, _this._setRenderViewsToHardwareTextureAndroid = function (index, renderToHardwareTexture) {
					var props = {
						renderToHardwareTextureAndroid: renderToHardwareTexture };

					_this._setPropsIfExists('icon_' + index, props);
					_this._setPropsIfExists('separator_' + index, props);
					_this._setPropsIfExists('title_' + index, props);
					_this._setPropsIfExists('right_' + index, props);
				}, _this.immediatelyRefresh = function () {
					_this._reset();
					_this.forceUpdate();
				}, _this._reset = function () {
					_this._key = guid();
					_this._descriptors = {
						crumb: new Map(),
						title: new Map(),
						right: new Map() };
				}, _this._getBreadcrumb = function (route, index) {
					if (_this._descriptors.crumb.has(route)) {
						return _this._descriptors.crumb.get(route);
					}

					var navBarRouteMapper = _this.props.routeMapper;
					var firstStyles = initStyle(index, navStatePresentedIndex(_this.props.navState));

					var breadcrumbDescriptor = React.createElement(View, {
						key: 'crumb_' + index,
						ref: 'crumb_' + index,
						style: firstStyles.Crumb }, React.createElement(View, { ref: 'icon_' + index, style: firstStyles.Icon }, navBarRouteMapper.iconForRoute(route, _this.props.navigator)), React.createElement(View, { ref: 'separator_' + index, style: firstStyles.Separator }, navBarRouteMapper.separatorForRoute(route, _this.props.navigator)));

					_this._descriptors.crumb = _this._descriptors.crumb.set(route, breadcrumbDescriptor);
					return breadcrumbDescriptor;
				}, _this._getTitle = function (route, index) {
					if (_this._descriptors.title.has(route)) {
						return _this._descriptors.title.get(route);
					}

					var titleContent = _this.props.routeMapper.titleContentForRoute(_this.props.navState.routeStack[index], _this.props.navigator);

					var firstStyles = initStyle(index, navStatePresentedIndex(_this.props.navState));

					var titleDescriptor = React.createElement(View, {
						key: 'title_' + index,
						ref: 'title_' + index,
						style: firstStyles.Title }, titleContent);

					_this._descriptors.title = _this._descriptors.title.set(route, titleDescriptor);
					return titleDescriptor;
				}, _this._getRightButton = function (route, index) {
					if (_this._descriptors.right.has(route)) {
						return _this._descriptors.right.get(route);
					}
					var rightContent = _this.props.routeMapper.rightContentForRoute(_this.props.navState.routeStack[index], _this.props.navigator);

					if (!rightContent) {
						_this._descriptors.right = _this._descriptors.right.set(route, null);
						return null;
					}
					var firstStyles = initStyle(index, navStatePresentedIndex(_this.props.navState));
					var rightButtonDescriptor = React.createElement(View, {
						key: 'right_' + index,
						ref: 'right_' + index,
						style: firstStyles.RightItem }, rightContent);

					_this._descriptors.right = _this._descriptors.right.set(route, rightButtonDescriptor);
					return rightButtonDescriptor;
				}, _this._setPropsIfExists = function (ref, props) {
					var ref = _this.refs[ref];
					ref && ref.setNativeProps(props);
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(NavigatorBreadcrumbNavigationBar, [{ key: 'componentWillMount', value: function componentWillMount() {
					this._reset();
				} }, { key: 'render', value: function render() {
					var navState = this.props.navState;var icons = navState && navState.routeStack.map(this._getBreadcrumb);var titles = navState.routeStack.map(this._getTitle);var buttons = navState.routeStack.map(this._getRightButton);return React.createElement(View, { key: this._key, style: [styles.breadCrumbContainer, this.props.style] }, titles, icons, buttons);
				} }]);return NavigatorBreadcrumbNavigationBar;
		}(React.Component);NavigatorBreadcrumbNavigationBar.propTypes = { navigator: PropTypes.shape({ push: PropTypes.func, pop: PropTypes.func, replace: PropTypes.func, popToRoute: PropTypes.func, popToTop: PropTypes.func }), routeMapper: PropTypes.shape({ rightContentForRoute: PropTypes.func, titleContentForRoute: PropTypes.func, iconForRoute: PropTypes.func }), navState: React.PropTypes.shape({ routeStack: React.PropTypes.arrayOf(React.PropTypes.object), presentedIndex: React.PropTypes.number }), style: View.propTypes.style };NavigatorBreadcrumbNavigationBar.Styles = NavigatorBreadcrumbNavigationBarStyles;

		var styles = StyleSheet.create({
			breadCrumbContainer: {
				overflow: 'hidden',
				position: 'absolute',
				height: NavigatorNavigationBarStyles.General.TotalNavHeight,
				top: 0,
				left: 0,
				right: 0 } });

		module.exports = NavigatorBreadcrumbNavigationBar;
	}, // Libraries/CustomComponents/Navigator/NavigatorBreadcrumbNavigationBarStyles.ios.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var NavigatorNavigationBarStylesIOS = __inner_require__(133 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesIOS.js*/);

		var buildStyleInterpolator = __inner_require__(134 /*Libraries/Utilities/buildStyleInterpolator.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		var SCREEN_WIDTH = Dimensions.get('window').width;
		var STATUS_BAR_HEIGHT = NavigatorNavigationBarStylesIOS.General.StatusBarHeight;
		var NAV_BAR_HEIGHT = NavigatorNavigationBarStylesIOS.General.NavBarHeight;

		var SPACING = 4;
		var ICON_WIDTH = 40;
		var SEPARATOR_WIDTH = 9;
		var CRUMB_WIDTH = ICON_WIDTH + SEPARATOR_WIDTH;

		var OPACITY_RATIO = 100;
		var ICON_INACTIVE_OPACITY = 0.6;
		var MAX_BREADCRUMBS = 10;

		var CRUMB_BASE = {
			position: 'absolute',
			flexDirection: 'row',
			top: STATUS_BAR_HEIGHT,
			width: CRUMB_WIDTH,
			height: NAV_BAR_HEIGHT,
			backgroundColor: 'transparent' };

		var ICON_BASE = {
			width: ICON_WIDTH,
			height: NAV_BAR_HEIGHT };

		var SEPARATOR_BASE = {
			width: SEPARATOR_WIDTH,
			height: NAV_BAR_HEIGHT };

		var TITLE_BASE = {
			position: 'absolute',
			top: STATUS_BAR_HEIGHT,
			height: NAV_BAR_HEIGHT,
			backgroundColor: 'transparent' };

		var FIRST_TITLE_BASE = merge(TITLE_BASE, {
			left: 0,
			right: 0,
			alignItems: 'center',
			height: NAV_BAR_HEIGHT });

		var RIGHT_BUTTON_BASE = {
			position: 'absolute',
			top: STATUS_BAR_HEIGHT,
			right: SPACING,
			overflow: 'hidden',
			opacity: 1,
			height: NAV_BAR_HEIGHT,
			backgroundColor: 'transparent' };

		var LEFT = [];
		var CENTER = [];
		var RIGHT = [];
		for (var i = 0; i < MAX_BREADCRUMBS; i++) {
			var crumbLeft = CRUMB_WIDTH * i + SPACING;
			LEFT[i] = {
				Crumb: merge(CRUMB_BASE, { left: crumbLeft }),
				Icon: merge(ICON_BASE, { opacity: ICON_INACTIVE_OPACITY }),
				Separator: merge(SEPARATOR_BASE, { opacity: 1 }),
				Title: merge(TITLE_BASE, { left: crumbLeft, opacity: 0 }),
				RightItem: merge(RIGHT_BUTTON_BASE, { opacity: 0 }) };

			CENTER[i] = {
				Crumb: merge(CRUMB_BASE, { left: crumbLeft }),
				Icon: merge(ICON_BASE, { opacity: 1 }),
				Separator: merge(SEPARATOR_BASE, { opacity: 0 }),
				Title: merge(TITLE_BASE, {
					left: crumbLeft + ICON_WIDTH,
					opacity: 1 }),

				RightItem: merge(RIGHT_BUTTON_BASE, { opacity: 1 }) };

			var crumbRight = SCREEN_WIDTH - 100;
			RIGHT[i] = {
				Crumb: merge(CRUMB_BASE, { left: crumbRight }),
				Icon: merge(ICON_BASE, { opacity: 0 }),
				Separator: merge(SEPARATOR_BASE, { opacity: 0 }),
				Title: merge(TITLE_BASE, {
					left: crumbRight + ICON_WIDTH,
					opacity: 0 }),

				RightItem: merge(RIGHT_BUTTON_BASE, { opacity: 0 }) };
		}

		CENTER[0] = {
			Crumb: merge(CRUMB_BASE, { left: SCREEN_WIDTH / 4 }),
			Icon: merge(ICON_BASE, { opacity: 0 }),
			Separator: merge(SEPARATOR_BASE, { opacity: 0 }),
			Title: merge(FIRST_TITLE_BASE, { opacity: 1 }),
			RightItem: CENTER[0].RightItem };

		LEFT[0].Title = merge(FIRST_TITLE_BASE, { left: -SCREEN_WIDTH / 4, opacity: 0 });
		RIGHT[0].Title = merge(FIRST_TITLE_BASE, { opacity: 0 });

		var buildIndexSceneInterpolator = function buildIndexSceneInterpolator(startStyles, endStyles) {
			return {
				Crumb: buildStyleInterpolator({
					left: {
						type: 'linear',
						from: startStyles.Crumb.left,
						to: endStyles.Crumb.left,
						min: 0,
						max: 1,
						extrapolate: true } }),

				Icon: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.Icon.opacity,
						to: endStyles.Icon.opacity,
						min: 0,
						max: 1 } }),

				Separator: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.Separator.opacity,
						to: endStyles.Separator.opacity,
						min: 0,
						max: 1 } }),

				Title: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.Title.opacity,
						to: endStyles.Title.opacity,
						min: 0,
						max: 1 },

					left: {
						type: 'linear',
						from: startStyles.Title.left,
						to: endStyles.Title.left,
						min: 0,
						max: 1,
						extrapolate: true } }),

				RightItem: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.RightItem.opacity,
						to: endStyles.RightItem.opacity,
						min: 0,
						max: 1,
						round: OPACITY_RATIO } }) };
		};

		var Interpolators = CENTER.map(function (_, ii) {
			return {

				RightToCenter: buildIndexSceneInterpolator(RIGHT[ii], CENTER[ii]),

				CenterToLeft: buildIndexSceneInterpolator(CENTER[ii], LEFT[ii]),

				RightToLeft: buildIndexSceneInterpolator(RIGHT[ii], LEFT[ii]) };
		});

		module.exports = {
			Interpolators: Interpolators,
			Left: LEFT,
			Center: CENTER,
			Right: RIGHT,
			IconWidth: ICON_WIDTH,
			IconHeight: NAV_BAR_HEIGHT,
			SeparatorWidth: SEPARATOR_WIDTH,
			SeparatorHeight: NAV_BAR_HEIGHT };
	}, // Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesIOS.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);

		var buildStyleInterpolator = __inner_require__(134 /*Libraries/Utilities/buildStyleInterpolator.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		var SCREEN_WIDTH = Dimensions.get('window').width;
		var NAV_BAR_HEIGHT = 44;
		var STATUS_BAR_HEIGHT = 20;
		var NAV_HEIGHT = NAV_BAR_HEIGHT + STATUS_BAR_HEIGHT;

		var BASE_STYLES = {
			Title: {
				position: 'absolute',
				top: STATUS_BAR_HEIGHT,
				left: 0,
				right: 0,
				alignItems: 'center',
				height: NAV_BAR_HEIGHT,
				backgroundColor: 'transparent' },

			LeftButton: {
				position: 'absolute',
				top: STATUS_BAR_HEIGHT,
				left: 0,
				overflow: 'hidden',
				opacity: 1,
				height: NAV_BAR_HEIGHT,
				backgroundColor: 'transparent' },

			RightButton: {
				position: 'absolute',
				top: STATUS_BAR_HEIGHT,
				right: 0,
				overflow: 'hidden',
				opacity: 1,
				alignItems: 'flex-end',
				height: NAV_BAR_HEIGHT,
				backgroundColor: 'transparent' } };

		var Stages = {
			Left: {
				Title: merge(BASE_STYLES.Title, { left: -SCREEN_WIDTH / 2, opacity: 0 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { left: 0, opacity: 0 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 0 }) },

			Center: {
				Title: merge(BASE_STYLES.Title, { left: 0, opacity: 1 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { left: 0, opacity: 1 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 1 }) },

			Right: {
				Title: merge(BASE_STYLES.Title, { left: SCREEN_WIDTH / 2, opacity: 0 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { left: 0, opacity: 0 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 0 }) } };

		var opacityRatio = 100;

		function buildSceneInterpolators(startStyles, endStyles) {
			return {
				Title: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.Title.opacity,
						to: endStyles.Title.opacity,
						min: 0,
						max: 1 },

					left: {
						type: 'linear',
						from: startStyles.Title.left,
						to: endStyles.Title.left,
						min: 0,
						max: 1,
						extrapolate: true } }),

				LeftButton: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.LeftButton.opacity,
						to: endStyles.LeftButton.opacity,
						min: 0,
						max: 1,
						round: opacityRatio },

					left: {
						type: 'linear',
						from: startStyles.LeftButton.left,
						to: endStyles.LeftButton.left,
						min: 0,
						max: 1 } }),

				RightButton: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.RightButton.opacity,
						to: endStyles.RightButton.opacity,
						min: 0,
						max: 1,
						round: opacityRatio },

					left: {
						type: 'linear',
						from: startStyles.RightButton.left,
						to: endStyles.RightButton.left,
						min: 0,
						max: 1,
						extrapolate: true } }) };
		}

		var Interpolators = {

			RightToCenter: buildSceneInterpolators(Stages.Right, Stages.Center),

			CenterToLeft: buildSceneInterpolators(Stages.Center, Stages.Left),

			RightToLeft: buildSceneInterpolators(Stages.Right, Stages.Left) };

		module.exports = {
			General: {
				NavBarHeight: NAV_BAR_HEIGHT,
				StatusBarHeight: STATUS_BAR_HEIGHT,
				TotalNavHeight: NAV_HEIGHT },

			Interpolators: Interpolators,
			Stages: Stages };
	}, // Libraries/Utilities/buildStyleInterpolator.js
	function (__inner_require__, exports, module) {
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var X_DIM = keyOf({ x: null });
		var Y_DIM = keyOf({ y: null });
		var Z_DIM = keyOf({ z: null });
		var W_DIM = keyOf({ w: null });

		var TRANSFORM_ROTATE_NAME = keyOf({ transformRotateRadians: null });

		var ShouldAllocateReusableOperationVars = {
			transformRotateRadians: true,
			transformScale: true,
			transformTranslate: true };

		var InitialOperationField = {
			transformRotateRadians: [0, 0, 0, 1],
			transformTranslate: [0, 0, 0],
			transformScale: [1, 1, 1] };

		var ARGUMENT_NAMES_RE = /([^\s,]+)/g;

		var inline = function inline(func, replaceWithArgs) {
			var fnStr = func.toString();
			var parameterNames = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES_RE) || [];
			var replaceRegexStr = parameterNames.map(function (paramName) {
				return '\\b' + paramName + '\\b';
			}).join('|');
			var replaceRegex = new RegExp(replaceRegexStr, 'g');
			var fnBody = fnStr.substring(fnStr.indexOf('{') + 1, fnStr.lastIndexOf('}'));
			var newFnBody = fnBody.replace(replaceRegex, function (parameterName) {
				var indexInParameterNames = parameterNames.indexOf(parameterName);
				var replacementName = replaceWithArgs[indexInParameterNames];
				return replacementName;
			});
			return newFnBody.split('\n');
		};

		var MatrixOps = {
			unroll: function unroll(matVar, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15) {
				m0 = matVar[0];
				m1 = matVar[1];
				m2 = matVar[2];
				m3 = matVar[3];
				m4 = matVar[4];
				m5 = matVar[5];
				m6 = matVar[6];
				m7 = matVar[7];
				m8 = matVar[8];
				m9 = matVar[9];
				m10 = matVar[10];
				m11 = matVar[11];
				m12 = matVar[12];
				m13 = matVar[13];
				m14 = matVar[14];
				m15 = matVar[15];
			},

			matrixDiffers: function matrixDiffers(retVar, matVar, m0, m1, m2, m3, m4, m5, m6, m7, m8, m9, m10, m11, m12, m13, m14, m15) {
				retVar = retVar || m0 !== matVar[0] || m1 !== matVar[1] || m2 !== matVar[2] || m3 !== matVar[3] || m4 !== matVar[4] || m5 !== matVar[5] || m6 !== matVar[6] || m7 !== matVar[7] || m8 !== matVar[8] || m9 !== matVar[9] || m10 !== matVar[10] || m11 !== matVar[11] || m12 !== matVar[12] || m13 !== matVar[13] || m14 !== matVar[14] || m15 !== matVar[15];
			},

			transformScale: function transformScale(matVar, opVar) {

				var x = opVar[0];
				var y = opVar[1];
				var z = opVar[2];
				matVar[0] = matVar[0] * x;
				matVar[1] = matVar[1] * x;
				matVar[2] = matVar[2] * x;
				matVar[3] = matVar[3] * x;
				matVar[4] = matVar[4] * y;
				matVar[5] = matVar[5] * y;
				matVar[6] = matVar[6] * y;
				matVar[7] = matVar[7] * y;
				matVar[8] = matVar[8] * z;
				matVar[9] = matVar[9] * z;
				matVar[10] = matVar[10] * z;
				matVar[11] = matVar[11] * z;
				matVar[12] = matVar[12];
				matVar[13] = matVar[13];
				matVar[14] = matVar[14];
				matVar[15] = matVar[15];
			},

			transformTranslate: function transformTranslate(matVar, opVar) {

				var x = opVar[0];
				var y = opVar[1];
				var z = opVar[2];
				matVar[12] = matVar[0] * x + matVar[4] * y + matVar[8] * z + matVar[12];
				matVar[13] = matVar[1] * x + matVar[5] * y + matVar[9] * z + matVar[13];
				matVar[14] = matVar[2] * x + matVar[6] * y + matVar[10] * z + matVar[14];
				matVar[15] = matVar[3] * x + matVar[7] * y + matVar[11] * z + matVar[15];
			},

			transformRotateRadians: function transformRotateRadians(matVar, q) {

				var xQuat = q[0],
				    yQuat = q[1],
				    zQuat = q[2],
				    wQuat = q[3];
				var x2Quat = xQuat + xQuat;
				var y2Quat = yQuat + yQuat;
				var z2Quat = zQuat + zQuat;
				var xxQuat = xQuat * x2Quat;
				var xyQuat = xQuat * y2Quat;
				var xzQuat = xQuat * z2Quat;
				var yyQuat = yQuat * y2Quat;
				var yzQuat = yQuat * z2Quat;
				var zzQuat = zQuat * z2Quat;
				var wxQuat = wQuat * x2Quat;
				var wyQuat = wQuat * y2Quat;
				var wzQuat = wQuat * z2Quat;

				var quatMat0 = 1 - (yyQuat + zzQuat);
				var quatMat1 = xyQuat + wzQuat;
				var quatMat2 = xzQuat - wyQuat;
				var quatMat4 = xyQuat - wzQuat;
				var quatMat5 = 1 - (xxQuat + zzQuat);
				var quatMat6 = yzQuat + wxQuat;
				var quatMat8 = xzQuat + wyQuat;
				var quatMat9 = yzQuat - wxQuat;
				var quatMat10 = 1 - (xxQuat + yyQuat);

				var a00 = matVar[0];
				var a01 = matVar[1];
				var a02 = matVar[2];
				var a03 = matVar[3];
				var a10 = matVar[4];
				var a11 = matVar[5];
				var a12 = matVar[6];
				var a13 = matVar[7];
				var a20 = matVar[8];
				var a21 = matVar[9];
				var a22 = matVar[10];
				var a23 = matVar[11];

				var b0 = quatMat0,
				    b1 = quatMat1,
				    b2 = quatMat2;
				matVar[0] = b0 * a00 + b1 * a10 + b2 * a20;
				matVar[1] = b0 * a01 + b1 * a11 + b2 * a21;
				matVar[2] = b0 * a02 + b1 * a12 + b2 * a22;
				matVar[3] = b0 * a03 + b1 * a13 + b2 * a23;
				b0 = quatMat4;b1 = quatMat5;b2 = quatMat6;
				matVar[4] = b0 * a00 + b1 * a10 + b2 * a20;
				matVar[5] = b0 * a01 + b1 * a11 + b2 * a21;
				matVar[6] = b0 * a02 + b1 * a12 + b2 * a22;
				matVar[7] = b0 * a03 + b1 * a13 + b2 * a23;
				b0 = quatMat8;b1 = quatMat9;b2 = quatMat10;
				matVar[8] = b0 * a00 + b1 * a10 + b2 * a20;
				matVar[9] = b0 * a01 + b1 * a11 + b2 * a21;
				matVar[10] = b0 * a02 + b1 * a12 + b2 * a22;
				matVar[11] = b0 * a03 + b1 * a13 + b2 * a23;
			} };

		var MatrixOpsInitial = {
			transformScale: function transformScale(matVar, opVar) {

				matVar[0] = opVar[0];
				matVar[1] = 0;
				matVar[2] = 0;
				matVar[3] = 0;
				matVar[4] = 0;
				matVar[5] = opVar[1];
				matVar[6] = 0;
				matVar[7] = 0;
				matVar[8] = 0;
				matVar[9] = 0;
				matVar[10] = opVar[2];
				matVar[11] = 0;
				matVar[12] = 0;
				matVar[13] = 0;
				matVar[14] = 0;
				matVar[15] = 1;
			},

			transformTranslate: function transformTranslate(matVar, opVar) {

				matVar[0] = 1;
				matVar[1] = 0;
				matVar[2] = 0;
				matVar[3] = 0;
				matVar[4] = 0;
				matVar[5] = 1;
				matVar[6] = 0;
				matVar[7] = 0;
				matVar[8] = 0;
				matVar[9] = 0;
				matVar[10] = 1;
				matVar[11] = 0;
				matVar[12] = opVar[0];
				matVar[13] = opVar[1];
				matVar[14] = opVar[2];
				matVar[15] = 1;
			},

			transformRotateRadians: function transformRotateRadians(matVar, q) {

				var xQuat = q[0],
				    yQuat = q[1],
				    zQuat = q[2],
				    wQuat = q[3];
				var x2Quat = xQuat + xQuat;
				var y2Quat = yQuat + yQuat;
				var z2Quat = zQuat + zQuat;
				var xxQuat = xQuat * x2Quat;
				var xyQuat = xQuat * y2Quat;
				var xzQuat = xQuat * z2Quat;
				var yyQuat = yQuat * y2Quat;
				var yzQuat = yQuat * z2Quat;
				var zzQuat = zQuat * z2Quat;
				var wxQuat = wQuat * x2Quat;
				var wyQuat = wQuat * y2Quat;
				var wzQuat = wQuat * z2Quat;

				var quatMat0 = 1 - (yyQuat + zzQuat);
				var quatMat1 = xyQuat + wzQuat;
				var quatMat2 = xzQuat - wyQuat;
				var quatMat4 = xyQuat - wzQuat;
				var quatMat5 = 1 - (xxQuat + zzQuat);
				var quatMat6 = yzQuat + wxQuat;
				var quatMat8 = xzQuat + wyQuat;
				var quatMat9 = yzQuat - wxQuat;
				var quatMat10 = 1 - (xxQuat + yyQuat);

				var b0 = quatMat0,
				    b1 = quatMat1,
				    b2 = quatMat2;
				matVar[0] = b0;
				matVar[1] = b1;
				matVar[2] = b2;
				matVar[3] = 0;
				b0 = quatMat4;b1 = quatMat5;b2 = quatMat6;
				matVar[4] = b0;
				matVar[5] = b1;
				matVar[6] = b2;
				matVar[7] = 0;
				b0 = quatMat8;b1 = quatMat9;b2 = quatMat10;
				matVar[8] = b0;
				matVar[9] = b1;
				matVar[10] = b2;
				matVar[11] = 0;
				matVar[12] = 0;
				matVar[13] = 0;
				matVar[14] = 0;
				matVar[15] = 1;
			} };

		var setNextValAndDetectChange = function setNextValAndDetectChange(name, tmpVarName) {
			return '  if (!didChange) {\n' + '    var prevVal = result.' + name + ';\n' + '    result.' + name + ' = ' + tmpVarName + ';\n' + '    didChange = didChange  || (' + tmpVarName + ' !== prevVal);\n' + '  } else {\n' + '    result.' + name + ' = ' + tmpVarName + ';\n' + '  }\n';
		};

		var computeNextValLinear = function computeNextValLinear(anim, from, to, tmpVarName) {
			var hasRoundRatio = 'round' in anim;
			var roundRatio = anim.round;
			var fn = '  ratio = (value - ' + anim.min + ') / ' + (anim.max - anim.min) + ';\n';
			if (!anim.extrapolate) {
				fn += '  ratio = ratio > 1 ? 1 : (ratio < 0 ? 0 : ratio);\n';
			}

			var roundOpen = hasRoundRatio ? 'Math.round(' + roundRatio + ' * ' : '';
			var roundClose = hasRoundRatio ? ') / ' + roundRatio : '';
			fn += '  ' + tmpVarName + ' = ' + roundOpen + '(' + from + ' * (1 - ratio) + ' + to + ' * ratio)' + roundClose + ';\n';
			return fn;
		};

		var computeNextValLinearScalar = function computeNextValLinearScalar(anim) {
			return computeNextValLinear(anim, anim.from, anim.to, 'nextScalarVal');
		};

		var computeNextValConstant = function computeNextValConstant(anim) {
			var constantExpression = JSON.stringify(anim.value);
			return '  nextScalarVal = ' + constantExpression + ';\n';
		};

		var computeNextValStep = function computeNextValStep(anim) {
			return '  nextScalarVal = value >= ' + (anim.threshold + ' ? ' + anim.to + ' : ' + anim.from) + ';\n';
		};

		var computeNextValIdentity = function computeNextValIdentity(anim) {
			return '  nextScalarVal = value;\n';
		};

		var operationVar = function operationVar(name) {
			return name + 'ReuseOp';
		};

		var createReusableOperationVars = function createReusableOperationVars(anims) {
			var ret = '';
			for (var name in anims) {
				if (ShouldAllocateReusableOperationVars[name]) {
					ret += 'var ' + operationVar(name) + ' = [];\n';
				}
			}
			return ret;
		};

		var newlines = function newlines(statements) {
			return '\n' + statements.join('\n') + '\n';
		};

		var computeNextMatrixOperationField = function computeNextMatrixOperationField(anim, name, dimension, index) {
			var fieldAccess = operationVar(name) + '[' + index + ']';
			if (anim.from[dimension] !== undefined && anim.to[dimension] !== undefined) {
				return '  ' + anim.from[dimension] !== anim.to[dimension] ? computeNextValLinear(anim, anim.from[dimension], anim.to[dimension], fieldAccess) : fieldAccess + ' = ' + anim.from[dimension] + ';';
			} else {
				return '  ' + fieldAccess + ' = ' + InitialOperationField[name][index] + ';';
			}
		};

		var unrolledVars = [];
		for (var varIndex = 0; varIndex < 16; varIndex++) {
			unrolledVars.push('m' + varIndex);
		}
		var setNextMatrixAndDetectChange = function setNextMatrixAndDetectChange(orderedMatrixOperations) {
			var fn = ['  var transform = result.transform !== undefined ? ' + 'result.transform : (result.transform = [{ matrix: [] }]);' + '  var transformMatrix = transform[0].matrix;'];

			fn.push.apply(fn, inline(MatrixOps.unroll, ['transformMatrix'].concat(unrolledVars)));

			for (var i = 0; i < orderedMatrixOperations.length; i++) {
				var opName = orderedMatrixOperations[i];
				if (i === 0) {
					fn.push.apply(fn, inline(MatrixOpsInitial[opName], ['transformMatrix', operationVar(opName)]));
				} else {
					fn.push.apply(fn, inline(MatrixOps[opName], ['transformMatrix', operationVar(opName)]));
				}
			}
			fn.push.apply(fn, inline(MatrixOps.matrixDiffers, ['didChange', 'transformMatrix'].concat(unrolledVars)));

			return fn;
		};

		var InterpolateMatrix = {
			transformTranslate: true,
			transformRotateRadians: true,
			transformScale: true };

		var createFunctionString = function createFunctionString(anims) {

			var orderedMatrixOperations = [];

			var fn = 'return (function() {\n';
			fn += createReusableOperationVars(anims);
			fn += 'return function(result, value) {\n';
			fn += '  var didChange = false;\n';
			fn += '  var nextScalarVal;\n';
			fn += '  var ratio;\n';

			for (var name in anims) {
				var anim = anims[name];
				if (anim.type === 'linear') {
					if (InterpolateMatrix[name]) {
						orderedMatrixOperations.push(name);
						var setOperations = [computeNextMatrixOperationField(anim, name, X_DIM, 0), computeNextMatrixOperationField(anim, name, Y_DIM, 1), computeNextMatrixOperationField(anim, name, Z_DIM, 2)];

						if (name === TRANSFORM_ROTATE_NAME) {
							setOperations.push(computeNextMatrixOperationField(anim, name, W_DIM, 3));
						}
						fn += newlines(setOperations);
					} else {
						fn += computeNextValLinearScalar(anim, 'nextScalarVal');
						fn += setNextValAndDetectChange(name, 'nextScalarVal');
					}
				} else if (anim.type === 'constant') {
					fn += computeNextValConstant(anim);
					fn += setNextValAndDetectChange(name, 'nextScalarVal');
				} else if (anim.type === 'step') {
					fn += computeNextValStep(anim);
					fn += setNextValAndDetectChange(name, 'nextScalarVal');
				} else if (anim.type === 'identity') {
					fn += computeNextValIdentity(anim);
					fn += setNextValAndDetectChange(name, 'nextScalarVal');
				}
			}
			if (orderedMatrixOperations.length) {
				fn += newlines(setNextMatrixAndDetectChange(orderedMatrixOperations));
			}
			fn += '  return didChange;\n';
			fn += '};\n';
			fn += '})()';
			return fn;
		};

		var buildStyleInterpolator = function buildStyleInterpolator(anims) {

			var interpolator = null;
			function lazyStyleInterpolator(result, value) {
				if (interpolator === null) {
					interpolator = Function(createFunctionString(anims))();
				}
				return interpolator(result, value);
			}
			return lazyStyleInterpolator;
		};

		module.exports = buildStyleInterpolator;
	}, // Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesAndroid.js
	function (__inner_require__, exports, module) {
		var buildStyleInterpolator = __inner_require__(134 /*Libraries/Utilities/buildStyleInterpolator.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		var NAV_BAR_HEIGHT = 56;
		var TITLE_LEFT = 72;
		var BUTTON_SIZE = 24;
		var TOUCH_TARGT_SIZE = 48;
		var BUTTON_HORIZONTAL_MARGIN = 16;

		var BUTTON_EFFECTIVE_MARGIN = BUTTON_HORIZONTAL_MARGIN - (TOUCH_TARGT_SIZE - BUTTON_SIZE) / 2;
		var NAV_ELEMENT_HEIGHT = NAV_BAR_HEIGHT;

		var BASE_STYLES = {
			Title: {
				position: 'absolute',
				bottom: 0,
				left: 0,
				right: 0,
				alignItems: 'flex-start',
				height: NAV_ELEMENT_HEIGHT,
				backgroundColor: 'transparent',
				marginLeft: TITLE_LEFT },

			LeftButton: {
				position: 'absolute',
				top: 0,
				left: BUTTON_EFFECTIVE_MARGIN,
				overflow: 'hidden',
				height: NAV_ELEMENT_HEIGHT,
				backgroundColor: 'transparent' },

			RightButton: {
				position: 'absolute',
				top: 0,
				right: BUTTON_EFFECTIVE_MARGIN,
				overflow: 'hidden',
				alignItems: 'flex-end',
				height: NAV_ELEMENT_HEIGHT,
				backgroundColor: 'transparent' } };

		var Stages = {
			Left: {
				Title: merge(BASE_STYLES.Title, { opacity: 0 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { opacity: 0 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 0 }) },

			Center: {
				Title: merge(BASE_STYLES.Title, { opacity: 1 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { opacity: 1 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 1 }) },

			Right: {
				Title: merge(BASE_STYLES.Title, { opacity: 0 }),
				LeftButton: merge(BASE_STYLES.LeftButton, { opacity: 0 }),
				RightButton: merge(BASE_STYLES.RightButton, { opacity: 0 }) } };

		var opacityRatio = 100;

		function buildSceneInterpolators(startStyles, endStyles) {
			return {
				Title: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.Title.opacity,
						to: endStyles.Title.opacity,
						min: 0,
						max: 1 },

					left: {
						type: 'linear',
						from: startStyles.Title.left,
						to: endStyles.Title.left,
						min: 0,
						max: 1,
						extrapolate: true } }),

				LeftButton: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.LeftButton.opacity,
						to: endStyles.LeftButton.opacity,
						min: 0,
						max: 1,
						round: opacityRatio },

					left: {
						type: 'linear',
						from: startStyles.LeftButton.left,
						to: endStyles.LeftButton.left,
						min: 0,
						max: 1 } }),

				RightButton: buildStyleInterpolator({
					opacity: {
						type: 'linear',
						from: startStyles.RightButton.opacity,
						to: endStyles.RightButton.opacity,
						min: 0,
						max: 1,
						round: opacityRatio },

					left: {
						type: 'linear',
						from: startStyles.RightButton.left,
						to: endStyles.RightButton.left,
						min: 0,
						max: 1,
						extrapolate: true } }) };
		}

		var Interpolators = {

			RightToCenter: buildSceneInterpolators(Stages.Right, Stages.Center),

			CenterToLeft: buildSceneInterpolators(Stages.Center, Stages.Left),

			RightToLeft: buildSceneInterpolators(Stages.Right, Stages.Left) };

		module.exports = {
			General: {
				NavBarHeight: NAV_BAR_HEIGHT,
				StatusBarHeight: 0,
				TotalNavHeight: NAV_BAR_HEIGHT },

			Interpolators: Interpolators,
			Stages: Stages };
	}, // Libraries/CustomComponents/Navigator/NavigatorNavigationBar.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var NavigatorNavigationBarStylesAndroid = __inner_require__(135 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesAndroid.js*/);
		var NavigatorNavigationBarStylesIOS = __inner_require__(133 /*Libraries/CustomComponents/Navigator/NavigatorNavigationBarStylesIOS.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var guid = require('react-native@0.33/Libraries/vendor/core/guid.js');var _require = require('immutable@3/dist/immutable.js'),
		    Map = _require.Map;

		var COMPONENT_NAMES = ['Title', 'LeftButton', 'RightButton'];

		var NavigatorNavigationBarStyles = Platform.OS === 'android' ? NavigatorNavigationBarStylesAndroid : NavigatorNavigationBarStylesIOS;

		var navStatePresentedIndex = function navStatePresentedIndex(navState) {
			if (navState.presentedIndex !== undefined) {
				return navState.presentedIndex;
			}

			return navState.observedTopOfStack;
		};var NavigatorNavigationBar = function (_React$Component) {
			babelHelpers.inherits(NavigatorNavigationBar, _React$Component);function NavigatorNavigationBar() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, NavigatorNavigationBar);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = NavigatorNavigationBar.__proto__ || Object.getPrototypeOf(NavigatorNavigationBar)).call.apply(_ref, [this].concat(args))), _this), _this.immediatelyRefresh = function () {
					_this._reset();
					_this.forceUpdate();
				}, _this._reset = function () {
					_this._key = guid();
					_this._reusableProps = {};
					_this._components = {};
					_this._descriptors = {};

					COMPONENT_NAMES.forEach(function (componentName) {
						_this._components[componentName] = new Map();
						_this._descriptors[componentName] = new Map();
					});
				}, _this._getReusableProps = function (componentName, index) {
					var propStack = _this._reusableProps[componentName];
					if (!propStack) {
						propStack = _this._reusableProps[componentName] = [];
					}
					var props = propStack[index];
					if (!props) {
						props = propStack[index] = { style: {} };
					}
					return props;
				}, _this._updateIndexProgress = function (progress, index, fromIndex, toIndex) {
					var amount = toIndex > fromIndex ? progress : 1 - progress;
					var oldDistToCenter = index - fromIndex;
					var newDistToCenter = index - toIndex;
					var interpolate;
					if (oldDistToCenter > 0 && newDistToCenter === 0 || newDistToCenter > 0 && oldDistToCenter === 0) {
						interpolate = _this.props.navigationStyles.Interpolators.RightToCenter;
					} else if (oldDistToCenter < 0 && newDistToCenter === 0 || newDistToCenter < 0 && oldDistToCenter === 0) {
						interpolate = _this.props.navigationStyles.Interpolators.CenterToLeft;
					} else if (oldDistToCenter === newDistToCenter) {
						interpolate = _this.props.navigationStyles.Interpolators.RightToCenter;
					} else {
						interpolate = _this.props.navigationStyles.Interpolators.RightToLeft;
					}

					COMPONENT_NAMES.forEach(function (componentName) {
						var component = this._components[componentName].get(this.props.navState.routeStack[index]);
						var props = this._getReusableProps(componentName, index);
						if (component && interpolate[componentName](props.style, amount)) {
							props.pointerEvents = props.style.opacity === 0 ? 'none' : 'box-none';
							component.setNativeProps(props);
						}
					}, _this);
				}, _this.updateProgress = function (progress, fromIndex, toIndex) {
					var max = Math.max(fromIndex, toIndex);
					var min = Math.min(fromIndex, toIndex);
					for (var index = min; index <= max; index++) {
						_this._updateIndexProgress(progress, index, fromIndex, toIndex);
					}
				}, _this._getComponent = function (componentName, route, index) {
					if (_this._descriptors[componentName].includes(route)) {
						return _this._descriptors[componentName].get(route);
					}

					var rendered = null;

					var content = _this.props.routeMapper[componentName](_this.props.navState.routeStack[index], _this.props.navigator, index, _this.props.navState);

					if (!content) {
						return null;
					}

					var componentIsActive = index === navStatePresentedIndex(_this.props.navState);
					var initialStage = componentIsActive ? _this.props.navigationStyles.Stages.Center : _this.props.navigationStyles.Stages.Left;
					rendered = React.createElement(View, {
						ref: function ref(_ref2) {
							_this._components[componentName] = _this._components[componentName].set(route, _ref2);
						},
						pointerEvents: componentIsActive ? 'box-none' : 'none',
						style: initialStage[componentName] }, content);

					_this._descriptors[componentName] = _this._descriptors[componentName].set(route, rendered);
					return rendered;
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(NavigatorNavigationBar, [{ key: 'componentWillMount', value: function componentWillMount() {
					this._reset();
				} }, { key: 'render', value: function render() {
					var _this2 = this;var navBarStyle = { height: this.props.navigationStyles.General.TotalNavHeight };var navState = this.props.navState;var components = navState.routeStack.map(function (route, index) {
						return COMPONENT_NAMES.map(function (componentName) {
							return _this2._getComponent(componentName, route, index);
						});
					});return React.createElement(View, { key: this._key, style: [styles.navBarContainer, navBarStyle, this.props.style] }, components);
				} }]);return NavigatorNavigationBar;
		}(React.Component);NavigatorNavigationBar.propTypes = { navigator: React.PropTypes.object, routeMapper: React.PropTypes.shape({ Title: React.PropTypes.func.isRequired, LeftButton: React.PropTypes.func.isRequired, RightButton: React.PropTypes.func.isRequired }).isRequired, navState: React.PropTypes.shape({ routeStack: React.PropTypes.arrayOf(React.PropTypes.object), presentedIndex: React.PropTypes.number }), navigationStyles: React.PropTypes.object, style: View.propTypes.style };NavigatorNavigationBar.Styles = NavigatorNavigationBarStyles;NavigatorNavigationBar.StylesAndroid = NavigatorNavigationBarStylesAndroid;NavigatorNavigationBar.StylesIOS = NavigatorNavigationBarStylesIOS;NavigatorNavigationBar.defaultProps = { navigationStyles: NavigatorNavigationBarStyles };

		var styles = StyleSheet.create({
			navBarContainer: {
				position: 'absolute',
				top: 0,
				left: 0,
				right: 0,
				backgroundColor: 'transparent' } });

		module.exports = NavigatorNavigationBar;
	}, // Libraries/CustomComponents/Navigator/NavigatorSceneConfigs.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var PixelRatio = __inner_require__(27 /*Libraries/Utilities/PixelRatio.js*/);
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);

		var buildStyleInterpolator = __inner_require__(134 /*Libraries/Utilities/buildStyleInterpolator.js*/);

		var IS_RTL = I18nManager.isRTL;

		var SCREEN_WIDTH = Dimensions.get('window').width;
		var SCREEN_HEIGHT = Dimensions.get('window').height;

		var ToTheLeftIOS = {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: -SCREEN_WIDTH * 0.3, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			opacity: {
				value: 1.0,
				type: 'constant' } };

		var ToTheRightIOS = babelHelpers.extends({}, ToTheLeftIOS, {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: SCREEN_WIDTH * 0.3, y: 0, z: 0 } } });

		var FadeToTheLeft = {

			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: -Math.round(Dimensions.get('window').width * 0.3), y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			transformScale: {
				from: { x: 1, y: 1, z: 1 },
				to: { x: 0.95, y: 0.95, z: 1 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true },

			opacity: {
				from: 1,
				to: 0.3,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: false,
				round: 100 },

			translateX: {
				from: 0,
				to: -Math.round(Dimensions.get('window').width * 0.3),
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			scaleX: {
				from: 1,
				to: 0.95,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true },

			scaleY: {
				from: 1,
				to: 0.95,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true } };

		var FadeToTheRight = babelHelpers.extends({}, FadeToTheLeft, {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: Math.round(SCREEN_WIDTH * 0.3), y: 0, z: 0 } },

			translateX: {
				from: 0,
				to: Math.round(SCREEN_WIDTH * 0.3) } });

		var FadeIn = {
			opacity: {
				from: 0,
				to: 1,
				min: 0.5,
				max: 1,
				type: 'linear',
				extrapolate: false,
				round: 100 } };

		var FadeOut = {
			opacity: {
				from: 1,
				to: 0,
				min: 0,
				max: 0.5,
				type: 'linear',
				extrapolate: false,
				round: 100 } };

		var ToTheLeft = {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: -Dimensions.get('window').width, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			opacity: {
				value: 1.0,
				type: 'constant' },

			translateX: {
				from: 0,
				to: -Dimensions.get('window').width,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } };

		var ToTheRight = {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: Dimensions.get('window').width, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			opacity: {
				value: 1.0,
				type: 'constant' },

			translateX: {
				from: 0,
				to: Dimensions.get('window').width,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } };

		var ToTheUp = {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: 0, y: -Dimensions.get('window').height, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			opacity: {
				value: 1.0,
				type: 'constant' },

			translateY: {
				from: 0,
				to: -Dimensions.get('window').height,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } };

		var ToTheDown = {
			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: 0, y: Dimensions.get('window').height, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			opacity: {
				value: 1.0,
				type: 'constant' },

			translateY: {
				from: 0,
				to: Dimensions.get('window').height,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } };

		var FromTheRight = {
			opacity: {
				value: 1.0,
				type: 'constant' },

			transformTranslate: {
				from: { x: Dimensions.get('window').width, y: 0, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateX: {
				from: Dimensions.get('window').width,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			scaleX: {
				value: 1,
				type: 'constant' },

			scaleY: {
				value: 1,
				type: 'constant' } };

		var FromTheLeft = babelHelpers.extends({}, FromTheRight, {
			transformTranslate: {
				from: { x: -SCREEN_WIDTH, y: 0, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateX: {
				from: -SCREEN_WIDTH,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } });

		var FromTheDown = babelHelpers.extends({}, FromTheRight, {
			transformTranslate: {
				from: { y: SCREEN_HEIGHT, x: 0, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateY: {
				from: SCREEN_HEIGHT,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } });

		var FromTheTop = babelHelpers.extends({}, FromTheRight, {
			transformTranslate: {
				from: { y: -SCREEN_HEIGHT, x: 0, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateY: {
				from: -SCREEN_HEIGHT,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } });

		var ToTheBack = {

			transformTranslate: {
				from: { x: 0, y: 0, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			transformScale: {
				from: { x: 1, y: 1, z: 1 },
				to: { x: 0.95, y: 0.95, z: 1 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true },

			opacity: {
				from: 1,
				to: 0.3,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: false,
				round: 100 },

			scaleX: {
				from: 1,
				to: 0.95,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true },

			scaleY: {
				from: 1,
				to: 0.95,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true } };

		var FromTheFront = {
			opacity: {
				value: 1.0,
				type: 'constant' },

			transformTranslate: {
				from: { x: 0, y: Dimensions.get('window').height, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateY: {
				from: Dimensions.get('window').height,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			scaleX: {
				value: 1,
				type: 'constant' },

			scaleY: {
				value: 1,
				type: 'constant' } };

		var ToTheBackAndroid = {
			opacity: {
				value: 1,
				type: 'constant' } };

		var FromTheFrontAndroid = {
			opacity: {
				from: 0,
				to: 1,
				min: 0.5,
				max: 1,
				type: 'linear',
				extrapolate: false,
				round: 100 },

			transformTranslate: {
				from: { x: 0, y: 100, z: 0 },
				to: { x: 0, y: 0, z: 0 },
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() },

			translateY: {
				from: 100,
				to: 0,
				min: 0,
				max: 1,
				type: 'linear',
				extrapolate: true,
				round: PixelRatio.get() } };

		var BaseOverswipeConfig = {
			frictionConstant: 1,
			frictionByDistance: 1.5 };

		var BaseLeftToRightGesture = {

			isDetachable: false,

			gestureDetectMovement: 2,

			notMoving: 0.3,

			directionRatio: 0.66,

			snapVelocity: 2,

			edgeHitWidth: 30,

			stillCompletionRatio: 3 / 5,

			fullDistance: SCREEN_WIDTH,

			direction: 'left-to-right' };

		var BaseRightToLeftGesture = babelHelpers.extends({}, BaseLeftToRightGesture, {
			direction: 'right-to-left' });

		var BaseDownUpGesture = babelHelpers.extends({}, BaseLeftToRightGesture, {
			fullDistance: SCREEN_HEIGHT,
			direction: 'down-to-up' });

		var BaseUpDownGesture = babelHelpers.extends({}, BaseLeftToRightGesture, {
			fullDistance: SCREEN_HEIGHT,
			direction: 'up-to-down' });

		var directionMapping = {
			ToTheStartIOS: ToTheLeftIOS,
			ToTheEndIOS: ToTheRightIOS,
			FadeToTheStart: FadeToTheLeft,
			FadeToTheEnd: FadeToTheRight,
			ToTheStart: ToTheLeft,
			ToTheEnd: ToTheRight,
			FromTheStart: FromTheLeft,
			FromTheEnd: FromTheRight,
			BaseStartToEndGesture: BaseLeftToRightGesture,
			BaseEndToStartGesture: BaseRightToLeftGesture };

		if (IS_RTL) {
			directionMapping = {
				ToTheStartIOS: ToTheRightIOS,
				ToTheEndIOS: ToTheLeftIOS,
				FadeToTheStart: FadeToTheRight,
				FadeToTheEnd: FadeToTheLeft,
				ToTheStart: ToTheRight,
				ToTheEnd: ToTheLeft,
				FromTheStart: FromTheRight,
				FromTheEnd: FromTheLeft,
				BaseStartToEndGesture: BaseRightToLeftGesture,
				BaseEndToStartGesture: BaseLeftToRightGesture };
		}

		var BaseConfig = {

			gestures: {
				pop: directionMapping.BaseStartToEndGesture },

			springFriction: 26,
			springTension: 200,

			defaultTransitionVelocity: 1.5,

			animationInterpolators: {
				into: buildStyleInterpolator(directionMapping.FromTheEnd),
				out: buildStyleInterpolator(directionMapping.FadeToTheStart) } };

		var NavigatorSceneConfigs = {
			PushFromRight: babelHelpers.extends({}, BaseConfig, {
				animationInterpolators: {
					into: buildStyleInterpolator(directionMapping.FromTheEnd),
					out: buildStyleInterpolator(directionMapping.ToTheStartIOS) } }),

			FloatFromRight: babelHelpers.extends({}, BaseConfig),

			FloatFromLeft: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					pop: directionMapping.BaseEndToStartGesture },

				animationInterpolators: {
					into: buildStyleInterpolator(directionMapping.FromTheStart),
					out: buildStyleInterpolator(directionMapping.FadeToTheEnd) } }),

			FloatFromBottom: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					pop: babelHelpers.extends({}, directionMapping.BaseStartToEndGesture, {
						edgeHitWidth: 150,
						direction: 'top-to-bottom',
						fullDistance: SCREEN_HEIGHT }) },

				animationInterpolators: {
					into: buildStyleInterpolator(FromTheFront),
					out: buildStyleInterpolator(ToTheBack) } }),

			FloatFromBottomAndroid: babelHelpers.extends({}, BaseConfig, {
				gestures: null,
				defaultTransitionVelocity: 3,
				springFriction: 20,
				animationInterpolators: {
					into: buildStyleInterpolator(FromTheFrontAndroid),
					out: buildStyleInterpolator(ToTheBackAndroid) } }),

			FadeAndroid: babelHelpers.extends({}, BaseConfig, {
				gestures: null,
				animationInterpolators: {
					into: buildStyleInterpolator(FadeIn),
					out: buildStyleInterpolator(FadeOut) } }),

			HorizontalSwipeJump: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					jumpBack: babelHelpers.extends({}, directionMapping.BaseStartToEndGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }),

					jumpForward: babelHelpers.extends({}, directionMapping.BaseEndToStartGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }) },

				animationInterpolators: {
					into: buildStyleInterpolator(directionMapping.FromTheEnd),
					out: buildStyleInterpolator(directionMapping.ToTheStart) } }),

			HorizontalSwipeJumpFromRight: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					jumpBack: babelHelpers.extends({}, directionMapping.BaseEndToStartGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }),

					jumpForward: babelHelpers.extends({}, directionMapping.BaseStartToEndGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }),

					pop: directionMapping.BaseEndToStartGesture },

				animationInterpolators: {
					into: buildStyleInterpolator(directionMapping.FromTheStart),
					out: buildStyleInterpolator(directionMapping.FadeToTheEnd) } }),

			VerticalUpSwipeJump: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					jumpBack: babelHelpers.extends({}, BaseDownUpGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }),

					jumpForward: babelHelpers.extends({}, BaseDownUpGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }) },

				animationInterpolators: {
					into: buildStyleInterpolator(FromTheDown),
					out: buildStyleInterpolator(ToTheUp) } }),

			VerticalDownSwipeJump: babelHelpers.extends({}, BaseConfig, {
				gestures: {
					jumpBack: babelHelpers.extends({}, BaseUpDownGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }),

					jumpForward: babelHelpers.extends({}, BaseUpDownGesture, {
						overswipe: BaseOverswipeConfig,
						edgeHitWidth: null,
						isDetachable: true }) },

				animationInterpolators: {
					into: buildStyleInterpolator(FromTheTop),
					out: buildStyleInterpolator(ToTheDown) } }) };

		module.exports = NavigatorSceneConfigs;
	}, // Libraries/Interaction/PanResponder.js
	function (__inner_require__, exports, module) {
		var InteractionManager = __inner_require__(124 /*Libraries/Interaction/InteractionManager.js*/);
		var TouchHistoryMath = __inner_require__(139 /*__react__/lib/TouchHistoryMath.js*/);

		var currentCentroidXOfTouchesChangedAfter = TouchHistoryMath.currentCentroidXOfTouchesChangedAfter;
		var currentCentroidYOfTouchesChangedAfter = TouchHistoryMath.currentCentroidYOfTouchesChangedAfter;
		var previousCentroidXOfTouchesChangedAfter = TouchHistoryMath.previousCentroidXOfTouchesChangedAfter;
		var previousCentroidYOfTouchesChangedAfter = TouchHistoryMath.previousCentroidYOfTouchesChangedAfter;
		var currentCentroidX = TouchHistoryMath.currentCentroidX;
		var currentCentroidY = TouchHistoryMath.currentCentroidY;

		var PanResponder = {

			_initializeGestureState: function _initializeGestureState(gestureState) {
				gestureState.moveX = 0;
				gestureState.moveY = 0;
				gestureState.x0 = 0;
				gestureState.y0 = 0;
				gestureState.dx = 0;
				gestureState.dy = 0;
				gestureState.vx = 0;
				gestureState.vy = 0;
				gestureState.numberActiveTouches = 0;

				gestureState._accountsForMovesUpTo = 0;
			},

			_updateGestureStateOnMove: function _updateGestureStateOnMove(gestureState, touchHistory) {
				gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
				gestureState.moveX = currentCentroidXOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
				gestureState.moveY = currentCentroidYOfTouchesChangedAfter(touchHistory, gestureState._accountsForMovesUpTo);
				var movedAfter = gestureState._accountsForMovesUpTo;
				var prevX = previousCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
				var x = currentCentroidXOfTouchesChangedAfter(touchHistory, movedAfter);
				var prevY = previousCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
				var y = currentCentroidYOfTouchesChangedAfter(touchHistory, movedAfter);
				var nextDX = gestureState.dx + (x - prevX);
				var nextDY = gestureState.dy + (y - prevY);

				var dt = touchHistory.mostRecentTimeStamp - gestureState._accountsForMovesUpTo;
				gestureState.vx = (nextDX - gestureState.dx) / dt;
				gestureState.vy = (nextDY - gestureState.dy) / dt;

				gestureState.dx = nextDX;
				gestureState.dy = nextDY;
				gestureState._accountsForMovesUpTo = touchHistory.mostRecentTimeStamp;
			},

			create: function create(config) {
				var interactionState = {
					handle: null };

				var gestureState = {

					stateID: Math.random() };

				PanResponder._initializeGestureState(gestureState);
				var panHandlers = {
					onStartShouldSetResponder: function onStartShouldSetResponder(e) {
						return config.onStartShouldSetPanResponder === undefined ? false : config.onStartShouldSetPanResponder(e, gestureState);
					},
					onMoveShouldSetResponder: function onMoveShouldSetResponder(e) {
						return config.onMoveShouldSetPanResponder === undefined ? false : config.onMoveShouldSetPanResponder(e, gestureState);
					},
					onStartShouldSetResponderCapture: function onStartShouldSetResponderCapture(e) {

						if (e.nativeEvent.touches.length === 1) {
							PanResponder._initializeGestureState(gestureState);
						}
						gestureState.numberActiveTouches = e.touchHistory.numberActiveTouches;
						return config.onStartShouldSetPanResponderCapture !== undefined ? config.onStartShouldSetPanResponderCapture(e, gestureState) : false;
					},

					onMoveShouldSetResponderCapture: function onMoveShouldSetResponderCapture(e) {
						var touchHistory = e.touchHistory;

						if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
							return false;
						}
						PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
						return config.onMoveShouldSetPanResponderCapture ? config.onMoveShouldSetPanResponderCapture(e, gestureState) : false;
					},

					onResponderGrant: function onResponderGrant(e) {
						if (!interactionState.handle) {
							interactionState.handle = InteractionManager.createInteractionHandle();
						}
						gestureState.x0 = currentCentroidX(e.touchHistory);
						gestureState.y0 = currentCentroidY(e.touchHistory);
						gestureState.dx = 0;
						gestureState.dy = 0;
						if (config.onPanResponderGrant) {
							config.onPanResponderGrant(e, gestureState);
						}

						return config.onShouldBlockNativeResponder === undefined ? true : config.onShouldBlockNativeResponder();
					},

					onResponderReject: function onResponderReject(e) {
						clearInteractionHandle(interactionState, config.onPanResponderReject, e, gestureState);
					},

					onResponderRelease: function onResponderRelease(e) {
						clearInteractionHandle(interactionState, config.onPanResponderRelease, e, gestureState);
						PanResponder._initializeGestureState(gestureState);
					},

					onResponderStart: function onResponderStart(e) {
						var touchHistory = e.touchHistory;
						gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
						if (config.onPanResponderStart) {
							config.onPanResponderStart(e, gestureState);
						}
					},

					onResponderMove: function onResponderMove(e) {
						var touchHistory = e.touchHistory;

						if (gestureState._accountsForMovesUpTo === touchHistory.mostRecentTimeStamp) {
							return;
						}

						PanResponder._updateGestureStateOnMove(gestureState, touchHistory);
						if (config.onPanResponderMove) {
							config.onPanResponderMove(e, gestureState);
						}
					},

					onResponderEnd: function onResponderEnd(e) {
						var touchHistory = e.touchHistory;
						gestureState.numberActiveTouches = touchHistory.numberActiveTouches;
						clearInteractionHandle(interactionState, config.onPanResponderEnd, e, gestureState);
					},

					onResponderTerminate: function onResponderTerminate(e) {
						clearInteractionHandle(interactionState, config.onPanResponderTerminate, e, gestureState);
						PanResponder._initializeGestureState(gestureState);
					},

					onResponderTerminationRequest: function onResponderTerminationRequest(e) {
						return config.onPanResponderTerminationRequest === undefined ? true : config.onPanResponderTerminationRequest(e, gestureState);
					} };

				return {
					panHandlers: panHandlers,
					getInteractionHandle: function getInteractionHandle() {
						return interactionState.handle;
					} };
			} };

		function clearInteractionHandle(interactionState, callback, event, gestureState) {
			if (interactionState.handle) {
				InteractionManager.clearInteractionHandle(interactionState.handle);
				interactionState.handle = null;
			}
			if (callback) {
				callback(event, gestureState);
			}
		}

		module.exports = PanResponder;
	}, // __react__/lib/TouchHistoryMath.js
	function (__inner_require__, exports, module) {
		var TouchHistoryMath = {

			centroidDimension: function centroidDimension(touchHistory, touchesChangedAfter, isXAxis, ofCurrent) {
				var touchBank = touchHistory.touchBank;
				var total = 0;
				var count = 0;

				var oneTouchData = touchHistory.numberActiveTouches === 1 ? touchHistory.touchBank[touchHistory.indexOfSingleActiveTouch] : null;

				if (oneTouchData !== null) {
					if (oneTouchData.touchActive && oneTouchData.currentTimeStamp > touchesChangedAfter) {
						total += ofCurrent && isXAxis ? oneTouchData.currentPageX : ofCurrent && !isXAxis ? oneTouchData.currentPageY : !ofCurrent && isXAxis ? oneTouchData.previousPageX : oneTouchData.previousPageY;
						count = 1;
					}
				} else {
					for (var i = 0; i < touchBank.length; i++) {
						var touchTrack = touchBank[i];
						if (touchTrack !== null && touchTrack !== undefined && touchTrack.touchActive && touchTrack.currentTimeStamp >= touchesChangedAfter) {
							var toAdd;
							if (ofCurrent && isXAxis) {
								toAdd = touchTrack.currentPageX;
							} else if (ofCurrent && !isXAxis) {
								toAdd = touchTrack.currentPageY;
							} else if (!ofCurrent && isXAxis) {
								toAdd = touchTrack.previousPageX;
							} else {
								toAdd = touchTrack.previousPageY;
							}
							total += toAdd;
							count++;
						}
					}
				}
				return count > 0 ? total / count : TouchHistoryMath.noCentroid;
			},

			currentCentroidXOfTouchesChangedAfter: function currentCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
				return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, true);
			},

			currentCentroidYOfTouchesChangedAfter: function currentCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
				return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, true);
			},

			previousCentroidXOfTouchesChangedAfter: function previousCentroidXOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
				return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, true, false);
			},

			previousCentroidYOfTouchesChangedAfter: function previousCentroidYOfTouchesChangedAfter(touchHistory, touchesChangedAfter) {
				return TouchHistoryMath.centroidDimension(touchHistory, touchesChangedAfter, false, false);
			},

			currentCentroidX: function currentCentroidX(touchHistory) {
				return TouchHistoryMath.centroidDimension(touchHistory, 0, true, true);
			},

			currentCentroidY: function currentCentroidY(touchHistory) {
				return TouchHistoryMath.centroidDimension(touchHistory, 0, false, true);
			},

			noCentroid: -1 };

		module.exports = TouchHistoryMath;
	}, // Libraries/Utilities/clamp.js
	function (__inner_require__, exports, module) {
		function clamp(min, value, max) {
			if (value < min) {
				return min;
			}
			if (value > max) {
				return max;
			}
			return value;
		}

		module.exports = clamp;
	}, // Libraries/Components/Navigation/NavigatorIOS.ios.js
	function (__inner_require__, exports, module) {
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var NavigationContext = __inner_require__(127 /*Libraries/CustomComponents/Navigator/Navigation/NavigationContext.js*/);
		var RCTNavigatorManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').NavigatorManager;
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var StaticContainer = __inner_require__(142 /*Libraries/Components/StaticContainer.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var logError = require('react-native@0.33/Libraries/Utilities/logError.js');
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var TRANSITIONER_REF = 'transitionerRef';

		var PropTypes = React.PropTypes;

		var __uid = 0;
		function getuid() {
			return __uid++;
		}var NavigatorTransitionerIOS = function (_React$Component) {
			babelHelpers.inherits(NavigatorTransitionerIOS, _React$Component);function NavigatorTransitionerIOS() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, NavigatorTransitionerIOS);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = NavigatorTransitionerIOS.__proto__ || Object.getPrototypeOf(NavigatorTransitionerIOS)).call.apply(_ref, [this].concat(args))), _this), _this.requestSchedulingNavigation = function (cb) {
					RCTNavigatorManager.requestSchedulingJavaScriptNavigation(ReactNative.findNodeHandle(_this), logError, cb);
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(NavigatorTransitionerIOS, [{ key: 'render', value: function render() {
					return React.createElement(RCTNavigator, this.props);
				} }]);return NavigatorTransitionerIOS;
		}(React.Component);

		var NavigatorIOS = React.createClass({ displayName: 'NavigatorIOS',

			propTypes: {

				initialRoute: PropTypes.shape({

					component: PropTypes.func.isRequired,

					title: PropTypes.string.isRequired,

					titleImage: Image.propTypes.source,

					passProps: PropTypes.object,

					backButtonIcon: Image.propTypes.source,

					backButtonTitle: PropTypes.string,

					leftButtonIcon: Image.propTypes.source,

					leftButtonTitle: PropTypes.string,

					onLeftButtonPress: PropTypes.func,

					rightButtonIcon: Image.propTypes.source,

					rightButtonTitle: PropTypes.string,

					onRightButtonPress: PropTypes.func,

					wrapperStyle: View.propTypes.style,

					navigationBarHidden: PropTypes.bool,

					shadowHidden: PropTypes.bool,

					tintColor: PropTypes.string,

					barTintColor: PropTypes.string,

					titleTextColor: PropTypes.string,

					translucent: PropTypes.bool }).isRequired,

				navigationBarHidden: PropTypes.bool,

				shadowHidden: PropTypes.bool,

				itemWrapperStyle: View.propTypes.style,

				tintColor: PropTypes.string,

				barTintColor: PropTypes.string,

				titleTextColor: PropTypes.string,

				translucent: PropTypes.bool,

				interactivePopGestureEnabled: PropTypes.bool },

			navigator: undefined,
			navigationContext: new NavigationContext(),

			componentWillMount: function componentWillMount() {

				this.navigator = {
					push: this.push,
					pop: this.pop,
					popN: this.popN,
					replace: this.replace,
					replacePrevious: this.replacePrevious,
					replacePreviousAndPop: this.replacePreviousAndPop,
					resetTo: this.resetTo,
					popToRoute: this.popToRoute,
					popToTop: this.popToTop,
					navigationContext: this.navigationContext };

				this._emitWillFocus(this.state.routeStack[this.state.observedTopOfStack]);
			},

			componentDidMount: function componentDidMount() {
				this._emitDidFocus(this.state.routeStack[this.state.observedTopOfStack]);
			},

			componentWillUnmount: function componentWillUnmount() {
				this.navigationContext.dispose();
				this.navigationContext = new NavigationContext();
			},

			getDefaultProps: function getDefaultProps() {
				return {
					translucent: true };
			},

			getInitialState: function getInitialState() {
				return {
					idStack: [getuid()],
					routeStack: [this.props.initialRoute],

					requestedTopOfStack: 0,

					observedTopOfStack: 0,
					progress: 1,
					fromIndex: 0,
					toIndex: 0,

					makingNavigatorRequest: false,

					updatingAllIndicesAtOrBeyond: 0 };
			},

			_toFocusOnNavigationComplete: undefined,

			_handleFocusRequest: function _handleFocusRequest(item) {
				if (this.state.makingNavigatorRequest) {
					this._toFocusOnNavigationComplete = item;
				} else {
					this._getFocusEmitter().emit('focus', item);
				}
			},

			_focusEmitter: undefined,

			_getFocusEmitter: function _getFocusEmitter() {

				var focusEmitter = this._focusEmitter;
				if (!focusEmitter) {
					focusEmitter = new EventEmitter();
					this._focusEmitter = focusEmitter;
				}
				return focusEmitter;
			},

			getChildContext: function getChildContext() {
				return {
					onFocusRequested: this._handleFocusRequest,
					focusEmitter: this._getFocusEmitter() };
			},

			childContextTypes: {
				onFocusRequested: React.PropTypes.func,
				focusEmitter: React.PropTypes.instanceOf(EventEmitter) },

			_tryLockNavigator: function _tryLockNavigator(cb) {
				this.refs[TRANSITIONER_REF].requestSchedulingNavigation(function (acquiredLock) {
					return acquiredLock && cb();
				});
			},

			_handleNavigatorStackChanged: function _handleNavigatorStackChanged(e) {
				var newObservedTopOfStack = e.nativeEvent.stackLength - 1;
				this._emitDidFocus(this.state.routeStack[newObservedTopOfStack]);

				invariant(newObservedTopOfStack <= this.state.requestedTopOfStack, 'No navigator item should be pushed without JS knowing about it %s %s', newObservedTopOfStack, this.state.requestedTopOfStack);

				var wasWaitingForConfirmation = this.state.requestedTopOfStack !== this.state.observedTopOfStack;
				if (wasWaitingForConfirmation) {
					invariant(newObservedTopOfStack === this.state.requestedTopOfStack, 'If waiting for observedTopOfStack to reach requestedTopOfStack, ' + 'the only valid observedTopOfStack should be requestedTopOfStack.');
				}

				var nextState = {
					observedTopOfStack: newObservedTopOfStack,
					makingNavigatorRequest: false,
					updatingAllIndicesAtOrBeyond: null,
					progress: 1,
					toIndex: newObservedTopOfStack,
					fromIndex: newObservedTopOfStack };

				this.setState(nextState, this._eliminateUnneededChildren);
			},

			_eliminateUnneededChildren: function _eliminateUnneededChildren() {

				var updatingAllIndicesAtOrBeyond = this.state.routeStack.length > this.state.observedTopOfStack + 1 ? this.state.observedTopOfStack + 1 : null;
				this.setState({
					idStack: this.state.idStack.slice(0, this.state.observedTopOfStack + 1),
					routeStack: this.state.routeStack.slice(0, this.state.observedTopOfStack + 1),

					requestedTopOfStack: this.state.observedTopOfStack,
					makingNavigatorRequest: true,
					updatingAllIndicesAtOrBeyond: updatingAllIndicesAtOrBeyond });
			},

			_emitDidFocus: function _emitDidFocus(route) {
				this.navigationContext.emit('didfocus', { route: route });
			},

			_emitWillFocus: function _emitWillFocus(route) {
				this.navigationContext.emit('willfocus', { route: route });
			},

			push: function push(route) {
				var _this2 = this;
				invariant(!!route, 'Must supply route to push');

				if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {
					this._tryLockNavigator(function () {
						_this2._emitWillFocus(route);

						var nextStack = _this2.state.routeStack.concat([route]);
						var nextIDStack = _this2.state.idStack.concat([getuid()]);
						_this2.setState({

							idStack: nextIDStack,
							routeStack: nextStack,
							requestedTopOfStack: nextStack.length - 1,
							makingNavigatorRequest: true,
							updatingAllIndicesAtOrBeyond: nextStack.length - 1 });
					});
				}
			},

			popN: function popN(n) {
				var _this3 = this;
				if (n === 0) {
					return;
				}

				if (this.state.requestedTopOfStack === this.state.observedTopOfStack) {
					if (this.state.requestedTopOfStack > 0) {
						this._tryLockNavigator(function () {
							var newRequestedTopOfStack = _this3.state.requestedTopOfStack - n;
							invariant(newRequestedTopOfStack >= 0, 'Cannot pop below 0');
							_this3._emitWillFocus(_this3.state.routeStack[newRequestedTopOfStack]);
							_this3.setState({
								requestedTopOfStack: newRequestedTopOfStack,
								makingNavigatorRequest: true,
								updatingAllIndicesAtOrBeyond: _this3.state.requestedTopOfStack - n });
						});
					}
				}
			},

			pop: function pop() {
				this.popN(1);
			},

			replaceAtIndex: function replaceAtIndex(route, index) {
				invariant(!!route, 'Must supply route to replace');
				if (index < 0) {
					index += this.state.routeStack.length;
				}

				if (this.state.routeStack.length <= index) {
					return;
				}

				var nextIDStack = this.state.idStack.slice();
				var nextRouteStack = this.state.routeStack.slice();
				nextIDStack[index] = getuid();
				nextRouteStack[index] = route;

				this.setState({
					idStack: nextIDStack,
					routeStack: nextRouteStack,
					makingNavigatorRequest: false,
					updatingAllIndicesAtOrBeyond: index });

				this._emitWillFocus(route);
				this._emitDidFocus(route);
			},

			replace: function replace(route) {
				this.replaceAtIndex(route, -1);
			},

			replacePrevious: function replacePrevious(route) {
				this.replaceAtIndex(route, -2);
			},

			popToTop: function popToTop() {
				this.popToRoute(this.state.routeStack[0]);
			},

			popToRoute: function popToRoute(route) {
				var indexOfRoute = this.state.routeStack.indexOf(route);
				invariant(indexOfRoute !== -1, 'Calling pop to route for a route that doesn\'t exist!');

				var numToPop = this.state.routeStack.length - indexOfRoute - 1;
				this.popN(numToPop);
			},

			replacePreviousAndPop: function replacePreviousAndPop(route) {
				var _this4 = this;

				if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {
					return;
				}
				if (this.state.routeStack.length < 2) {
					return;
				}
				this._tryLockNavigator(function () {
					_this4.replacePrevious(route);
					_this4.setState({
						requestedTopOfStack: _this4.state.requestedTopOfStack - 1,
						makingNavigatorRequest: true });
				});
			},

			resetTo: function resetTo(route) {
				invariant(!!route, 'Must supply route to push');

				if (this.state.requestedTopOfStack !== this.state.observedTopOfStack) {
					return;
				}
				this.replaceAtIndex(route, 0);
				this.popToRoute(route);
			},

			_handleNavigationComplete: function _handleNavigationComplete(e) {
				if (this._toFocusOnNavigationComplete) {
					this._getFocusEmitter().emit('focus', this._toFocusOnNavigationComplete);
					this._toFocusOnNavigationComplete = null;
				}
				this._handleNavigatorStackChanged(e);
			},

			_routeToStackItem: function _routeToStackItem(routeArg, i) {
				var component = routeArg.component,
				    wrapperStyle = routeArg.wrapperStyle,
				    passProps = routeArg.passProps,
				    route = babelHelpers.objectWithoutProperties(routeArg, ['component', 'wrapperStyle', 'passProps']);var _props = this.props,
				    itemWrapperStyle = _props.itemWrapperStyle,
				    props = babelHelpers.objectWithoutProperties(_props, ['itemWrapperStyle']);
				var shouldUpdateChild = this.state.updatingAllIndicesAtOrBeyond != null && this.state.updatingAllIndicesAtOrBeyond >= i;
				var Component = component;
				return React.createElement(StaticContainer, { key: 'nav' + i, shouldUpdate: shouldUpdateChild }, React.createElement(RCTNavigatorItem, babelHelpers.extends({}, props, route, {
					style: [styles.stackItem, itemWrapperStyle, wrapperStyle] }), React.createElement(Component, babelHelpers.extends({
					navigator: this.navigator,
					route: route }, passProps))));
			},

			_renderNavigationStackItems: function _renderNavigationStackItems() {
				var shouldRecurseToNavigator = this.state.makingNavigatorRequest || this.state.updatingAllIndicesAtOrBeyond !== null;

				var items = shouldRecurseToNavigator ? this.state.routeStack.map(this._routeToStackItem) : null;
				return React.createElement(StaticContainer, { shouldUpdate: shouldRecurseToNavigator }, React.createElement(NavigatorTransitionerIOS, {
					ref: TRANSITIONER_REF,
					style: styles.transitioner,
					vertical: this.props.vertical,
					requestedTopOfStack: this.state.requestedTopOfStack,
					onNavigationComplete: this._handleNavigationComplete,
					interactivePopGestureEnabled: this.props.interactivePopGestureEnabled }, items));
			},

			render: function render() {
				return React.createElement(View, { style: this.props.style }, this._renderNavigationStackItems());
			} });

		var styles = StyleSheet.create({
			stackItem: {
				backgroundColor: 'white',
				overflow: 'hidden',
				position: 'absolute',
				top: 0,
				left: 0,
				right: 0,
				bottom: 0 },

			transitioner: {
				flex: 1 } });

		var RCTNavigator = requireNativeComponent('RCTNavigator');
		var RCTNavigatorItem = requireNativeComponent('RCTNavItem');

		module.exports = NavigatorIOS;
	}, // Libraries/Components/StaticContainer.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);

		var onlyChild = __inner_require__(25 /*__react__/lib/onlyChild.js*/);var StaticContainer = function (_React$Component) {
			babelHelpers.inherits(StaticContainer, _React$Component);function StaticContainer() {
				babelHelpers.classCallCheck(this, StaticContainer);return babelHelpers.possibleConstructorReturn(this, (StaticContainer.__proto__ || Object.getPrototypeOf(StaticContainer)).apply(this, arguments));
			}babelHelpers.createClass(StaticContainer, [{ key: 'shouldComponentUpdate', value: function shouldComponentUpdate(nextProps) {
					return !!nextProps.shouldUpdate;
				} }, { key: 'render', value: function render() {
					var child = this.props.children;
					return child === null || child === false ? null : onlyChild(child);
				} }]);return StaticContainer;
		}(React.Component);

		module.exports = StaticContainer;
	}, // Libraries/Components/Picker/Picker.js
	function (__inner_require__, exports, module) {
		var _class, _temp;

		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var PickerIOS = __inner_require__(144 /*Libraries/Components/Picker/PickerIOS.ios.js*/);
		var PickerAndroid = __inner_require__(145 /*Libraries/Components/Picker/PickerAndroid.ios.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);
		var TextStylePropTypes = __inner_require__(36 /*Libraries/Text/TextStylePropTypes.js*/);
		var UnimplementedView = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);

		var itemStylePropType = StyleSheetPropType(TextStylePropTypes);

		var pickerStyleType = StyleSheetPropType(babelHelpers.extends({}, ViewStylePropTypes, {
			color: ColorPropType }));

		var MODE_DIALOG = 'dialog';
		var MODE_DROPDOWN = 'dropdown';var Picker = function (_React$Component) {
			babelHelpers.inherits(Picker, _React$Component);function Picker() {
				babelHelpers.classCallCheck(this, Picker);return babelHelpers.possibleConstructorReturn(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).apply(this, arguments));
			}babelHelpers.createClass(Picker, [{ key: 'render', value: function render() {
					if (Platform.OS === 'ios') {

						return React.createElement(PickerIOS, this.props, this.props.children);
					} else if (Platform.OS === 'android') {

						return React.createElement(PickerAndroid, this.props, this.props.children);
					} else {
						return React.createElement(UnimplementedView, null);
					}
				} }]);return Picker;
		}(React.Component);Picker.MODE_DIALOG = MODE_DIALOG;Picker.MODE_DROPDOWN = MODE_DROPDOWN;Picker.defaultProps = { mode: MODE_DIALOG };Picker.propTypes = babelHelpers.extends({}, View.propTypes, { style: pickerStyleType, selectedValue: React.PropTypes.any, onValueChange: React.PropTypes.func, enabled: React.PropTypes.bool, mode: React.PropTypes.oneOf(['dialog', 'dropdown']), itemStyle: itemStylePropType, prompt: React.PropTypes.string, testID: React.PropTypes.string });

		Picker.Item = (_temp = _class = function (_React$Component2) {
			babelHelpers.inherits(_class, _React$Component2);function _class() {
				babelHelpers.classCallCheck(this, _class);return babelHelpers.possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
			}babelHelpers.createClass(_class, [{ key: 'render', value: function render() {

					throw null;
				} }]);return _class;
		}(React.Component), _class.propTypes = { label: React.PropTypes.string.isRequired, value: React.PropTypes.any, color: ColorPropType, testID: React.PropTypes.string }, _temp);

		module.exports = Picker;
	}, // Libraries/Components/Picker/PickerIOS.ios.js
	function (__inner_require__, exports, module) {
		var _class, _temp;

		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactChildren = __inner_require__(14 /*__react__/lib/ReactChildren.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);
		var TextStylePropTypes = __inner_require__(36 /*Libraries/Text/TextStylePropTypes.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var itemStylePropType = StyleSheetPropType(TextStylePropTypes);
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var PickerIOS = React.createClass({ displayName: 'PickerIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {
				itemStyle: itemStylePropType,
				onValueChange: React.PropTypes.func,
				selectedValue: React.PropTypes.any }),

			getInitialState: function getInitialState() {
				return this._stateFromProps(this.props);
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
				this.setState(this._stateFromProps(nextProps));
			},

			_stateFromProps: function _stateFromProps(props) {
				var selectedIndex = 0;
				var items = [];
				ReactChildren.forEach(props.children, function (child, index) {
					if (child.props.value === props.selectedValue) {
						selectedIndex = index;
					}
					items.push({ value: child.props.value, label: child.props.label });
				});
				return { selectedIndex: selectedIndex, items: items };
			},

			render: function render() {
				var _this = this;
				return React.createElement(View, { style: this.props.style }, React.createElement(RCTPickerIOS, {
					ref: function ref(picker) {
						return _this._picker = picker;
					},
					style: [styles.pickerIOS, this.props.itemStyle],
					items: this.state.items,
					selectedIndex: this.state.selectedIndex,
					onChange: this._onChange }));
			},

			_onChange: function _onChange(event) {
				if (this.props.onChange) {
					this.props.onChange(event);
				}
				if (this.props.onValueChange) {
					this.props.onValueChange(event.nativeEvent.newValue, event.nativeEvent.newIndex);
				}

				if (this._picker && this.state.selectedIndex !== event.nativeEvent.newIndex) {
					this._picker.setNativeProps({
						selectedIndex: this.state.selectedIndex });
				}
			} });

		PickerIOS.Item = (_temp = _class = function (_React$Component) {
			babelHelpers.inherits(_class, _React$Component);function _class() {
				babelHelpers.classCallCheck(this, _class);return babelHelpers.possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).apply(this, arguments));
			}babelHelpers.createClass(_class, [{ key: 'render', value: function render() {

					return null;
				} }]);return _class;
		}(React.Component), _class.propTypes = { value: React.PropTypes.any, label: React.PropTypes.string }, _temp);

		var styles = StyleSheet.create({
			pickerIOS: {

				height: 216 } });

		var RCTPickerIOS = requireNativeComponent('RCTPicker', {
			propTypes: {
				style: itemStylePropType } }, {
			nativeOnly: {
				items: true,
				onChange: true,
				selectedIndex: true } });

		module.exports = PickerIOS;
	}, // Libraries/Components/Picker/PickerAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Components/ProgressBarAndroid/ProgressBarAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Components/ProgressViewIOS/ProgressViewIOS.ios.js
	function (__inner_require__, exports, module) {
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var ProgressViewIOS = React.createClass({ displayName: 'ProgressViewIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				progressViewStyle: PropTypes.oneOf(['default', 'bar']),

				progress: PropTypes.number,

				progressTintColor: PropTypes.string,

				trackTintColor: PropTypes.string,

				progressImage: Image.propTypes.source,

				trackImage: Image.propTypes.source }),

			render: function render() {
				return React.createElement(RCTProgressView, babelHelpers.extends({}, this.props, {
					style: [styles.progressView, this.props.style] }));
			} });

		var styles = StyleSheet.create({
			progressView: {
				height: 2 } });

		var RCTProgressView = requireNativeComponent('RCTProgressView', ProgressViewIOS);

		module.exports = ProgressViewIOS;
	}, // Libraries/Components/SegmentedControlIOS/SegmentedControlIOS.ios.js
	function (__inner_require__, exports, module) {
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var SEGMENTED_CONTROL_REFERENCE = 'segmentedcontrol';

		var SegmentedControlIOS = React.createClass({ displayName: 'SegmentedControlIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				values: PropTypes.arrayOf(PropTypes.string),

				selectedIndex: PropTypes.number,

				onValueChange: PropTypes.func,

				onChange: PropTypes.func,

				enabled: PropTypes.bool,

				tintColor: PropTypes.string,

				momentary: PropTypes.bool }),

			getDefaultProps: function getDefaultProps() {
				return {
					values: [],
					enabled: true };
			},

			_onChange: function _onChange(event) {
				this.props.onChange && this.props.onChange(event);
				this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
			},

			render: function render() {
				return React.createElement(RCTSegmentedControl, babelHelpers.extends({}, this.props, {
					ref: SEGMENTED_CONTROL_REFERENCE,
					style: [styles.segmentedControl, this.props.style],
					onChange: this._onChange }));
			} });

		var styles = StyleSheet.create({
			segmentedControl: {
				height: 28 } });

		var RCTSegmentedControl = requireNativeComponent('RCTSegmentedControl', SegmentedControlIOS);

		module.exports = SegmentedControlIOS;
	}, // Libraries/Components/Slider/Slider.js
	function (__inner_require__, exports, module) {
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var Slider = React.createClass({ displayName: 'Slider',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				style: View.propTypes.style,

				value: PropTypes.number,

				step: PropTypes.number,

				minimumValue: PropTypes.number,

				maximumValue: PropTypes.number,

				minimumTrackTintColor: PropTypes.string,

				maximumTrackTintColor: PropTypes.string,

				disabled: PropTypes.bool,

				trackImage: Image.propTypes.source,

				minimumTrackImage: Image.propTypes.source,

				maximumTrackImage: Image.propTypes.source,

				thumbImage: Image.propTypes.source,

				onValueChange: PropTypes.func,

				onSlidingComplete: PropTypes.func,

				testID: PropTypes.string }),

			getDefaultProps: function getDefaultProps() {
				return {
					disabled: false,
					value: 0,
					minimumValue: 0,
					maximumValue: 1,
					step: 0 };
			},

			render: function render() {
				var _props = this.props,
				    style = _props.style,
				    onValueChange = _props.onValueChange,
				    onSlidingComplete = _props.onSlidingComplete,
				    props = babelHelpers.objectWithoutProperties(_props, ['style', 'onValueChange', 'onSlidingComplete']);
				props.style = [styles.slider, style];

				props.onValueChange = onValueChange && function (event) {
					var userEvent = true;
					if (Platform.OS === 'android') {

						userEvent = event.nativeEvent.fromUser;
					}
					onValueChange && userEvent && onValueChange(event.nativeEvent.value);
				};

				props.onChange = props.onValueChange;

				props.onSlidingComplete = onSlidingComplete && function (event) {
					onSlidingComplete && onSlidingComplete(event.nativeEvent.value);
				};

				return React.createElement(RCTSlider, babelHelpers.extends({}, props, {
					enabled: !this.props.disabled,
					onStartShouldSetResponder: function onStartShouldSetResponder() {
						return true;
					},
					onResponderTerminationRequest: function onResponderTerminationRequest() {
						return false;
					} }));
			} });

		var styles = void 0;
		if (Platform.OS === 'ios') {
			styles = StyleSheet.create({
				slider: {
					height: 40 } });
		} else {
			styles = StyleSheet.create({
				slider: {} });
		}

		var options = {};
		if (Platform.OS === 'android') {
			options = {
				nativeOnly: {
					enabled: true } };
		}
		var RCTSlider = requireNativeComponent('RCTSlider', Slider, options);

		module.exports = Slider;
	}, // Libraries/Components/SliderIOS/SliderIOS.ios.js
	function (__inner_require__, exports, module) {
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var SliderIOS = React.createClass({ displayName: 'SliderIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				style: View.propTypes.style,

				value: PropTypes.number,

				step: PropTypes.number,

				minimumValue: PropTypes.number,

				maximumValue: PropTypes.number,

				minimumTrackTintColor: PropTypes.string,

				maximumTrackTintColor: PropTypes.string,

				disabled: PropTypes.bool,

				trackImage: Image.propTypes.source,

				minimumTrackImage: Image.propTypes.source,

				maximumTrackImage: Image.propTypes.source,

				thumbImage: Image.propTypes.source,

				onValueChange: PropTypes.func,

				onSlidingComplete: PropTypes.func }),

			getDefaultProps: function getDefaultProps() {
				return {
					disabled: false };
			},

			render: function render() {
				console.warn('SliderIOS is deprecated and will be removed in ' + 'future versions of React Native. Use the cross-platform Slider ' + 'as a drop-in replacement.');var _props = this.props,
				    style = _props.style,
				    onValueChange = _props.onValueChange,
				    onSlidingComplete = _props.onSlidingComplete,
				    props = babelHelpers.objectWithoutProperties(_props, ['style', 'onValueChange', 'onSlidingComplete']);
				props.style = [styles.slider, style];

				props.onValueChange = onValueChange && function (event) {
					onValueChange && onValueChange(event.nativeEvent.value);
				};

				props.onSlidingComplete = onSlidingComplete && function (event) {
					onSlidingComplete && onSlidingComplete(event.nativeEvent.value);
				};

				return React.createElement(RCTSlider, babelHelpers.extends({}, props, {
					onStartShouldSetResponder: function onStartShouldSetResponder() {
						return true;
					},
					onResponderTerminationRequest: function onResponderTerminationRequest() {
						return false;
					} }));
			} });

		var styles = StyleSheet.create({
			slider: {
				height: 40 } });

		var RCTSlider = requireNativeComponent('RCTSlider', SliderIOS);

		module.exports = SliderIOS;
	}, // Libraries/RCTTest/SnapshotViewIOS.ios.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);var _require = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js'),
		    TestModule = _require.TestModule;
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);var SnapshotViewIOS = function (_React$Component) {
			babelHelpers.inherits(SnapshotViewIOS, _React$Component);function SnapshotViewIOS() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, SnapshotViewIOS);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = SnapshotViewIOS.__proto__ || Object.getPrototypeOf(SnapshotViewIOS)).call.apply(_ref, [this].concat(args))), _this), _this.onDefaultAction = function (event) {
					TestModule.verifySnapshot(TestModule.markTestPassed);
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(SnapshotViewIOS, [{ key: 'render', value: function render() {
					var testIdentifier = this.props.testIdentifier || 'test';
					var onSnapshotReady = this.props.onSnapshotReady || this.onDefaultAction;
					return React.createElement(RCTSnapshot, babelHelpers.extends({
						style: style.snapshot }, this.props, {
						onSnapshotReady: onSnapshotReady,
						testIdentifier: testIdentifier }));
				} }]);return SnapshotViewIOS;
		}(React.Component);SnapshotViewIOS.propTypes = babelHelpers.extends({}, View.propTypes, { onSnapshotReady: React.PropTypes.func, testIdentifier: React.PropTypes.string });

		var style = StyleSheet.create({
			snapshot: {
				flex: 1 } });

		var RCTSnapshot = UIManager.RCTSnapshot ? requireNativeComponent('RCTSnapshot', SnapshotViewIOS) : View;

		module.exports = SnapshotViewIOS;
	}, // Libraries/Components/Switch/Switch.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var Switch = React.createClass({ displayName: 'Switch',
			propTypes: babelHelpers.extends({}, View.propTypes, {

				value: React.PropTypes.bool,

				disabled: React.PropTypes.bool,

				onValueChange: React.PropTypes.func,

				testID: React.PropTypes.string,

				tintColor: ColorPropType,

				onTintColor: ColorPropType,

				thumbTintColor: ColorPropType }),

			getDefaultProps: function getDefaultProps() {
				return {
					value: false,
					disabled: false };
			},

			mixins: [NativeMethodsMixin],

			_rctSwitch: {},
			_onChange: function _onChange(event) {
				if (Platform.OS === 'android') {
					this._rctSwitch.setNativeProps({ on: this.props.value });
				} else {
					this._rctSwitch.setNativeProps({ value: this.props.value });
				}

				this.props.onChange && this.props.onChange(event);
				this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
			},

			render: function render() {
				var _this = this;
				var props = babelHelpers.extends({}, this.props);
				props.onStartShouldSetResponder = function () {
					return true;
				};
				props.onResponderTerminationRequest = function () {
					return false;
				};
				if (Platform.OS === 'android') {
					props.enabled = !this.props.disabled;
					props.on = this.props.value;
					props.style = this.props.style;
				} else if (Platform.OS === 'ios') {
					props.style = [styles.rctSwitchIOS, this.props.style];
				}
				return React.createElement(RCTSwitch, babelHelpers.extends({}, props, {
					ref: function ref(_ref) {
						_this._rctSwitch = _ref;
					},
					onChange: this._onChange }));
			} });

		var styles = StyleSheet.create({
			rctSwitchIOS: {
				height: 31,
				width: 51 } });

		if (Platform.OS === 'android') {
			var RCTSwitch = requireNativeComponent('AndroidSwitch', Switch, {
				nativeOnly: { onChange: true, on: true, enabled: true } });
		} else {
			var RCTSwitch = requireNativeComponent('RCTSwitch', Switch, {
				nativeOnly: { onChange: true } });
		}

		module.exports = Switch;
	}, // Libraries/Components/ScrollView/RecyclerViewBackedScrollView.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
	}, // Libraries/Components/RefreshControl/RefreshControl.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		if (Platform.OS === 'android') {
			var RefreshLayoutConsts = require('react-native@0.33/Libraries/Utilities/UIManager.js').AndroidSwipeRefreshLayout.Constants;
		} else {
			var RefreshLayoutConsts = { SIZE: {} };
		}

		var RefreshControl = React.createClass({ displayName: 'RefreshControl',
			statics: {
				SIZE: RefreshLayoutConsts.SIZE },

			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				onRefresh: React.PropTypes.func,

				refreshing: React.PropTypes.bool.isRequired,

				tintColor: ColorPropType,

				titleColor: ColorPropType,

				title: React.PropTypes.string,

				enabled: React.PropTypes.bool,

				colors: React.PropTypes.arrayOf(ColorPropType),

				progressBackgroundColor: ColorPropType,

				size: React.PropTypes.oneOf([RefreshLayoutConsts.SIZE.DEFAULT, RefreshLayoutConsts.SIZE.LARGE]),

				progressViewOffset: React.PropTypes.number }),

			_nativeRef: null,
			_lastNativeRefreshing: false,

			componentDidMount: function componentDidMount() {
				this._lastNativeRefreshing = this.props.refreshing;
			},

			componentDidUpdate: function componentDidUpdate(prevProps) {

				if (this.props.refreshing !== prevProps.refreshing) {
					this._lastNativeRefreshing = this.props.refreshing;
				} else if (this.props.refreshing !== this._lastNativeRefreshing) {
					this._nativeRef.setNativeProps({ refreshing: this.props.refreshing });
					this._lastNativeRefreshing = this.props.refreshing;
				}
			},

			render: function render() {
				var _this = this;
				return React.createElement(NativeRefreshControl, babelHelpers.extends({}, this.props, {
					ref: function ref(_ref) {
						return _this._nativeRef = _ref;
					},
					onRefresh: this._onRefresh }));
			},

			_onRefresh: function _onRefresh() {
				this._lastNativeRefreshing = true;

				this.props.onRefresh && this.props.onRefresh();

				this.forceUpdate();
			} });

		if (Platform.OS === 'ios') {
			var NativeRefreshControl = requireNativeComponent('RCTRefreshControl', RefreshControl);
		} else if (Platform.OS === 'android') {
			var NativeRefreshControl = requireNativeComponent('AndroidSwipeRefreshLayout', RefreshControl);
		}

		module.exports = RefreshControl;
	}, // Libraries/Components/StatusBar/StatusBar.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');

		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');

		var StatusBarManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').StatusBarManager;

		function mergePropsStack(propsStack, defaultValues) {
			return propsStack.reduce(function (prev, cur) {
				for (var prop in cur) {
					if (cur[prop] != null) {
						prev[prop] = cur[prop];
					}
				}
				return prev;
			}, babelHelpers.extends({}, defaultValues));
		}

		function createStackEntry(props) {
			return {
				backgroundColor: props.backgroundColor != null ? {
					value: props.backgroundColor,
					animated: props.animated } : null,
				barStyle: props.barStyle != null ? {
					value: props.barStyle,
					animated: props.animated } : null,
				translucent: props.translucent,
				hidden: props.hidden != null ? {
					value: props.hidden,
					animated: props.animated,
					transition: props.showHideTransition } : null,
				networkActivityIndicatorVisible: props.networkActivityIndicatorVisible };
		}var StatusBar = function (_React$Component) {
			babelHelpers.inherits(StatusBar, _React$Component);function StatusBar() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, StatusBar);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = StatusBar.__proto__ || Object.getPrototypeOf(StatusBar)).call.apply(_ref, [this].concat(args))), _this), _this._stackEntry = null, _this._updatePropsStack = function () {

					clearImmediate(StatusBar._updateImmediate);
					StatusBar._updateImmediate = setImmediate(function () {
						var oldProps = StatusBar._currentValues;
						var mergedProps = mergePropsStack(StatusBar._propsStack, StatusBar._defaultProps);

						if (Platform.OS === 'ios') {
							if (!oldProps || oldProps.barStyle.value !== mergedProps.barStyle.value) {
								StatusBarManager.setStyle(mergedProps.barStyle.value, mergedProps.barStyle.animated);
							}
							if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
								StatusBarManager.setHidden(mergedProps.hidden.value, mergedProps.hidden.animated ? mergedProps.hidden.transition : 'none');
							}

							if (!oldProps || oldProps.networkActivityIndicatorVisible !== mergedProps.networkActivityIndicatorVisible) {
								StatusBarManager.setNetworkActivityIndicatorVisible(mergedProps.networkActivityIndicatorVisible);
							}
						} else if (Platform.OS === 'android') {
							if (!oldProps || oldProps.backgroundColor.value !== mergedProps.backgroundColor.value) {
								StatusBarManager.setColor(processColor(mergedProps.backgroundColor.value), mergedProps.backgroundColor.animated);
							}
							if (!oldProps || oldProps.hidden.value !== mergedProps.hidden.value) {
								StatusBarManager.setHidden(mergedProps.hidden.value);
							}
							if (!oldProps || oldProps.translucent !== mergedProps.translucent) {
								StatusBarManager.setTranslucent(mergedProps.translucent);
							}
						}

						StatusBar._currentValues = mergedProps;
					});
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(StatusBar, [{ key: 'componentDidMount', value: function componentDidMount() {
					this._stackEntry = createStackEntry(this.props);StatusBar._propsStack.push(this._stackEntry);this._updatePropsStack();
				} }, { key: 'componentWillUnmount', value: function componentWillUnmount() {
					var index = StatusBar._propsStack.indexOf(this._stackEntry);StatusBar._propsStack.splice(index, 1);this._updatePropsStack();
				} }, { key: 'componentDidUpdate', value: function componentDidUpdate() {
					var index = StatusBar._propsStack.indexOf(this._stackEntry);this._stackEntry = createStackEntry(this.props);StatusBar._propsStack[index] = this._stackEntry;this._updatePropsStack();
				} }, { key: 'render', value: function render() {
					return null;
				} }], [{ key: 'setHidden', value: function setHidden(hidden, animation) {
					animation = animation || 'none';StatusBar._defaultProps.hidden.value = hidden;if (Platform.OS === 'ios') {
						StatusBarManager.setHidden(hidden, animation);
					} else if (Platform.OS === 'android') {
						StatusBarManager.setHidden(hidden);
					}
				} }, { key: 'setBarStyle', value: function setBarStyle(style, animated) {
					if (Platform.OS !== 'ios') {
						console.warn('`setBarStyle` is only available on iOS');return;
					}animated = animated || false;StatusBar._defaultProps.barStyle.value = style;StatusBarManager.setStyle(style, animated);
				} }, { key: 'setNetworkActivityIndicatorVisible', value: function setNetworkActivityIndicatorVisible(visible) {
					if (Platform.OS !== 'ios') {
						console.warn('`setNetworkActivityIndicatorVisible` is only available on iOS');return;
					}StatusBar._defaultProps.networkActivityIndicatorVisible = visible;StatusBarManager.setNetworkActivityIndicatorVisible(visible);
				} }, { key: 'setBackgroundColor', value: function setBackgroundColor(color, animated) {
					if (Platform.OS !== 'android') {
						console.warn('`setBackgroundColor` is only available on Android');return;
					}animated = animated || false;StatusBar._defaultProps.backgroundColor.value = color;StatusBarManager.setColor(processColor(color), animated);
				} }, { key: 'setTranslucent', value: function setTranslucent(translucent) {
					if (Platform.OS !== 'android') {
						console.warn('`setTranslucent` is only available on Android');return;
					}StatusBar._defaultProps.translucent = translucent;StatusBarManager.setTranslucent(translucent);
				} }]);return StatusBar;
		}(React.Component);StatusBar._propsStack = [];StatusBar._defaultProps = createStackEntry({ animated: false, showHideTransition: 'fade', backgroundColor: 'black', barStyle: 'default', translucent: false, hidden: false, networkActivityIndicatorVisible: false });StatusBar._updateImmediate = null;StatusBar._currentValues = null;StatusBar.currentHeight = StatusBarManager.HEIGHT;StatusBar.propTypes = { hidden: React.PropTypes.bool, animated: React.PropTypes.bool, backgroundColor: ColorPropType, translucent: React.PropTypes.bool, barStyle: React.PropTypes.oneOf(['default', 'light-content']), networkActivityIndicatorVisible: React.PropTypes.bool, showHideTransition: React.PropTypes.oneOf(['fade', 'slide']) };StatusBar.defaultProps = { animated: false, showHideTransition: 'fade' };

		module.exports = StatusBar;
	}, // Libraries/Experimental/SwipeableRow/SwipeableListView.js
	function (__inner_require__, exports, module) {
		var ListView = __inner_require__(87 /*Libraries/CustomComponents/ListView/ListView.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var SwipeableListViewDataSource = __inner_require__(157 /*Libraries/Experimental/SwipeableRow/SwipeableListViewDataSource.js*/);
		var SwipeableRow = __inner_require__(158 /*Libraries/Experimental/SwipeableRow/SwipeableRow.js*/);var PropTypes = React.PropTypes;var SwipeableListView = function (_React$Component) {
			babelHelpers.inherits(SwipeableListView, _React$Component);function SwipeableListView() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, SwipeableListView);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = SwipeableListView.__proto__ || Object.getPrototypeOf(SwipeableListView)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
					dataSource: _this.props.dataSource }, _this._listViewRef = null, _this._shouldBounceFirstRowOnMount = false, _this._setListViewScrollable = function (value) {
					if (_this._listViewRef && _this._listViewRef.setNativeProps) {
						_this._listViewRef.setNativeProps({
							scrollEnabled: value });
					}
				}, _this.getScrollResponder = function () {
					if (_this._listViewRef && _this._listViewRef.getScrollResponder) {
						return _this._listViewRef.getScrollResponder();
					}
				}, _this._renderRow = function (rowData, sectionID, rowID) {
					var slideoutView = _this.props.renderQuickActions(rowData, sectionID, rowID);

					if (!slideoutView) {
						return _this.props.renderRow(rowData, sectionID, rowID);
					}

					var shouldBounceOnMount = false;

					if (_this._shouldBounceFirstRowOnMount) {
						_this._shouldBounceFirstRowOnMount = false;
						shouldBounceOnMount = rowID === _this.props.dataSource.getFirstRowID();
					}

					return React.createElement(SwipeableRow, {
						slideoutView: slideoutView,
						isOpen: rowData.id === _this.props.dataSource.getOpenRowID(),
						maxSwipeDistance: _this.props.maxSwipeDistance,
						key: rowID,
						onOpen: function onOpen() {
							return _this._onOpen(rowData.id);
						},
						onSwipeEnd: function onSwipeEnd() {
							return _this._setListViewScrollable(true);
						},
						onSwipeStart: function onSwipeStart() {
							return _this._setListViewScrollable(false);
						},
						shouldBounceOnMount: shouldBounceOnMount }, _this.props.renderRow(rowData, sectionID, rowID));
				}, _this._onOpen = function (rowID) {
					_this.setState({
						dataSource: _this.state.dataSource.setOpenRowID(rowID) });
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(SwipeableListView, [{ key: 'componentWillMount', value: function componentWillMount() {
					this._shouldBounceFirstRowOnMount = this.props.bounceFirstRowOnMount;
				} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(nextProps) {
					if (this.state.dataSource.getDataSource() !== nextProps.dataSource.getDataSource()) {
						this.setState({ dataSource: nextProps.dataSource });
					}
				} }, { key: 'render', value: function render() {
					var _this2 = this;return React.createElement(ListView, babelHelpers.extends({}, this.props, { ref: function ref(_ref2) {
							_this2._listViewRef = _ref2;
						}, dataSource: this.state.dataSource.getDataSource(), renderRow: this._renderRow, scrollEnabled: this.state.scrollEnabled }));
				} }], [{ key: 'getNewDataSource', value: function getNewDataSource() {
					return new SwipeableListViewDataSource({ getRowData: function getRowData(data, sectionID, rowID) {
							return data[sectionID][rowID];
						}, getSectionHeaderData: function getSectionHeaderData(data, sectionID) {
							return data[sectionID];
						}, sectionHeaderHasChanged: function sectionHeaderHasChanged(s1, s2) {
							return s1 !== s2;
						}, rowHasChanged: function rowHasChanged(row1, row2) {
							return row1 !== row2;
						} });
				} }]);return SwipeableListView;
		}(React.Component);SwipeableListView.propTypes = { bounceFirstRowOnMount: PropTypes.bool.isRequired, dataSource: PropTypes.instanceOf(SwipeableListViewDataSource).isRequired, maxSwipeDistance: PropTypes.number.isRequired, renderRow: PropTypes.func.isRequired, renderQuickActions: PropTypes.func.isRequired };SwipeableListView.defaultProps = { bounceFirstRowOnMount: false, renderQuickActions: function renderQuickActions() {
				return null;
			} };

		module.exports = SwipeableListView;
	}, // Libraries/Experimental/SwipeableRow/SwipeableListViewDataSource.js
	function (__inner_require__, exports, module) {
		var ListViewDataSource = __inner_require__(88 /*Libraries/CustomComponents/ListView/ListViewDataSource.js*/);var SwipeableListViewDataSource = function () {

			function SwipeableListViewDataSource(params) {
				var _this = this;babelHelpers.classCallCheck(this, SwipeableListViewDataSource);
				this._dataSource = new ListViewDataSource({
					getRowData: params.getRowData,
					getSectionHeaderData: params.getSectionHeaderData,
					rowHasChanged: function rowHasChanged(row1, row2) {

						return row1.id !== _this._previousOpenRowID && row2.id === _this._openRowID || row1.id === _this._previousOpenRowID && row2.id !== _this._openRowID || params.rowHasChanged(row1, row2);
					},
					sectionHeaderHasChanged: params.sectionHeaderHasChanged });
			}babelHelpers.createClass(SwipeableListViewDataSource, [{ key: 'cloneWithRowsAndSections', value: function cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities) {
					this._dataSource = this._dataSource.cloneWithRowsAndSections(dataBlob, sectionIdentities, rowIdentities);

					this._dataBlob = dataBlob;
					this.rowIdentities = this._dataSource.rowIdentities;
					this.sectionIdentities = this._dataSource.sectionIdentities;

					return this;
				} }, { key: 'getDataSource', value: function getDataSource() {
					return this._dataSource;
				} }, { key: 'getOpenRowID', value: function getOpenRowID() {
					return this._openRowID;
				} }, { key: 'getFirstRowID', value: function getFirstRowID() {

					if (this.rowIdentities) {
						return this.rowIdentities[0] && this.rowIdentities[0][0];
					}
					return Object.keys(this._dataBlob)[0];
				} }, { key: 'setOpenRowID', value: function setOpenRowID(rowID) {
					this._previousOpenRowID = this._openRowID;
					this._openRowID = rowID;

					this._dataSource = this._dataSource.cloneWithRowsAndSections(this._dataBlob, this.sectionIdentities, this.rowIdentities);

					return this;
				} }]);return SwipeableListViewDataSource;
		}();

		module.exports = SwipeableListViewDataSource;
	}, // Libraries/Experimental/SwipeableRow/SwipeableRow.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var PanResponder = __inner_require__(138 /*Libraries/Interaction/PanResponder.js*/);
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var PropTypes = React.PropTypes;

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');

		var IS_RTL = I18nManager.isRTL;

		var CLOSED_LEFT_POSITION = 0;

		var HORIZONTAL_SWIPE_DISTANCE_THRESHOLD = 10;

		var HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD = 0.3;

		var SLOW_SPEED_SWIPE_FACTOR = 4;

		var SWIPE_DURATION = 200;

		var ON_MOUNT_BOUNCE_DELAY = 700;
		var ON_MOUNT_BOUNCE_DURATION = 400;

		var RIGHT_SWIPE_BOUNCE_BACK_DISTANCE = 50;
		var RIGHT_SWIPE_BOUNCE_BACK_DURATION = 400;

		var RIGHT_SWIPE_THRESHOLD = 30 * SLOW_SPEED_SWIPE_FACTOR;

		var SwipeableRow = React.createClass({ displayName: 'SwipeableRow',
			_panResponder: {},
			_previousLeft: CLOSED_LEFT_POSITION,

			mixins: [TimerMixin],

			propTypes: {
				children: PropTypes.any,
				isOpen: PropTypes.bool,
				maxSwipeDistance: PropTypes.number.isRequired,
				onOpen: PropTypes.func.isRequired,
				onSwipeEnd: PropTypes.func.isRequired,
				onSwipeStart: PropTypes.func.isRequired,

				shouldBounceOnMount: PropTypes.bool,

				slideoutView: PropTypes.node.isRequired,

				swipeThreshold: PropTypes.number.isRequired },

			getInitialState: function getInitialState() {
				return {
					currentLeft: new Animated.Value(this._previousLeft),

					isSwipeableViewRendered: false,
					rowHeight: null };
			},

			getDefaultProps: function getDefaultProps() {
				return {
					isOpen: false,
					maxSwipeDistance: 0,
					onOpen: emptyFunction,
					onSwipeEnd: emptyFunction,
					onSwipeStart: emptyFunction,
					swipeThreshold: 30 };
			},

			componentWillMount: function componentWillMount() {
				this._panResponder = PanResponder.create({
					onMoveShouldSetPanResponderCapture: this._handleMoveShouldSetPanResponderCapture,
					onPanResponderGrant: this._handlePanResponderGrant,
					onPanResponderMove: this._handlePanResponderMove,
					onPanResponderRelease: this._handlePanResponderEnd,
					onPanResponderTerminationRequest: this._onPanResponderTerminationRequest,
					onPanResponderTerminate: this._handlePanResponderEnd });
			},

			componentDidMount: function componentDidMount() {
				var _this = this;
				if (this.props.shouldBounceOnMount) {

					this.setTimeout(function () {
						_this._animateBounceBack(ON_MOUNT_BOUNCE_DURATION);
					}, ON_MOUNT_BOUNCE_DELAY);
				}
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {

				if (this.props.isOpen && !nextProps.isOpen) {
					this._animateToClosedPosition();
				}
			},

			shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
				if (this.props.shouldBounceOnMount && !nextProps.shouldBounceOnMount) {

					return false;
				}

				return true;
			},

			render: function render() {

				var slideOutView = void 0;
				if (this.state.isSwipeableViewRendered) {
					slideOutView = React.createElement(View, { style: [styles.slideOutContainer, { height: this.state.rowHeight }] }, this.props.slideoutView);
				}

				var swipeableView = React.createElement(Animated.View, {
					onLayout: this._onSwipeableViewLayout,
					style: [styles.swipeableContainer, {
						transform: [{ translateX: this.state.currentLeft }] }] }, this.props.children);

				return React.createElement(View, this._panResponder.panHandlers, slideOutView, swipeableView);
			},

			_onSwipeableViewLayout: function _onSwipeableViewLayout(event) {
				this.setState({
					isSwipeableViewRendered: true,
					rowHeight: event.nativeEvent.layout.height });
			},

			_handleMoveShouldSetPanResponderCapture: function _handleMoveShouldSetPanResponderCapture(event, gestureState) {

				return gestureState.dy < 10 && this._isValidSwipe(gestureState);
			},

			_handlePanResponderGrant: function _handlePanResponderGrant(event, gestureState) {},

			_handlePanResponderMove: function _handlePanResponderMove(event, gestureState) {
				if (this._isSwipingExcessivelyRightFromClosedPosition(gestureState)) {
					return;
				}

				this.props.onSwipeStart();

				if (this._isSwipingRightFromClosed(gestureState)) {
					this._swipeSlowSpeed(gestureState);
				} else {
					this._swipeFullSpeed(gestureState);
				}
			},

			_isSwipingRightFromClosed: function _isSwipingRightFromClosed(gestureState) {
				var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
				return this._previousLeft === CLOSED_LEFT_POSITION && gestureStateDx > 0;
			},

			_swipeFullSpeed: function _swipeFullSpeed(gestureState) {
				this.state.currentLeft.setValue(this._previousLeft + gestureState.dx);
			},

			_swipeSlowSpeed: function _swipeSlowSpeed(gestureState) {
				this.state.currentLeft.setValue(this._previousLeft + gestureState.dx / SLOW_SPEED_SWIPE_FACTOR);
			},

			_isSwipingExcessivelyRightFromClosedPosition: function _isSwipingExcessivelyRightFromClosedPosition(gestureState) {

				var gestureStateDx = IS_RTL ? -gestureState.dx : gestureState.dx;
				return this._isSwipingRightFromClosed(gestureState) && gestureStateDx > RIGHT_SWIPE_THRESHOLD;
			},

			_onPanResponderTerminationRequest: function _onPanResponderTerminationRequest(event, gestureState) {
				return false;
			},

			_animateTo: function _animateTo(toValue) {
				var _this2 = this;var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SWIPE_DURATION;var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : emptyFunction;
				Animated.timing(this.state.currentLeft, {
					duration: duration,
					toValue: toValue }).start(function () {
					_this2._previousLeft = toValue;
					callback();
				});
			},

			_animateToOpenPosition: function _animateToOpenPosition() {
				var maxSwipeDistance = IS_RTL ? -this.props.maxSwipeDistance : this.props.maxSwipeDistance;
				this._animateTo(-maxSwipeDistance);
			},

			_animateToClosedPosition: function _animateToClosedPosition() {
				var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SWIPE_DURATION;
				this._animateTo(CLOSED_LEFT_POSITION, duration);
			},

			_animateToClosedPositionDuringBounce: function _animateToClosedPositionDuringBounce() {
				this._animateToClosedPosition(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
			},

			_animateBounceBack: function _animateBounceBack(duration) {

				var swipeBounceBackDistance = IS_RTL ? -RIGHT_SWIPE_BOUNCE_BACK_DISTANCE : RIGHT_SWIPE_BOUNCE_BACK_DISTANCE;
				this._animateTo(-swipeBounceBackDistance, duration, this._animateToClosedPositionDuringBounce);
			},

			_isValidSwipe: function _isValidSwipe(gestureState) {
				return Math.abs(gestureState.dx) > HORIZONTAL_SWIPE_DISTANCE_THRESHOLD;
			},

			_shouldAnimateRemainder: function _shouldAnimateRemainder(gestureState) {

				return Math.abs(gestureState.dx) > this.props.swipeThreshold || gestureState.vx > HORIZONTAL_FULL_SWIPE_SPEED_THRESHOLD;
			},

			_handlePanResponderEnd: function _handlePanResponderEnd(event, gestureState) {
				var horizontalDistance = IS_RTL ? -gestureState.dx : gestureState.dx;
				if (this._isSwipingRightFromClosed(gestureState)) {
					this.props.onOpen();
					this._animateBounceBack(RIGHT_SWIPE_BOUNCE_BACK_DURATION);
				} else if (this._shouldAnimateRemainder(gestureState)) {
					if (horizontalDistance < 0) {

						this.props.onOpen();
						this._animateToOpenPosition();
					} else {

						this._animateToClosedPosition();
					}
				} else {
					if (this._previousLeft === CLOSED_LEFT_POSITION) {
						this._animateToClosedPosition();
					} else {
						this._animateToOpenPosition();
					}
				}

				this.props.onSwipeEnd();
			} });

		var styles = StyleSheet.create({
			slideOutContainer: {
				bottom: 0,
				left: 0,
				position: 'absolute',
				right: 0,
				top: 0 },

			swipeableContainer: {
				flex: 1 } });

		module.exports = SwipeableRow;
	}, // Libraries/Animated/src/Animated.js
	function (__inner_require__, exports, module) {
		var AnimatedImplementation = __inner_require__(160 /*Libraries/Animated/src/AnimatedImplementation.js*/);
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		module.exports = babelHelpers.extends({}, AnimatedImplementation, {
			View: AnimatedImplementation.createAnimatedComponent(View),
			Text: AnimatedImplementation.createAnimatedComponent(Text),
			Image: AnimatedImplementation.createAnimatedComponent(Image) });
	}, // Libraries/Animated/src/AnimatedImplementation.js
	function (__inner_require__, exports, module) {
		var InteractionManager = __inner_require__(124 /*Libraries/Interaction/InteractionManager.js*/);
		var Interpolation = __inner_require__(161 /*Libraries/Animated/src/Interpolation.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var Set = require('react-native@0.33/Libraries/vendor/core/Set.js');
		var SpringConfig = __inner_require__(162 /*Libraries/Animated/src/SpringConfig.js*/);
		var ViewStylePropTypes = __inner_require__(37 /*Libraries/Components/View/ViewStylePropTypes.js*/);
		var NativeAnimatedHelper = __inner_require__(163 /*Libraries/Animated/src/NativeAnimatedHelper.js*/);

		var findNodeHandle = require('react-native@0.33/__react__/lib/findNodeHandle.js');
		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var requestAnimationFrame = __inner_require__(164 /*__fbjs__/lib/requestAnimationFrame.js*/);

		var NativeAnimatedAPI = NativeAnimatedHelper.API;var Animated = function () {
			function Animated() {
				babelHelpers.classCallCheck(this, Animated);
			}babelHelpers.createClass(Animated, [{ key: '__attach', value: function __attach() {} }, { key: '__detach', value: function __detach() {
					if (this.__isNative && this.__nativeTag != null) {
						NativeAnimatedAPI.dropAnimatedNode(this.__nativeTag);
						this.__nativeTag = undefined;
					}
				} }, { key: '__getValue', value: function __getValue() {} }, { key: '__getAnimatedValue', value: function __getAnimatedValue() {
					return this.__getValue();
				} }, { key: '__addChild', value: function __addChild(child) {} }, { key: '__removeChild', value: function __removeChild(child) {} }, { key: '__getChildren', value: function __getChildren() {
					return [];
				} }, { key: '__makeNative', value: function __makeNative() {
					if (!this.__isNative) {
						throw new Error('This node cannot be made a "native" animated node');
					}
				} }, { key: '__getNativeTag', value: function __getNativeTag() {
					NativeAnimatedHelper.assertNativeAnimatedModule();
					invariant(this.__isNative, 'Attempt to get native tag from node not marked as "native"');
					if (this.__nativeTag == null) {
						var nativeTag = NativeAnimatedHelper.generateNewNodeTag();
						NativeAnimatedAPI.createAnimatedNode(nativeTag, this.__getNativeConfig());
						this.__nativeTag = nativeTag;
					}
					return this.__nativeTag;
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					throw new Error('This JS animated node type cannot be used as native animated node');
				} }, { key: 'toJSON', value: function toJSON() {
					return this.__getValue();
				} }]);return Animated;
		}();var Animation = function () {
			function Animation() {
				babelHelpers.classCallCheck(this, Animation);
			}babelHelpers.createClass(Animation, [{ key: 'start', value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {} }, { key: 'stop', value: function stop() {
					if (this.__nativeId) {
						NativeAnimatedAPI.stopAnimation(this.__nativeId);
					}
				} }, { key: '__getNativeAnimationConfig', value: function __getNativeAnimationConfig() {

					throw new Error('This animation type cannot be offloaded to native');
				} }, { key: '__debouncedOnEnd', value: function __debouncedOnEnd(result) {
					var onEnd = this.__onEnd;
					this.__onEnd = null;
					onEnd && onEnd(result);
				} }, { key: '__startNativeAnimation', value: function __startNativeAnimation(animatedValue) {
					animatedValue.__makeNative();
					this.__nativeId = NativeAnimatedHelper.generateNewAnimationId();
					NativeAnimatedAPI.startAnimatingNode(this.__nativeId, animatedValue.__getNativeTag(), this.__getNativeAnimationConfig(), this.__debouncedOnEnd.bind(this));
				} }]);return Animation;
		}();var AnimatedWithChildren = function (_Animated) {
			babelHelpers.inherits(AnimatedWithChildren, _Animated);

			function AnimatedWithChildren() {
				babelHelpers.classCallCheck(this, AnimatedWithChildren);var _this = babelHelpers.possibleConstructorReturn(this, (AnimatedWithChildren.__proto__ || Object.getPrototypeOf(AnimatedWithChildren)).call(this));

				_this._children = [];return _this;
			}babelHelpers.createClass(AnimatedWithChildren, [{ key: '__makeNative', value: function __makeNative() {
					if (!this.__isNative) {
						this.__isNative = true;
						for (var _iterator = this._children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
							var _ref;if (_isArray) {
								if (_i >= _iterator.length) break;_ref = _iterator[_i++];
							} else {
								_i = _iterator.next();if (_i.done) break;_ref = _i.value;
							}var child = _ref;
							child.__makeNative();
							NativeAnimatedAPI.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
						}
					}
				} }, { key: '__addChild', value: function __addChild(child) {
					if (this._children.length === 0) {
						this.__attach();
					}
					this._children.push(child);
					if (this.__isNative) {

						child.__makeNative();
						NativeAnimatedAPI.connectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
					}
				} }, { key: '__removeChild', value: function __removeChild(child) {
					var index = this._children.indexOf(child);
					if (index === -1) {
						console.warn('Trying to remove a child that doesn\'t exist');
						return;
					}
					if (this.__isNative && child.__isNative) {
						NativeAnimatedAPI.disconnectAnimatedNodes(this.__getNativeTag(), child.__getNativeTag());
					}
					this._children.splice(index, 1);
					if (this._children.length === 0) {
						this.__detach();
					}
				} }, { key: '__getChildren', value: function __getChildren() {
					return this._children;
				} }]);return AnimatedWithChildren;
		}(Animated);

		function _flush(rootNode) {
			var animatedStyles = new Set();
			function findAnimatedStyles(node) {
				if (typeof node.update === 'function') {
					animatedStyles.add(node);
				} else {
					node.__getChildren().forEach(findAnimatedStyles);
				}
			}
			findAnimatedStyles(rootNode);

			animatedStyles.forEach(function (animatedStyle) {
				return animatedStyle.update();
			});
		}

		var _easeInOut = void 0;
		function easeInOut() {
			if (!_easeInOut) {
				var Easing = __inner_require__(166 /*Libraries/Animated/src/Easing.js*/);
				_easeInOut = Easing.inOut(Easing.ease);
			}
			return _easeInOut;
		}var TimingAnimation = function (_Animation) {
			babelHelpers.inherits(TimingAnimation, _Animation);

			function TimingAnimation(config) {
				babelHelpers.classCallCheck(this, TimingAnimation);var _this2 = babelHelpers.possibleConstructorReturn(this, (TimingAnimation.__proto__ || Object.getPrototypeOf(TimingAnimation)).call(this));

				_this2._toValue = config.toValue;
				_this2._easing = config.easing !== undefined ? config.easing : easeInOut();
				_this2._duration = config.duration !== undefined ? config.duration : 500;
				_this2._delay = config.delay !== undefined ? config.delay : 0;
				_this2.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;
				_this2._useNativeDriver = config.useNativeDriver !== undefined ? config.useNativeDriver : false;return _this2;
			}babelHelpers.createClass(TimingAnimation, [{ key: '__getNativeAnimationConfig', value: function __getNativeAnimationConfig() {
					var frameDuration = 1000.0 / 60.0;
					var frames = [];
					for (var dt = 0.0; dt < this._duration; dt += frameDuration) {
						frames.push(this._easing(dt / this._duration));
					}
					frames.push(this._easing(1));
					return {
						type: 'frames',
						frames: frames,
						toValue: this._toValue,
						delay: this._delay };
				} }, { key: 'start', value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
					var _this3 = this;
					this.__active = true;
					this._fromValue = fromValue;
					this._onUpdate = onUpdate;
					this.__onEnd = onEnd;

					var start = function start() {
						if (_this3._duration === 0) {
							_this3._onUpdate(_this3._toValue);
							_this3.__debouncedOnEnd({ finished: true });
						} else {
							_this3._startTime = Date.now();
							if (_this3._useNativeDriver) {
								_this3.__startNativeAnimation(animatedValue);
							} else {
								_this3._animationFrame = requestAnimationFrame(_this3.onUpdate.bind(_this3));
							}
						}
					};
					if (this._delay) {
						this._timeout = setTimeout(start, this._delay);
					} else {
						start();
					}
				} }, { key: 'onUpdate', value: function onUpdate() {
					var now = Date.now();
					if (now >= this._startTime + this._duration) {
						if (this._duration === 0) {
							this._onUpdate(this._toValue);
						} else {
							this._onUpdate(this._fromValue + this._easing(1) * (this._toValue - this._fromValue));
						}
						this.__debouncedOnEnd({ finished: true });
						return;
					}

					this._onUpdate(this._fromValue + this._easing((now - this._startTime) / this._duration) * (this._toValue - this._fromValue));

					if (this.__active) {
						this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
					}
				} }, { key: 'stop', value: function stop() {
					babelHelpers.get(TimingAnimation.prototype.__proto__ || Object.getPrototypeOf(TimingAnimation.prototype), 'stop', this).call(this);
					this.__active = false;
					clearTimeout(this._timeout);
					global.cancelAnimationFrame(this._animationFrame);
					this.__debouncedOnEnd({ finished: false });
				} }]);return TimingAnimation;
		}(Animation);var DecayAnimation = function (_Animation2) {
			babelHelpers.inherits(DecayAnimation, _Animation2);

			function DecayAnimation(config) {
				babelHelpers.classCallCheck(this, DecayAnimation);var _this4 = babelHelpers.possibleConstructorReturn(this, (DecayAnimation.__proto__ || Object.getPrototypeOf(DecayAnimation)).call(this));

				_this4._deceleration = config.deceleration !== undefined ? config.deceleration : 0.998;
				_this4._velocity = config.velocity;
				_this4._useNativeDriver = config.useNativeDriver !== undefined ? config.useNativeDriver : false;
				_this4.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;return _this4;
			}babelHelpers.createClass(DecayAnimation, [{ key: '__getNativeAnimationConfig', value: function __getNativeAnimationConfig() {
					return {
						type: 'decay',
						deceleration: this._deceleration,
						velocity: this._velocity };
				} }, { key: 'start', value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
					this.__active = true;
					this._lastValue = fromValue;
					this._fromValue = fromValue;
					this._onUpdate = onUpdate;
					this.__onEnd = onEnd;
					this._startTime = Date.now();
					if (this._useNativeDriver) {
						this.__startNativeAnimation(animatedValue);
					} else {
						this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
					}
				} }, { key: 'onUpdate', value: function onUpdate() {
					var now = Date.now();

					var value = this._fromValue + this._velocity / (1 - this._deceleration) * (1 - Math.exp(-(1 - this._deceleration) * (now - this._startTime)));

					this._onUpdate(value);

					if (Math.abs(this._lastValue - value) < 0.1) {
						this.__debouncedOnEnd({ finished: true });
						return;
					}

					this._lastValue = value;
					if (this.__active) {
						this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
					}
				} }, { key: 'stop', value: function stop() {
					babelHelpers.get(DecayAnimation.prototype.__proto__ || Object.getPrototypeOf(DecayAnimation.prototype), 'stop', this).call(this);
					this.__active = false;
					global.cancelAnimationFrame(this._animationFrame);
					this.__debouncedOnEnd({ finished: false });
				} }]);return DecayAnimation;
		}(Animation);

		function withDefault(value, defaultValue) {
			if (value === undefined || value === null) {
				return defaultValue;
			}
			return value;
		}var SpringAnimation = function (_Animation3) {
			babelHelpers.inherits(SpringAnimation, _Animation3);

			function SpringAnimation(config) {
				babelHelpers.classCallCheck(this, SpringAnimation);var _this5 = babelHelpers.possibleConstructorReturn(this, (SpringAnimation.__proto__ || Object.getPrototypeOf(SpringAnimation)).call(this));

				_this5._overshootClamping = withDefault(config.overshootClamping, false);
				_this5._restDisplacementThreshold = withDefault(config.restDisplacementThreshold, 0.001);
				_this5._restSpeedThreshold = withDefault(config.restSpeedThreshold, 0.001);
				_this5._initialVelocity = config.velocity;
				_this5._lastVelocity = withDefault(config.velocity, 0);
				_this5._toValue = config.toValue;
				_this5._useNativeDriver = config.useNativeDriver !== undefined ? config.useNativeDriver : false;
				_this5.__isInteraction = config.isInteraction !== undefined ? config.isInteraction : true;

				var springConfig;
				if (config.bounciness !== undefined || config.speed !== undefined) {
					invariant(config.tension === undefined && config.friction === undefined, 'You can only define bounciness/speed or tension/friction but not both');

					springConfig = SpringConfig.fromBouncinessAndSpeed(withDefault(config.bounciness, 8), withDefault(config.speed, 12));
				} else {
					springConfig = SpringConfig.fromOrigamiTensionAndFriction(withDefault(config.tension, 40), withDefault(config.friction, 7));
				}
				_this5._tension = springConfig.tension;
				_this5._friction = springConfig.friction;return _this5;
			}babelHelpers.createClass(SpringAnimation, [{ key: '__getNativeAnimationConfig', value: function __getNativeAnimationConfig() {
					return {
						type: 'spring',
						overshootClamping: this._overshootClamping,
						restDisplacementThreshold: this._restDisplacementThreshold,
						restSpeedThreshold: this._restSpeedThreshold,
						tension: this._tension,
						friction: this._friction,
						initialVelocity: withDefault(this._initialVelocity, this._lastVelocity),
						toValue: this._toValue };
				} }, { key: 'start', value: function start(fromValue, onUpdate, onEnd, previousAnimation, animatedValue) {
					this.__active = true;
					this._startPosition = fromValue;
					this._lastPosition = this._startPosition;

					this._onUpdate = onUpdate;
					this.__onEnd = onEnd;
					this._lastTime = Date.now();

					if (previousAnimation instanceof SpringAnimation) {
						var internalState = previousAnimation.getInternalState();
						this._lastPosition = internalState.lastPosition;
						this._lastVelocity = internalState.lastVelocity;
						this._lastTime = internalState.lastTime;
					}
					if (this._initialVelocity !== undefined && this._initialVelocity !== null) {
						this._lastVelocity = this._initialVelocity;
					}
					if (this._useNativeDriver) {
						this.__startNativeAnimation(animatedValue);
					} else {
						this.onUpdate();
					}
				} }, { key: 'getInternalState', value: function getInternalState() {
					return {
						lastPosition: this._lastPosition,
						lastVelocity: this._lastVelocity,
						lastTime: this._lastTime };
				} }, { key: 'onUpdate', value: function onUpdate() {
					var position = this._lastPosition;
					var velocity = this._lastVelocity;

					var tempPosition = this._lastPosition;
					var tempVelocity = this._lastVelocity;

					var MAX_STEPS = 64;
					var now = Date.now();
					if (now > this._lastTime + MAX_STEPS) {
						now = this._lastTime + MAX_STEPS;
					}

					var TIMESTEP_MSEC = 1;
					var numSteps = Math.floor((now - this._lastTime) / TIMESTEP_MSEC);

					for (var i = 0; i < numSteps; ++i) {

						var step = TIMESTEP_MSEC / 1000;

						var aVelocity = velocity;
						var aAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
						var tempPosition = position + aVelocity * step / 2;
						var tempVelocity = velocity + aAcceleration * step / 2;

						var bVelocity = tempVelocity;
						var bAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
						tempPosition = position + bVelocity * step / 2;
						tempVelocity = velocity + bAcceleration * step / 2;

						var cVelocity = tempVelocity;
						var cAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
						tempPosition = position + cVelocity * step / 2;
						tempVelocity = velocity + cAcceleration * step / 2;

						var dVelocity = tempVelocity;
						var dAcceleration = this._tension * (this._toValue - tempPosition) - this._friction * tempVelocity;
						tempPosition = position + cVelocity * step / 2;
						tempVelocity = velocity + cAcceleration * step / 2;

						var dxdt = (aVelocity + 2 * (bVelocity + cVelocity) + dVelocity) / 6;
						var dvdt = (aAcceleration + 2 * (bAcceleration + cAcceleration) + dAcceleration) / 6;

						position += dxdt * step;
						velocity += dvdt * step;
					}

					this._lastTime = now;
					this._lastPosition = position;
					this._lastVelocity = velocity;

					this._onUpdate(position);
					if (!this.__active) {
						return;
					}

					var isOvershooting = false;
					if (this._overshootClamping && this._tension !== 0) {
						if (this._startPosition < this._toValue) {
							isOvershooting = position > this._toValue;
						} else {
							isOvershooting = position < this._toValue;
						}
					}
					var isVelocity = Math.abs(velocity) <= this._restSpeedThreshold;
					var isDisplacement = true;
					if (this._tension !== 0) {
						isDisplacement = Math.abs(this._toValue - position) <= this._restDisplacementThreshold;
					}

					if (isOvershooting || isVelocity && isDisplacement) {
						if (this._tension !== 0) {

							this._onUpdate(this._toValue);
						}

						this.__debouncedOnEnd({ finished: true });
						return;
					}
					this._animationFrame = requestAnimationFrame(this.onUpdate.bind(this));
				} }, { key: 'stop', value: function stop() {
					babelHelpers.get(SpringAnimation.prototype.__proto__ || Object.getPrototypeOf(SpringAnimation.prototype), 'stop', this).call(this);
					this.__active = false;
					global.cancelAnimationFrame(this._animationFrame);
					this.__debouncedOnEnd({ finished: false });
				} }]);return SpringAnimation;
		}(Animation);

		var _uniqueId = 1;var AnimatedValue = function (_AnimatedWithChildren) {
			babelHelpers.inherits(AnimatedValue, _AnimatedWithChildren);

			function AnimatedValue(value) {
				babelHelpers.classCallCheck(this, AnimatedValue);var _this6 = babelHelpers.possibleConstructorReturn(this, (AnimatedValue.__proto__ || Object.getPrototypeOf(AnimatedValue)).call(this));

				_this6._startingValue = _this6._value = value;
				_this6._offset = 0;
				_this6._animation = null;
				_this6._listeners = {};return _this6;
			}babelHelpers.createClass(AnimatedValue, [{ key: '__detach', value: function __detach() {
					this.stopAnimation();
					babelHelpers.get(AnimatedValue.prototype.__proto__ || Object.getPrototypeOf(AnimatedValue.prototype), '__detach', this).call(this);
				} }, { key: '__getValue', value: function __getValue() {
					return this._value + this._offset;
				} }, { key: '__makeNative', value: function __makeNative() {
					babelHelpers.get(AnimatedValue.prototype.__proto__ || Object.getPrototypeOf(AnimatedValue.prototype), '__makeNative', this).call(this);

					if (Object.keys(this._listeners).length) {
						this._startListeningToNativeValueUpdates();
					}
				} }, { key: 'setValue', value: function setValue(value) {
					if (this._animation) {
						this._animation.stop();
						this._animation = null;
					}
					this._updateValue(value, !this.__isNative);
					if (this.__isNative) {
						NativeAnimatedAPI.setAnimatedNodeValue(this.__getNativeTag(), value);
					}
				} }, { key: 'setOffset', value: function setOffset(offset) {
					this._offset = offset;
				} }, { key: 'flattenOffset', value: function flattenOffset() {
					this._value += this._offset;
					this._offset = 0;
				} }, { key: 'addListener', value: function addListener(callback) {
					var id = String(_uniqueId++);
					this._listeners[id] = callback;
					if (this.__isNative) {
						this._startListeningToNativeValueUpdates();
					}
					return id;
				} }, { key: 'removeListener', value: function removeListener(id) {
					delete this._listeners[id];
					if (this.__isNative && Object.keys(this._listeners).length === 0) {
						this._stopListeningForNativeValueUpdates();
					}
				} }, { key: 'removeAllListeners', value: function removeAllListeners() {
					this._listeners = {};
					if (this.__isNative) {
						this._stopListeningForNativeValueUpdates();
					}
				} }, { key: '_startListeningToNativeValueUpdates', value: function _startListeningToNativeValueUpdates() {
					var _this7 = this;
					if (this.__nativeAnimatedValueListener) {
						return;
					}

					NativeAnimatedAPI.startListeningToAnimatedNodeValue(this.__getNativeTag());
					this.__nativeAnimatedValueListener = NativeAnimatedHelper.nativeEventEmitter.addListener('onAnimatedValueUpdate', function (data) {
						if (data.tag !== _this7.__getNativeTag()) {
							return;
						}
						_this7._updateValue(data.value, false);
					});
				} }, { key: '_stopListeningForNativeValueUpdates', value: function _stopListeningForNativeValueUpdates() {
					if (!this.__nativeAnimatedValueListener) {
						return;
					}

					this.__nativeAnimatedValueListener.remove();
					this.__nativeAnimatedValueListener = null;
					NativeAnimatedAPI.stopListeningToAnimatedNodeValue(this.__getNativeTag());
				} }, { key: 'stopAnimation', value: function stopAnimation(callback) {
					this.stopTracking();
					this._animation && this._animation.stop();
					this._animation = null;
					callback && callback(this.__getValue());
				} }, { key: 'interpolate', value: function interpolate(config) {
					return new AnimatedInterpolation(this, config);
				} }, { key: 'animate', value: function animate(animation, callback) {
					var _this8 = this;
					var handle = null;
					if (animation.__isInteraction) {
						handle = InteractionManager.createInteractionHandle();
					}
					var previousAnimation = this._animation;
					this._animation && this._animation.stop();
					this._animation = animation;
					animation.start(this._value, function (value) {

						_this8._updateValue(value, true);
					}, function (result) {
						_this8._animation = null;
						if (handle !== null) {
							InteractionManager.clearInteractionHandle(handle);
						}
						callback && callback(result);
					}, previousAnimation, this);
				} }, { key: 'stopTracking', value: function stopTracking() {
					this._tracking && this._tracking.__detach();
					this._tracking = null;
				} }, { key: 'track', value: function track(tracking) {
					this.stopTracking();
					this._tracking = tracking;
				} }, { key: '_updateValue', value: function _updateValue(value, flush) {
					this._value = value;
					if (flush) {
						_flush(this);
					}
					for (var key in this._listeners) {
						this._listeners[key]({ value: this.__getValue() });
					}
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					return {
						type: 'value',
						value: this._startingValue };
				} }]);return AnimatedValue;
		}(AnimatedWithChildren);var AnimatedValueXY = function (_AnimatedWithChildren2) {
			babelHelpers.inherits(AnimatedValueXY, _AnimatedWithChildren2);

			function AnimatedValueXY(valueIn) {
				babelHelpers.classCallCheck(this, AnimatedValueXY);var _this9 = babelHelpers.possibleConstructorReturn(this, (AnimatedValueXY.__proto__ || Object.getPrototypeOf(AnimatedValueXY)).call(this));

				var value = valueIn || { x: 0, y: 0 };
				if (typeof value.x === 'number' && typeof value.y === 'number') {
					_this9.x = new AnimatedValue(value.x);
					_this9.y = new AnimatedValue(value.y);
				} else {
					invariant(value.x instanceof AnimatedValue && value.y instanceof AnimatedValue, 'AnimatedValueXY must be initalized with an object of numbers or ' + 'AnimatedValues.');

					_this9.x = value.x;
					_this9.y = value.y;
				}
				_this9._listeners = {};return _this9;
			}babelHelpers.createClass(AnimatedValueXY, [{ key: 'setValue', value: function setValue(value) {
					this.x.setValue(value.x);
					this.y.setValue(value.y);
				} }, { key: 'setOffset', value: function setOffset(offset) {
					this.x.setOffset(offset.x);
					this.y.setOffset(offset.y);
				} }, { key: 'flattenOffset', value: function flattenOffset() {
					this.x.flattenOffset();
					this.y.flattenOffset();
				} }, { key: '__getValue', value: function __getValue() {
					return {
						x: this.x.__getValue(),
						y: this.y.__getValue() };
				} }, { key: 'stopAnimation', value: function stopAnimation(callback) {
					this.x.stopAnimation();
					this.y.stopAnimation();
					callback && callback(this.__getValue());
				} }, { key: 'addListener', value: function addListener(callback) {
					var _this10 = this;
					var id = String(_uniqueId++);
					var jointCallback = function jointCallback(_ref2) {
						var number = _ref2.value;
						callback(_this10.__getValue());
					};
					this._listeners[id] = {
						x: this.x.addListener(jointCallback),
						y: this.y.addListener(jointCallback) };

					return id;
				} }, { key: 'removeListener', value: function removeListener(id) {
					this.x.removeListener(this._listeners[id].x);
					this.y.removeListener(this._listeners[id].y);
					delete this._listeners[id];
				} }, { key: 'getLayout', value: function getLayout() {
					return {
						left: this.x,
						top: this.y };
				} }, { key: 'getTranslateTransform', value: function getTranslateTransform() {
					return [{ translateX: this.x }, { translateY: this.y }];
				} }]);return AnimatedValueXY;
		}(AnimatedWithChildren);var AnimatedInterpolation = function (_AnimatedWithChildren3) {
			babelHelpers.inherits(AnimatedInterpolation, _AnimatedWithChildren3);

			function AnimatedInterpolation(parent, config) {
				babelHelpers.classCallCheck(this, AnimatedInterpolation);var _this11 = babelHelpers.possibleConstructorReturn(this, (AnimatedInterpolation.__proto__ || Object.getPrototypeOf(AnimatedInterpolation)).call(this));

				_this11._parent = parent;
				_this11._config = config;
				_this11._interpolation = Interpolation.create(config);return _this11;
			}babelHelpers.createClass(AnimatedInterpolation, [{ key: '__getValue', value: function __getValue() {
					var parentValue = this._parent.__getValue();
					invariant(typeof parentValue === 'number', 'Cannot interpolate an input which is not a number.');

					return this._interpolation(parentValue);
				} }, { key: 'interpolate', value: function interpolate(config) {
					return new AnimatedInterpolation(this, config);
				} }, { key: '__attach', value: function __attach() {
					this._parent.__addChild(this);
				} }, { key: '__detach', value: function __detach() {
					this._parent.__removeChild(this);
					babelHelpers.get(AnimatedInterpolation.prototype.__proto__ || Object.getPrototypeOf(AnimatedInterpolation.prototype), '__detach', this).call(this);
				} }, { key: '__transformDataType', value: function __transformDataType(range) {

					return range.map(function (value) {
						if (typeof value !== 'string') {
							return value;
						}
						if (/deg$/.test(value)) {
							var degrees = parseFloat(value, 10) || 0;
							var radians = degrees * Math.PI / 180.0;
							return radians;
						} else {

							return parseFloat(value, 10) || 0;
						}
					});
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					NativeAnimatedHelper.validateInterpolation(this._config);
					return babelHelpers.extends({}, this._config, {

						outputRange: this.__transformDataType(this._config.outputRange),
						type: 'interpolation' });
				} }]);return AnimatedInterpolation;
		}(AnimatedWithChildren);var AnimatedAddition = function (_AnimatedWithChildren4) {
			babelHelpers.inherits(AnimatedAddition, _AnimatedWithChildren4);

			function AnimatedAddition(a, b) {
				babelHelpers.classCallCheck(this, AnimatedAddition);var _this12 = babelHelpers.possibleConstructorReturn(this, (AnimatedAddition.__proto__ || Object.getPrototypeOf(AnimatedAddition)).call(this));

				_this12._a = typeof a === 'number' ? new AnimatedValue(a) : a;
				_this12._b = typeof b === 'number' ? new AnimatedValue(b) : b;return _this12;
			}babelHelpers.createClass(AnimatedAddition, [{ key: '__makeNative', value: function __makeNative() {
					this._a.__makeNative();
					this._b.__makeNative();
					babelHelpers.get(AnimatedAddition.prototype.__proto__ || Object.getPrototypeOf(AnimatedAddition.prototype), '__makeNative', this).call(this);
				} }, { key: '__getValue', value: function __getValue() {
					return this._a.__getValue() + this._b.__getValue();
				} }, { key: 'interpolate', value: function interpolate(config) {
					return new AnimatedInterpolation(this, config);
				} }, { key: '__attach', value: function __attach() {
					this._a.__addChild(this);
					this._b.__addChild(this);
				} }, { key: '__detach', value: function __detach() {
					this._a.__removeChild(this);
					this._b.__removeChild(this);
					babelHelpers.get(AnimatedAddition.prototype.__proto__ || Object.getPrototypeOf(AnimatedAddition.prototype), '__detach', this).call(this);
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					return {
						type: 'addition',
						input: [this._a.__getNativeTag(), this._b.__getNativeTag()] };
				} }]);return AnimatedAddition;
		}(AnimatedWithChildren);var AnimatedMultiplication = function (_AnimatedWithChildren5) {
			babelHelpers.inherits(AnimatedMultiplication, _AnimatedWithChildren5);

			function AnimatedMultiplication(a, b) {
				babelHelpers.classCallCheck(this, AnimatedMultiplication);var _this13 = babelHelpers.possibleConstructorReturn(this, (AnimatedMultiplication.__proto__ || Object.getPrototypeOf(AnimatedMultiplication)).call(this));

				_this13._a = typeof a === 'number' ? new AnimatedValue(a) : a;
				_this13._b = typeof b === 'number' ? new AnimatedValue(b) : b;return _this13;
			}babelHelpers.createClass(AnimatedMultiplication, [{ key: '__makeNative', value: function __makeNative() {
					babelHelpers.get(AnimatedMultiplication.prototype.__proto__ || Object.getPrototypeOf(AnimatedMultiplication.prototype), '__makeNative', this).call(this);
					this._a.__makeNative();
					this._b.__makeNative();
				} }, { key: '__getValue', value: function __getValue() {
					return this._a.__getValue() * this._b.__getValue();
				} }, { key: 'interpolate', value: function interpolate(config) {
					return new AnimatedInterpolation(this, config);
				} }, { key: '__attach', value: function __attach() {
					this._a.__addChild(this);
					this._b.__addChild(this);
				} }, { key: '__detach', value: function __detach() {
					this._a.__removeChild(this);
					this._b.__removeChild(this);
					babelHelpers.get(AnimatedMultiplication.prototype.__proto__ || Object.getPrototypeOf(AnimatedMultiplication.prototype), '__detach', this).call(this);
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					return {
						type: 'multiplication',
						input: [this._a.__getNativeTag(), this._b.__getNativeTag()] };
				} }]);return AnimatedMultiplication;
		}(AnimatedWithChildren);var AnimatedModulo = function (_AnimatedWithChildren6) {
			babelHelpers.inherits(AnimatedModulo, _AnimatedWithChildren6);

			function AnimatedModulo(a, modulus) {
				babelHelpers.classCallCheck(this, AnimatedModulo);var _this14 = babelHelpers.possibleConstructorReturn(this, (AnimatedModulo.__proto__ || Object.getPrototypeOf(AnimatedModulo)).call(this));

				_this14._a = a;
				_this14._modulus = modulus;return _this14;
			}babelHelpers.createClass(AnimatedModulo, [{ key: '__getValue', value: function __getValue() {
					return (this._a.__getValue() % this._modulus + this._modulus) % this._modulus;
				} }, { key: 'interpolate', value: function interpolate(config) {
					return new AnimatedInterpolation(this, config);
				} }, { key: '__attach', value: function __attach() {
					this._a.__addChild(this);
				} }, { key: '__detach', value: function __detach() {
					this._a.__removeChild(this);
				} }]);return AnimatedModulo;
		}(AnimatedWithChildren);var AnimatedTransform = function (_AnimatedWithChildren7) {
			babelHelpers.inherits(AnimatedTransform, _AnimatedWithChildren7);

			function AnimatedTransform(transforms) {
				babelHelpers.classCallCheck(this, AnimatedTransform);var _this15 = babelHelpers.possibleConstructorReturn(this, (AnimatedTransform.__proto__ || Object.getPrototypeOf(AnimatedTransform)).call(this));

				_this15._transforms = transforms;return _this15;
			}babelHelpers.createClass(AnimatedTransform, [{ key: '__makeNative', value: function __makeNative() {
					babelHelpers.get(AnimatedTransform.prototype.__proto__ || Object.getPrototypeOf(AnimatedTransform.prototype), '__makeNative', this).call(this);
					this._transforms.forEach(function (transform) {
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								value.__makeNative();
							}
						}
					});
				} }, { key: '__getValue', value: function __getValue() {
					return this._transforms.map(function (transform) {
						var result = {};
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								result[key] = value.__getValue();
							} else {
								result[key] = value;
							}
						}
						return result;
					});
				} }, { key: '__getAnimatedValue', value: function __getAnimatedValue() {
					return this._transforms.map(function (transform) {
						var result = {};
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								result[key] = value.__getAnimatedValue();
							} else {

								result[key] = value;
							}
						}
						return result;
					});
				} }, { key: '__attach', value: function __attach() {
					var _this16 = this;
					this._transforms.forEach(function (transform) {
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								value.__addChild(_this16);
							}
						}
					});
				} }, { key: '__detach', value: function __detach() {
					var _this17 = this;
					this._transforms.forEach(function (transform) {
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								value.__removeChild(_this17);
							}
						}
					});
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					var transConfigs = [];

					this._transforms.forEach(function (transform) {
						for (var key in transform) {
							var value = transform[key];
							if (value instanceof Animated) {
								transConfigs.push({
									type: 'animated',
									property: key,
									nodeTag: value.__getNativeTag() });
							} else {
								transConfigs.push({
									type: 'static',
									property: key,
									value: value });
							}
						}
					});

					NativeAnimatedHelper.validateTransform(transConfigs);
					return {
						type: 'transform',
						transforms: transConfigs };
				} }]);return AnimatedTransform;
		}(AnimatedWithChildren);var AnimatedStyle = function (_AnimatedWithChildren8) {
			babelHelpers.inherits(AnimatedStyle, _AnimatedWithChildren8);

			function AnimatedStyle(style) {
				babelHelpers.classCallCheck(this, AnimatedStyle);var _this18 = babelHelpers.possibleConstructorReturn(this, (AnimatedStyle.__proto__ || Object.getPrototypeOf(AnimatedStyle)).call(this));

				style = flattenStyle(style) || {};
				if (style.transform) {
					style = babelHelpers.extends({}, style, {
						transform: new AnimatedTransform(style.transform) });
				}
				_this18._style = style;return _this18;
			}babelHelpers.createClass(AnimatedStyle, [{ key: '__getValue', value: function __getValue() {
					var style = {};
					for (var key in this._style) {
						var value = this._style[key];
						if (value instanceof Animated) {
							if (!value.__isNative) {

								style[key] = value.__getValue();
							}
						} else {
							style[key] = value;
						}
					}
					return style;
				} }, { key: '__getAnimatedValue', value: function __getAnimatedValue() {
					var style = {};
					for (var key in this._style) {
						var value = this._style[key];
						if (value instanceof Animated) {
							style[key] = value.__getAnimatedValue();
						}
					}
					return style;
				} }, { key: '__attach', value: function __attach() {
					for (var key in this._style) {
						var value = this._style[key];
						if (value instanceof Animated) {
							value.__addChild(this);
						}
					}
				} }, { key: '__detach', value: function __detach() {
					for (var key in this._style) {
						var value = this._style[key];
						if (value instanceof Animated) {
							value.__removeChild(this);
						}
					}
				} }, { key: '__makeNative', value: function __makeNative() {
					babelHelpers.get(AnimatedStyle.prototype.__proto__ || Object.getPrototypeOf(AnimatedStyle.prototype), '__makeNative', this).call(this);
					for (var key in this._style) {
						var value = this._style[key];
						if (value instanceof Animated) {
							value.__makeNative();
						}
					}
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					var styleConfig = {};
					for (var styleKey in this._style) {
						if (this._style[styleKey] instanceof Animated) {
							styleConfig[styleKey] = this._style[styleKey].__getNativeTag();
						}
					}
					NativeAnimatedHelper.validateStyles(styleConfig);
					return {
						type: 'style',
						style: styleConfig };
				} }]);return AnimatedStyle;
		}(AnimatedWithChildren);var AnimatedProps = function (_Animated2) {
			babelHelpers.inherits(AnimatedProps, _Animated2);

			function AnimatedProps(props, callback) {
				babelHelpers.classCallCheck(this, AnimatedProps);var _this19 = babelHelpers.possibleConstructorReturn(this, (AnimatedProps.__proto__ || Object.getPrototypeOf(AnimatedProps)).call(this));

				if (props.style) {
					props = babelHelpers.extends({}, props, {
						style: new AnimatedStyle(props.style) });
				}
				_this19._props = props;
				_this19._callback = callback;
				_this19.__attach();return _this19;
			}babelHelpers.createClass(AnimatedProps, [{ key: '__getValue', value: function __getValue() {
					var props = {};
					for (var key in this._props) {
						var value = this._props[key];
						if (value instanceof Animated) {
							if (!value.__isNative || value instanceof AnimatedStyle) {

								props[key] = value.__getValue();
							}
						} else {
							props[key] = value;
						}
					}
					return props;
				} }, { key: '__getAnimatedValue', value: function __getAnimatedValue() {
					var props = {};
					for (var key in this._props) {
						var value = this._props[key];
						if (value instanceof Animated) {
							props[key] = value.__getAnimatedValue();
						}
					}
					return props;
				} }, { key: '__attach', value: function __attach() {
					for (var key in this._props) {
						var value = this._props[key];
						if (value instanceof Animated) {
							value.__addChild(this);
						}
					}
				} }, { key: '__detach', value: function __detach() {
					if (this.__isNative && this._animatedView) {
						this.__disconnectAnimatedView();
					}
					for (var key in this._props) {
						var value = this._props[key];
						if (value instanceof Animated) {
							value.__removeChild(this);
						}
					}
					babelHelpers.get(AnimatedProps.prototype.__proto__ || Object.getPrototypeOf(AnimatedProps.prototype), '__detach', this).call(this);
				} }, { key: 'update', value: function update() {
					this._callback();
				} }, { key: '__makeNative', value: function __makeNative() {
					if (!this.__isNative) {
						this.__isNative = true;
						for (var key in this._props) {
							var value = this._props[key];
							if (value instanceof Animated) {
								value.__makeNative();
							}
						}
						if (this._animatedView) {
							this.__connectAnimatedView();
						}
					}
				} }, { key: 'setNativeView', value: function setNativeView(animatedView) {
					invariant(this._animatedView === undefined, 'Animated view already set.');
					this._animatedView = animatedView;
					if (this.__isNative) {
						this.__connectAnimatedView();
					}
				} }, { key: '__connectAnimatedView', value: function __connectAnimatedView() {
					invariant(this.__isNative, 'Expected node to be marked as "native"');
					var nativeViewTag = findNodeHandle(this._animatedView);
					invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
					NativeAnimatedAPI.connectAnimatedNodeToView(this.__getNativeTag(), nativeViewTag);
				} }, { key: '__disconnectAnimatedView', value: function __disconnectAnimatedView() {
					invariant(this.__isNative, 'Expected node to be marked as "native"');
					var nativeViewTag = findNodeHandle(this._animatedView);
					invariant(nativeViewTag != null, 'Unable to locate attached view in the native tree');
					NativeAnimatedAPI.disconnectAnimatedNodeFromView(this.__getNativeTag(), nativeViewTag);
				} }, { key: '__getNativeConfig', value: function __getNativeConfig() {
					var propsConfig = {};
					for (var propKey in this._props) {
						var value = this._props[propKey];
						if (value instanceof Animated) {
							propsConfig[propKey] = value.__getNativeTag();
						}
					}
					NativeAnimatedHelper.validateProps(propsConfig);
					return {
						type: 'props',
						props: propsConfig };
				} }]);return AnimatedProps;
		}(Animated);

		function createAnimatedComponent(Component) {
			var AnimatedComponent = function (_React$Component) {
				babelHelpers.inherits(AnimatedComponent, _React$Component);

				function AnimatedComponent(props) {
					babelHelpers.classCallCheck(this, AnimatedComponent);var _this20 = babelHelpers.possibleConstructorReturn(this, (AnimatedComponent.__proto__ || Object.getPrototypeOf(AnimatedComponent)).call(this, props));
					_this20._setComponentRef = _this20._setComponentRef.bind(_this20);return _this20;
				}babelHelpers.createClass(AnimatedComponent, [{ key: 'componentWillUnmount', value: function componentWillUnmount() {
						this._propsAnimated && this._propsAnimated.__detach();
					} }, { key: 'setNativeProps', value: function setNativeProps(props) {
						this._component.setNativeProps(props);
					} }, { key: 'componentWillMount', value: function componentWillMount() {
						this.attachProps(this.props);
					} }, { key: 'componentDidMount', value: function componentDidMount() {
						this._propsAnimated.setNativeView(this._component);
					} }, { key: 'attachProps', value: function attachProps(nextProps) {
						var _this21 = this;
						var oldPropsAnimated = this._propsAnimated;

						var callback = function callback() {
							if (_this21._component.setNativeProps) {
								if (!_this21._propsAnimated.__isNative) {
									_this21._component.setNativeProps(_this21._propsAnimated.__getAnimatedValue());
								} else {
									throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to "native" earlier by starting an ' + 'animation with `useNativeDriver: true`');
								}
							} else {
								_this21.forceUpdate();
							}
						};

						this._propsAnimated = new AnimatedProps(nextProps, callback);

						if (this._component) {
							this._propsAnimated.setNativeView(this._component);
						}

						oldPropsAnimated && oldPropsAnimated.__detach();
					} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(nextProps) {
						this.attachProps(nextProps);
					} }, { key: 'render', value: function render() {
						return React.createElement(Component, babelHelpers.extends({}, this._propsAnimated.__getValue(), {
							ref: this._setComponentRef }));
					} }, { key: '_setComponentRef', value: function _setComponentRef(c) {
						this._component = c;
					} }]);return AnimatedComponent;
			}(React.Component);

			AnimatedComponent.propTypes = {
				style: function style(props, propName, componentName) {
					if (!Component.propTypes) {
						return;
					}

					for (var key in ViewStylePropTypes) {
						if (!Component.propTypes[key] && props[key] !== undefined) {
							console.warn('You are setting the style `{ ' + key + ': ... }` as a prop. You ' + 'should nest it in a style object. ' + 'E.g. `{ style: { ' + key + ': ... } }`');
						}
					}
				} };

			return AnimatedComponent;
		}var AnimatedTracking = function (_Animated3) {
			babelHelpers.inherits(AnimatedTracking, _Animated3);

			function AnimatedTracking(value, parent, animationClass, animationConfig, callback) {
				babelHelpers.classCallCheck(this, AnimatedTracking);var _this22 = babelHelpers.possibleConstructorReturn(this, (AnimatedTracking.__proto__ || Object.getPrototypeOf(AnimatedTracking)).call(this));

				_this22._value = value;
				_this22._parent = parent;
				_this22._animationClass = animationClass;
				_this22._animationConfig = animationConfig;
				_this22._callback = callback;
				_this22.__attach();return _this22;
			}babelHelpers.createClass(AnimatedTracking, [{ key: '__getValue', value: function __getValue() {
					return this._parent.__getValue();
				} }, { key: '__attach', value: function __attach() {
					this._parent.__addChild(this);
				} }, { key: '__detach', value: function __detach() {
					this._parent.__removeChild(this);
					babelHelpers.get(AnimatedTracking.prototype.__proto__ || Object.getPrototypeOf(AnimatedTracking.prototype), '__detach', this).call(this);
				} }, { key: 'update', value: function update() {
					this._value.animate(new this._animationClass(babelHelpers.extends({}, this._animationConfig, {
						toValue: this._animationConfig.toValue.__getValue() })), this._callback);
				} }]);return AnimatedTracking;
		}(Animated);

		var add = function add(a, b) {
			return new AnimatedAddition(a, b);
		};

		var multiply = function multiply(a, b) {
			return new AnimatedMultiplication(a, b);
		};

		var modulo = function modulo(a, modulus) {
			return new AnimatedModulo(a, modulus);
		};

		var _combineCallbacks = function _combineCallbacks(callback, config) {
			if (callback && config.onComplete) {
				return function () {
					config.onComplete && config.onComplete.apply(config, arguments);
					callback && callback.apply(undefined, arguments);
				};
			} else {
				return callback || config.onComplete;
			}
		};

		var maybeVectorAnim = function maybeVectorAnim(value, config, anim) {
			if (value instanceof AnimatedValueXY) {
				var configX = babelHelpers.extends({}, config);
				var configY = babelHelpers.extends({}, config);
				for (var key in config) {
					var _config$key = config[key],
					    x = _config$key.x,
					    y = _config$key.y;
					if (x !== undefined && y !== undefined) {
						configX[key] = x;
						configY[key] = y;
					}
				}
				var aX = anim(value.x, configX);
				var aY = anim(value.y, configY);

				return parallel([aX, aY], { stopTogether: false });
			}
			return null;
		};

		var spring = function spring(value, config) {
			return maybeVectorAnim(value, config, spring) || {
				start: function start(callback) {
					callback = _combineCallbacks(callback, config);
					var singleValue = value;
					var singleConfig = config;
					singleValue.stopTracking();
					if (config.toValue instanceof Animated) {
						singleValue.track(new AnimatedTracking(singleValue, config.toValue, SpringAnimation, singleConfig, callback));
					} else {
						singleValue.animate(new SpringAnimation(singleConfig), callback);
					}
				},

				stop: function stop() {
					value.stopAnimation();
				} };
		};

		var timing = function timing(value, config) {
			return maybeVectorAnim(value, config, timing) || {
				start: function start(callback) {
					callback = _combineCallbacks(callback, config);
					var singleValue = value;
					var singleConfig = config;
					singleValue.stopTracking();
					if (config.toValue instanceof Animated) {
						singleValue.track(new AnimatedTracking(singleValue, config.toValue, TimingAnimation, singleConfig, callback));
					} else {
						singleValue.animate(new TimingAnimation(singleConfig), callback);
					}
				},

				stop: function stop() {
					value.stopAnimation();
				} };
		};

		var decay = function decay(value, config) {
			return maybeVectorAnim(value, config, decay) || {
				start: function start(callback) {
					callback = _combineCallbacks(callback, config);
					var singleValue = value;
					var singleConfig = config;
					singleValue.stopTracking();
					singleValue.animate(new DecayAnimation(singleConfig), callback);
				},

				stop: function stop() {
					value.stopAnimation();
				} };
		};

		var sequence = function sequence(animations) {
			var current = 0;
			return {
				start: function start(callback) {
					var onComplete = function onComplete(result) {
						if (!result.finished) {
							callback && callback(result);
							return;
						}

						current++;

						if (current === animations.length) {
							callback && callback(result);
							return;
						}

						animations[current].start(onComplete);
					};

					if (animations.length === 0) {
						callback && callback({ finished: true });
					} else {
						animations[current].start(onComplete);
					}
				},

				stop: function stop() {
					if (current < animations.length) {
						animations[current].stop();
					}
				} };
		};

		var parallel = function parallel(animations, config) {
			var doneCount = 0;

			var hasEnded = {};
			var stopTogether = !(config && config.stopTogether === false);

			var result = {
				start: function start(callback) {
					if (doneCount === animations.length) {
						callback && callback({ finished: true });
						return;
					}

					animations.forEach(function (animation, idx) {
						var cb = function cb(endResult) {
							hasEnded[idx] = true;
							doneCount++;
							if (doneCount === animations.length) {
								doneCount = 0;
								callback && callback(endResult);
								return;
							}

							if (!endResult.finished && stopTogether) {
								result.stop();
							}
						};

						if (!animation) {
							cb({ finished: true });
						} else {
							animation.start(cb);
						}
					});
				},

				stop: function stop() {
					animations.forEach(function (animation, idx) {
						!hasEnded[idx] && animation.stop();
						hasEnded[idx] = true;
					});
				} };

			return result;
		};

		var delay = function delay(time) {

			return timing(new AnimatedValue(0), { toValue: 0, delay: time, duration: 0 });
		};

		var stagger = function stagger(time, animations) {
			return parallel(animations.map(function (animation, i) {
				return sequence([delay(time * i), animation]);
			}));
		};

		var event = function event(argMapping, config) {
			return function () {
				for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}
				var traverse = function traverse(recMapping, recEvt, key) {
					if (typeof recEvt === 'number') {
						invariant(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');

						recMapping.setValue(recEvt);
						return;
					}
					invariant(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);

					invariant(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);

					for (var key in recMapping) {
						traverse(recMapping[key], recEvt[key], key);
					}
				};
				argMapping.forEach(function (mapping, idx) {
					traverse(mapping, args[idx], 'arg' + idx);
				});
				if (config && config.listener) {
					config.listener.apply(null, args);
				}
			};
		};

		module.exports = {

			Value: AnimatedValue,

			ValueXY: AnimatedValueXY,

			decay: decay,

			timing: timing,

			spring: spring,

			add: add,

			multiply: multiply,

			modulo: modulo,

			delay: delay,

			sequence: sequence,

			parallel: parallel,

			stagger: stagger,

			event: event,

			createAnimatedComponent: createAnimatedComponent,

			__PropsOnlyForTests: AnimatedProps };
	}, // Libraries/Animated/src/Interpolation.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var normalizeColor = require('react-native@0.33/Libraries/StyleSheet/normalizeColor.js');

		var linear = function linear(t) {
			return t;
		};var Interpolation = function () {
			function Interpolation() {
				babelHelpers.classCallCheck(this, Interpolation);
			}babelHelpers.createClass(Interpolation, null, [{ key: 'create', value: function create(config) {

					if (config.outputRange && typeof config.outputRange[0] === 'string') {
						return createInterpolationFromStringOutputRange(config);
					}

					var outputRange = config.outputRange;
					checkInfiniteRange('outputRange', outputRange);

					var inputRange = config.inputRange;
					checkInfiniteRange('inputRange', inputRange);
					checkValidInputRange(inputRange);

					invariant(inputRange.length === outputRange.length, 'inputRange (' + inputRange.length + ') and outputRange (' + outputRange.length + ') must have the same length');

					var easing = config.easing || linear;

					var extrapolateLeft = 'extend';
					if (config.extrapolateLeft !== undefined) {
						extrapolateLeft = config.extrapolateLeft;
					} else if (config.extrapolate !== undefined) {
						extrapolateLeft = config.extrapolate;
					}

					var extrapolateRight = 'extend';
					if (config.extrapolateRight !== undefined) {
						extrapolateRight = config.extrapolateRight;
					} else if (config.extrapolate !== undefined) {
						extrapolateRight = config.extrapolate;
					}

					return function (input) {
						invariant(typeof input === 'number', 'Cannot interpolation an input which is not a number');

						var range = findRange(input, inputRange);
						return interpolate(input, inputRange[range], inputRange[range + 1], outputRange[range], outputRange[range + 1], easing, extrapolateLeft, extrapolateRight);
					};
				} }]);return Interpolation;
		}();

		function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight) {
			var result = input;

			if (result < inputMin) {
				if (extrapolateLeft === 'identity') {
					return result;
				} else if (extrapolateLeft === 'clamp') {
					result = inputMin;
				} else if (extrapolateLeft === 'extend') {}
			}

			if (result > inputMax) {
				if (extrapolateRight === 'identity') {
					return result;
				} else if (extrapolateRight === 'clamp') {
					result = inputMax;
				} else if (extrapolateRight === 'extend') {}
			}

			if (outputMin === outputMax) {
				return outputMin;
			}

			if (inputMin === inputMax) {
				if (input <= inputMin) {
					return outputMin;
				}
				return outputMax;
			}

			if (inputMin === -Infinity) {
				result = -result;
			} else if (inputMax === Infinity) {
				result = result - inputMin;
			} else {
				result = (result - inputMin) / (inputMax - inputMin);
			}

			result = easing(result);

			if (outputMin === -Infinity) {
				result = -result;
			} else if (outputMax === Infinity) {
				result = result + outputMin;
			} else {
				result = result * (outputMax - outputMin) + outputMin;
			}

			return result;
		}

		function colorToRgba(input) {
			var int32Color = normalizeColor(input);
			if (int32Color === null) {
				return input;
			}

			int32Color = int32Color || 0;

			var r = (int32Color & 0xff000000) >>> 24;
			var g = (int32Color & 0x00ff0000) >>> 16;
			var b = (int32Color & 0x0000ff00) >>> 8;
			var a = (int32Color & 0x000000ff) / 255;

			return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
		}

		var stringShapeRegex = /[0-9\.-]+/g;

		function createInterpolationFromStringOutputRange(config) {
			var outputRange = config.outputRange;
			invariant(outputRange.length >= 2, 'Bad output range');
			outputRange = outputRange.map(colorToRgba);
			checkPattern(outputRange);

			var outputRanges = outputRange[0].match(stringShapeRegex).map(function () {
				return [];
			});
			outputRange.forEach(function (value) {

				value.match(stringShapeRegex).forEach(function (number, i) {
					outputRanges[i].push(+number);
				});
			});

			var interpolations = outputRange[0].match(stringShapeRegex).map(function (value, i) {
				return Interpolation.create(babelHelpers.extends({}, config, {
					outputRange: outputRanges[i] }));
			});

			var shouldRound = isRgbOrRgba(outputRange[0]);

			return function (input) {
				var i = 0;

				return outputRange[0].replace(stringShapeRegex, function () {
					var val = +interpolations[i++](input);
					var rounded = shouldRound && i < 4 ? Math.round(val) : Math.round(val * 1000) / 1000;
					return String(rounded);
				});
			};
		}

		function isRgbOrRgba(range) {
			return typeof range === 'string' && range.startsWith('rgb');
		}

		function checkPattern(arr) {
			var pattern = arr[0].replace(stringShapeRegex, '');
			for (var i = 1; i < arr.length; ++i) {
				invariant(pattern === arr[i].replace(stringShapeRegex, ''), 'invalid pattern ' + arr[0] + ' and ' + arr[i]);
			}
		}

		function findRange(input, inputRange) {
			for (var i = 1; i < inputRange.length - 1; ++i) {
				if (inputRange[i] >= input) {
					break;
				}
			}
			return i - 1;
		}

		function checkValidInputRange(arr) {
			invariant(arr.length >= 2, 'inputRange must have at least 2 elements');
			for (var i = 1; i < arr.length; ++i) {
				invariant(arr[i] >= arr[i - 1], 'inputRange must be monotonically increasing ' + arr);
			}
		}

		function checkInfiniteRange(name, arr) {
			invariant(arr.length >= 2, name + ' must have at least 2 elements');
			invariant(arr.length !== 2 || arr[0] !== -Infinity || arr[1] !== Infinity, name + 'cannot be ]-infinity;+infinity[ ' + arr);
		}

		module.exports = Interpolation;
	}, // Libraries/Animated/src/SpringConfig.js
	function (__inner_require__, exports, module) {
		function tensionFromOrigamiValue(oValue) {
			return (oValue - 30) * 3.62 + 194;
		}

		function frictionFromOrigamiValue(oValue) {
			return (oValue - 8) * 3 + 25;
		}

		function fromOrigamiTensionAndFriction(tension, friction) {
			return {
				tension: tensionFromOrigamiValue(tension),
				friction: frictionFromOrigamiValue(friction) };
		}

		function fromBouncinessAndSpeed(bounciness, speed) {
			function normalize(value, startValue, endValue) {
				return (value - startValue) / (endValue - startValue);
			}

			function projectNormal(n, start, end) {
				return start + n * (end - start);
			}

			function linearInterpolation(t, start, end) {
				return t * end + (1 - t) * start;
			}

			function quadraticOutInterpolation(t, start, end) {
				return linearInterpolation(2 * t - t * t, start, end);
			}

			function b3Friction1(x) {
				return 0.0007 * Math.pow(x, 3) - 0.031 * Math.pow(x, 2) + 0.64 * x + 1.28;
			}

			function b3Friction2(x) {
				return 0.000044 * Math.pow(x, 3) - 0.006 * Math.pow(x, 2) + 0.36 * x + 2;
			}

			function b3Friction3(x) {
				return 0.00000045 * Math.pow(x, 3) - 0.000332 * Math.pow(x, 2) + 0.1078 * x + 5.84;
			}

			function b3Nobounce(tension) {
				if (tension <= 18) {
					return b3Friction1(tension);
				} else if (tension > 18 && tension <= 44) {
					return b3Friction2(tension);
				} else {
					return b3Friction3(tension);
				}
			}

			var b = normalize(bounciness / 1.7, 0, 20);
			b = projectNormal(b, 0, 0.8);
			var s = normalize(speed / 1.7, 0, 20);
			var bouncyTension = projectNormal(s, 0.5, 200);
			var bouncyFriction = quadraticOutInterpolation(b, b3Nobounce(bouncyTension), 0.01);

			return {
				tension: tensionFromOrigamiValue(bouncyTension),
				friction: frictionFromOrigamiValue(bouncyFriction) };
		}

		module.exports = {
			fromOrigamiTensionAndFriction: fromOrigamiTensionAndFriction,
			fromBouncinessAndSpeed: fromBouncinessAndSpeed };
	}, // Libraries/Animated/src/NativeAnimatedHelper.js
	function (__inner_require__, exports, module) {
		var NativeAnimatedModule = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').NativeAnimatedModule;
		var NativeEventEmitter = require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var __nativeAnimatedNodeTagCount = 1;
		var __nativeAnimationIdCount = 1;

		var nativeEventEmitter = void 0;

		var API = {
			createAnimatedNode: function createAnimatedNode(tag, config) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.createAnimatedNode(tag, config);
			},
			startListeningToAnimatedNodeValue: function startListeningToAnimatedNodeValue(tag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.startListeningToAnimatedNodeValue(tag);
			},
			stopListeningToAnimatedNodeValue: function stopListeningToAnimatedNodeValue(tag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.stopListeningToAnimatedNodeValue(tag);
			},
			connectAnimatedNodes: function connectAnimatedNodes(parentTag, childTag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.connectAnimatedNodes(parentTag, childTag);
			},
			disconnectAnimatedNodes: function disconnectAnimatedNodes(parentTag, childTag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.disconnectAnimatedNodes(parentTag, childTag);
			},
			startAnimatingNode: function startAnimatingNode(animationId, nodeTag, config, endCallback) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.startAnimatingNode(animationId, nodeTag, config, endCallback);
			},
			stopAnimation: function stopAnimation(animationId) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.stopAnimation(animationId);
			},
			setAnimatedNodeValue: function setAnimatedNodeValue(nodeTag, value) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.setAnimatedNodeValue(nodeTag, value);
			},
			connectAnimatedNodeToView: function connectAnimatedNodeToView(nodeTag, viewTag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.connectAnimatedNodeToView(nodeTag, viewTag);
			},
			disconnectAnimatedNodeFromView: function disconnectAnimatedNodeFromView(nodeTag, viewTag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.disconnectAnimatedNodeFromView(nodeTag, viewTag);
			},
			dropAnimatedNode: function dropAnimatedNode(tag) {
				assertNativeAnimatedModule();
				NativeAnimatedModule.dropAnimatedNode(tag);
			} };

		var PROPS_WHITELIST = {
			style: {
				opacity: true,
				transform: true,

				scaleX: true,
				scaleY: true,
				translateX: true,
				translateY: true } };

		var TRANSFORM_WHITELIST = {
			translateX: true,
			translateY: true,
			scale: true,
			scaleX: true,
			scaleY: true,
			rotate: true,
			rotateX: true,
			rotateY: true,
			perspective: true };

		function validateProps(params) {
			for (var key in params) {
				if (!PROPS_WHITELIST.hasOwnProperty(key)) {
					throw new Error('Property \'' + key + '\' is not supported by native animated module');
				}
			}
		}

		function validateTransform(configs) {
			configs.forEach(function (config) {
				if (!TRANSFORM_WHITELIST.hasOwnProperty(config.property)) {
					throw new Error('Property \'' + config.property + '\' is not supported by native animated module');
				}
			});
		}

		function validateStyles(styles) {
			var STYLES_WHITELIST = PROPS_WHITELIST.style || {};
			for (var key in styles) {
				if (!STYLES_WHITELIST.hasOwnProperty(key)) {
					throw new Error('Style property \'' + key + '\' is not supported by native animated module');
				}
			}
		}

		function validateInterpolation(config) {
			var SUPPORTED_INTERPOLATION_PARAMS = {
				inputRange: true,
				outputRange: true };

			for (var key in config) {
				if (!SUPPORTED_INTERPOLATION_PARAMS.hasOwnProperty(key)) {
					throw new Error('Interpolation property \'' + key + '\' is not supported by native animated module');
				}
			}
		}

		function generateNewNodeTag() {
			return __nativeAnimatedNodeTagCount++;
		}

		function generateNewAnimationId() {
			return __nativeAnimationIdCount++;
		}

		function assertNativeAnimatedModule() {
			invariant(NativeAnimatedModule, 'Native animated module is not available');
		}

		module.exports = {
			API: API,
			validateProps: validateProps,
			validateStyles: validateStyles,
			validateTransform: validateTransform,
			validateInterpolation: validateInterpolation,
			generateNewNodeTag: generateNewNodeTag,
			generateNewAnimationId: generateNewAnimationId,
			assertNativeAnimatedModule: assertNativeAnimatedModule,
			get nativeEventEmitter() {
				if (!nativeEventEmitter) {
					nativeEventEmitter = new NativeEventEmitter(NativeAnimatedModule);
				}
				return nativeEventEmitter;
			} };
	}, // __fbjs__/lib/requestAnimationFrame.js
	function (__inner_require__, exports, module) {
		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var nativeRequestAnimationFrame = __inner_require__(165 /*__fbjs__/lib/nativeRequestAnimationFrame.js*/);

		var lastTime = 0;

		var requestAnimationFrame = nativeRequestAnimationFrame || function (callback) {
			var currTime = Date.now();
			var timeDelay = Math.max(0, 16 - (currTime - lastTime));
			lastTime = currTime + timeDelay;
			return global.setTimeout(function () {
				callback(Date.now());
			}, timeDelay);
		};

		requestAnimationFrame(emptyFunction);

		module.exports = requestAnimationFrame;
	}, // __fbjs__/lib/nativeRequestAnimationFrame.js
	function (__inner_require__, exports, module) {
		var nativeRequestAnimationFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame || global.msRequestAnimationFrame;

		module.exports = nativeRequestAnimationFrame;
	}, // Libraries/Animated/src/Easing.js
	function (__inner_require__, exports, module) {
		var _ease = void 0;var Easing = function () {
			function Easing() {
				babelHelpers.classCallCheck(this, Easing);
			}babelHelpers.createClass(Easing, null, [{ key: 'step0', value: function step0(n) {
					return n > 0 ? 1 : 0;
				} }, { key: 'step1', value: function step1(n) {
					return n >= 1 ? 1 : 0;
				} }, { key: 'linear', value: function linear(t) {
					return t;
				} }, { key: 'ease', value: function ease(t) {
					if (!_ease) {
						_ease = Easing.bezier(0.42, 0, 1, 1);
					}
					return _ease(t);
				} }, { key: 'quad', value: function quad(t) {
					return t * t;
				} }, { key: 'cubic', value: function cubic(t) {
					return t * t * t;
				} }, { key: 'poly', value: function poly(n) {
					return function (t) {
						return Math.pow(t, n);
					};
				} }, { key: 'sin', value: function sin(t) {
					return 1 - Math.cos(t * Math.PI / 2);
				} }, { key: 'circle', value: function circle(t) {
					return 1 - Math.sqrt(1 - t * t);
				} }, { key: 'exp', value: function exp(t) {
					return Math.pow(2, 10 * (t - 1));
				} }, { key: 'elastic', value: function elastic() {
					var bounciness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
					var p = bounciness * Math.PI;
					return function (t) {
						return 1 - Math.pow(Math.cos(t * Math.PI / 2), 3) * Math.cos(t * p);
					};
				} }, { key: 'back', value: function back(s) {
					if (s === undefined) {
						s = 1.70158;
					}
					return function (t) {
						return t * t * ((s + 1) * t - s);
					};
				} }, { key: 'bounce', value: function bounce(t) {
					if (t < 1 / 2.75) {
						return 7.5625 * t * t;
					}

					if (t < 2 / 2.75) {
						t -= 1.5 / 2.75;
						return 7.5625 * t * t + 0.75;
					}

					if (t < 2.5 / 2.75) {
						t -= 2.25 / 2.75;
						return 7.5625 * t * t + 0.9375;
					}

					t -= 2.625 / 2.75;
					return 7.5625 * t * t + 0.984375;
				} }, { key: 'bezier', value: function bezier(x1, y1, x2, y2) {
					var _bezier = __inner_require__(167 /*Libraries/Animated/src/bezier.js*/);
					return _bezier(x1, y1, x2, y2);
				} }, { key: 'in', value: function _in(easing) {
					return easing;
				} }, { key: 'out', value: function out(easing) {
					return function (t) {
						return 1 - easing(1 - t);
					};
				} }, { key: 'inOut', value: function inOut(easing) {
					return function (t) {
						if (t < 0.5) {
							return easing(t * 2) / 2;
						}
						return 1 - easing((1 - t) * 2) / 2;
					};
				} }]);return Easing;
		}();

		module.exports = Easing;
	}, // Libraries/Animated/src/bezier.js
	function (__inner_require__, exports, module) {
		var NEWTON_ITERATIONS = 4;
		var NEWTON_MIN_SLOPE = 0.001;
		var SUBDIVISION_PRECISION = 0.0000001;
		var SUBDIVISION_MAX_ITERATIONS = 10;

		var kSplineTableSize = 11;
		var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

		var float32ArraySupported = typeof Float32Array === 'function';

		function A(aA1, aA2) {
			return 1.0 - 3.0 * aA2 + 3.0 * aA1;
		}
		function B(aA1, aA2) {
			return 3.0 * aA2 - 6.0 * aA1;
		}
		function C(aA1) {
			return 3.0 * aA1;
		}

		function calcBezier(aT, aA1, aA2) {
			return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
		}

		function getSlope(aT, aA1, aA2) {
			return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
		}

		function binarySubdivide(aX, aA, aB, mX1, mX2) {
			var currentX,
			    currentT,
			    i = 0;
			do {
				currentT = aA + (aB - aA) / 2.0;
				currentX = calcBezier(currentT, mX1, mX2) - aX;
				if (currentX > 0.0) {
					aB = currentT;
				} else {
					aA = currentT;
				}
			} while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
			return currentT;
		}

		function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
			for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
				var currentSlope = getSlope(aGuessT, mX1, mX2);
				if (currentSlope === 0.0) {
					return aGuessT;
				}
				var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
				aGuessT -= currentX / currentSlope;
			}
			return aGuessT;
		}

		module.exports = function bezier(mX1, mY1, mX2, mY2) {
			if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
				throw new Error('bezier x values must be in [0, 1] range');
			}

			var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
			if (mX1 !== mY1 || mX2 !== mY2) {
				for (var i = 0; i < kSplineTableSize; ++i) {
					sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
				}
			}

			function getTForX(aX) {
				var intervalStart = 0.0;
				var currentSample = 1;
				var lastSample = kSplineTableSize - 1;

				for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
					intervalStart += kSampleStepSize;
				}
				--currentSample;

				var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
				var guessForT = intervalStart + dist * kSampleStepSize;

				var initialSlope = getSlope(guessForT, mX1, mX2);
				if (initialSlope >= NEWTON_MIN_SLOPE) {
					return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
				} else if (initialSlope === 0.0) {
					return guessForT;
				} else {
					return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
				}
			}

			return function BezierEasing(x) {
				if (mX1 === mY1 && mX2 === mY2) {
					return x;
				}

				if (x === 0) {
					return 0;
				}
				if (x === 1) {
					return 1;
				}
				return calcBezier(getTForX(x), mY1, mY2);
			};
		};
	}, // Libraries/Text/Text.js
	function (__inner_require__, exports, module) {
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNativeViewAttributes = __inner_require__(49 /*Libraries/Components/View/ReactNativeViewAttributes.js*/);
		var StyleSheetPropType = __inner_require__(50 /*Libraries/StyleSheet/StyleSheetPropType.js*/);
		var TextStylePropTypes = __inner_require__(36 /*Libraries/Text/TextStylePropTypes.js*/);
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);

		var createReactNativeComponentClass = __inner_require__(53 /*__react__/lib/createReactNativeComponentClass.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);

		var stylePropType = StyleSheetPropType(TextStylePropTypes);

		var viewConfig = {
			validAttributes: merge(ReactNativeViewAttributes.UIView, {
				isHighlighted: true,
				numberOfLines: true,
				ellipsizeMode: true,
				allowFontScaling: true,
				selectable: true,
				adjustsFontSizeToFit: true,
				minimumFontScale: true }),

			uiViewClassName: 'RCTText' };

		var Text = React.createClass({ displayName: 'Text',
			propTypes: {

				ellipsizeMode: React.PropTypes.oneOf(['head', 'middle', 'tail', 'clip']),

				numberOfLines: React.PropTypes.number,

				onLayout: React.PropTypes.func,

				onPress: React.PropTypes.func,

				onLongPress: React.PropTypes.func,

				selectable: React.PropTypes.bool,

				suppressHighlighting: React.PropTypes.bool,
				style: stylePropType,

				testID: React.PropTypes.string,

				allowFontScaling: React.PropTypes.bool,

				accessible: React.PropTypes.bool,

				adjustsFontSizeToFit: React.PropTypes.bool,

				minimumFontScale: React.PropTypes.number },

			getDefaultProps: function getDefaultProps() {
				return {
					accessible: true,
					allowFontScaling: true,
					ellipsizeMode: 'tail' };
			},
			getInitialState: function getInitialState() {
				return merge(Touchable.Mixin.touchableGetInitialState(), {
					isHighlighted: false });
			},
			mixins: [NativeMethodsMixin],
			viewConfig: viewConfig,
			getChildContext: function getChildContext() {
				return { isInAParentText: true };
			},
			childContextTypes: {
				isInAParentText: React.PropTypes.bool },

			contextTypes: {
				isInAParentText: React.PropTypes.bool },

			_handlers: null,
			_hasPressHandler: function _hasPressHandler() {
				return !!this.props.onPress || !!this.props.onLongPress;
			},

			touchableHandleActivePressIn: null,
			touchableHandleActivePressOut: null,
			touchableHandlePress: null,
			touchableHandleLongPress: null,
			touchableGetPressRectOffset: null,
			render: function render() {
				var _this = this;
				var newProps = this.props;
				if (this.props.onStartShouldSetResponder || this._hasPressHandler()) {
					if (!this._handlers) {
						this._handlers = {
							onStartShouldSetResponder: function onStartShouldSetResponder() {
								var shouldSetFromProps = _this.props.onStartShouldSetResponder && _this.props.onStartShouldSetResponder();
								var setResponder = shouldSetFromProps || _this._hasPressHandler();
								if (setResponder && !_this.touchableHandleActivePressIn) {

									for (var key in Touchable.Mixin) {
										if (typeof Touchable.Mixin[key] === 'function') {
											_this[key] = Touchable.Mixin[key].bind(_this);
										}
									}
									_this.touchableHandleActivePressIn = function () {
										if (_this.props.suppressHighlighting || !_this._hasPressHandler()) {
											return;
										}
										_this.setState({
											isHighlighted: true });
									};

									_this.touchableHandleActivePressOut = function () {
										if (_this.props.suppressHighlighting || !_this._hasPressHandler()) {
											return;
										}
										_this.setState({
											isHighlighted: false });
									};

									_this.touchableHandlePress = function () {
										_this.props.onPress && _this.props.onPress();
									};

									_this.touchableHandleLongPress = function () {
										_this.props.onLongPress && _this.props.onLongPress();
									};

									_this.touchableGetPressRectOffset = function () {
										return PRESS_RECT_OFFSET;
									};
								}
								return setResponder;
							},
							onResponderGrant: function (e, dispatchID) {
								this.touchableHandleResponderGrant(e, dispatchID);
								this.props.onResponderGrant && this.props.onResponderGrant.apply(this, arguments);
							}.bind(this),
							onResponderMove: function (e) {
								this.touchableHandleResponderMove(e);
								this.props.onResponderMove && this.props.onResponderMove.apply(this, arguments);
							}.bind(this),
							onResponderRelease: function (e) {
								this.touchableHandleResponderRelease(e);
								this.props.onResponderRelease && this.props.onResponderRelease.apply(this, arguments);
							}.bind(this),
							onResponderTerminate: function (e) {
								this.touchableHandleResponderTerminate(e);
								this.props.onResponderTerminate && this.props.onResponderTerminate.apply(this, arguments);
							}.bind(this),
							onResponderTerminationRequest: function () {

								var allowTermination = this.touchableHandleResponderTerminationRequest();
								if (allowTermination && this.props.onResponderTerminationRequest) {
									allowTermination = this.props.onResponderTerminationRequest.apply(this, arguments);
								}
								return allowTermination;
							}.bind(this) };
					}
					newProps = babelHelpers.extends({}, this.props, this._handlers, {
						isHighlighted: this.state.isHighlighted });
				}
				if (Touchable.TOUCH_TARGET_DEBUG && newProps.onPress) {
					newProps = babelHelpers.extends({}, newProps, {
						style: [this.props.style, { color: 'magenta' }] });
				}
				if (this.context.isInAParentText) {
					return React.createElement(RCTVirtualText, newProps);
				} else {
					return React.createElement(RCTText, newProps);
				}
			} });

		var PRESS_RECT_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };

		var RCTText = createReactNativeComponentClass(viewConfig);
		var RCTVirtualText = RCTText;

		if (Platform.OS === 'android') {
			RCTVirtualText = createReactNativeComponentClass({
				validAttributes: merge(ReactNativeViewAttributes.UIView, {
					isHighlighted: true }),

				uiViewClassName: 'RCTVirtualText' });
		}

		module.exports = Text;
	}, // Libraries/Components/Touchable/Touchable.js
	function (__inner_require__, exports, module) {
		var BoundingDimensions = __inner_require__(170 /*Libraries/Components/Touchable/BoundingDimensions.js*/);
		var Position = __inner_require__(171 /*Libraries/Components/Touchable/Position.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var TouchEventUtils = __inner_require__(172 /*__fbjs__/lib/TouchEventUtils.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');
		var normalizeColor = require('react-native@0.33/Libraries/StyleSheet/normalizeColor.js');
		var queryLayoutByID = __inner_require__(173 /*Libraries/RKBackendNode/queryLayoutByID.js*/);

		var States = keyMirror({
			NOT_RESPONDER: null,
			RESPONDER_INACTIVE_PRESS_IN: null,
			RESPONDER_INACTIVE_PRESS_OUT: null,
			RESPONDER_ACTIVE_PRESS_IN: null,
			RESPONDER_ACTIVE_PRESS_OUT: null,
			RESPONDER_ACTIVE_LONG_PRESS_IN: null,
			RESPONDER_ACTIVE_LONG_PRESS_OUT: null,
			ERROR: null });

		var IsActive = {
			RESPONDER_ACTIVE_PRESS_OUT: true,
			RESPONDER_ACTIVE_PRESS_IN: true };

		var IsPressingIn = {
			RESPONDER_INACTIVE_PRESS_IN: true,
			RESPONDER_ACTIVE_PRESS_IN: true,
			RESPONDER_ACTIVE_LONG_PRESS_IN: true };

		var IsLongPressingIn = {
			RESPONDER_ACTIVE_LONG_PRESS_IN: true };

		var Signals = keyMirror({
			DELAY: null,
			RESPONDER_GRANT: null,
			RESPONDER_RELEASE: null,
			RESPONDER_TERMINATED: null,
			ENTER_PRESS_RECT: null,
			LEAVE_PRESS_RECT: null,
			LONG_PRESS_DETECTED: null });

		var Transitions = {
			NOT_RESPONDER: {
				DELAY: States.ERROR,
				RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
				RESPONDER_RELEASE: States.ERROR,
				RESPONDER_TERMINATED: States.ERROR,
				ENTER_PRESS_RECT: States.ERROR,
				LEAVE_PRESS_RECT: States.ERROR,
				LONG_PRESS_DETECTED: States.ERROR },

			RESPONDER_INACTIVE_PRESS_IN: {
				DELAY: States.RESPONDER_ACTIVE_PRESS_IN,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
				LONG_PRESS_DETECTED: States.ERROR },

			RESPONDER_INACTIVE_PRESS_OUT: {
				DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,
				LONG_PRESS_DETECTED: States.ERROR },

			RESPONDER_ACTIVE_PRESS_IN: {
				DELAY: States.ERROR,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
				LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN },

			RESPONDER_ACTIVE_PRESS_OUT: {
				DELAY: States.ERROR,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,
				LONG_PRESS_DETECTED: States.ERROR },

			RESPONDER_ACTIVE_LONG_PRESS_IN: {
				DELAY: States.ERROR,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
				LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN },

			RESPONDER_ACTIVE_LONG_PRESS_OUT: {
				DELAY: States.ERROR,
				RESPONDER_GRANT: States.ERROR,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,
				LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,
				LONG_PRESS_DETECTED: States.ERROR },

			error: {
				DELAY: States.NOT_RESPONDER,
				RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,
				RESPONDER_RELEASE: States.NOT_RESPONDER,
				RESPONDER_TERMINATED: States.NOT_RESPONDER,
				ENTER_PRESS_RECT: States.NOT_RESPONDER,
				LEAVE_PRESS_RECT: States.NOT_RESPONDER,
				LONG_PRESS_DETECTED: States.NOT_RESPONDER } };

		var HIGHLIGHT_DELAY_MS = 130;

		var PRESS_EXPAND_PX = 20;

		var LONG_PRESS_THRESHOLD = 500;

		var LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;

		var LONG_PRESS_ALLOWED_MOVEMENT = 10;

		var TouchableMixin = {

			componentWillUnmount: function componentWillUnmount() {
				this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
				this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
				this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
			},

			touchableGetInitialState: function touchableGetInitialState() {
				return {
					touchable: { touchState: undefined, responderID: null } };
			},

			touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {
				return !this.props.rejectResponderTermination;
			},

			touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {
				return !this.props.disabled;
			},

			touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {
				return true;
			},

			touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {
				var dispatchID = e.currentTarget;

				e.persist();

				this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);
				this.pressOutDelayTimeout = null;

				this.state.touchable.touchState = States.NOT_RESPONDER;
				this.state.touchable.responderID = dispatchID;
				this._receiveSignal(Signals.RESPONDER_GRANT, e);
				var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;
				delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;
				if (delayMS !== 0) {
					this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);
				} else {
					this._handleDelay(e);
				}

				var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;
				longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;
				this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);

				return this.props.shouldBlockResponder && this.props.shouldBlockResponder();
			},

			touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {
				this._receiveSignal(Signals.RESPONDER_RELEASE, e);
			},

			touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {
				this._receiveSignal(Signals.RESPONDER_TERMINATED, e);
			},

			touchableHandleResponderMove: function touchableHandleResponderMove(e) {

				if (this.state.touchable.touchState === States.RESPONDER_INACTIVE_PRESS_IN) {
					return;
				}

				if (!this.state.touchable.positionOnActivate) {
					return;
				}

				var positionOnActivate = this.state.touchable.positionOnActivate;
				var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;
				var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {
					left: PRESS_EXPAND_PX,
					right: PRESS_EXPAND_PX,
					top: PRESS_EXPAND_PX,
					bottom: PRESS_EXPAND_PX };

				var pressExpandLeft = pressRectOffset.left;
				var pressExpandTop = pressRectOffset.top;
				var pressExpandRight = pressRectOffset.right;
				var pressExpandBottom = pressRectOffset.bottom;

				var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;

				if (hitSlop) {
					pressExpandLeft += hitSlop.left;
					pressExpandTop += hitSlop.top;
					pressExpandRight += hitSlop.right;
					pressExpandBottom += hitSlop.bottom;
				}

				var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
				var pageX = touch && touch.pageX;
				var pageY = touch && touch.pageY;

				if (this.pressInLocation) {
					var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);
					if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {
						this._cancelLongPressDelayTimeout();
					}
				}

				var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;
				if (isTouchWithinActive) {
					this._receiveSignal(Signals.ENTER_PRESS_RECT, e);
					var curState = this.state.touchable.touchState;
					if (curState === States.RESPONDER_INACTIVE_PRESS_IN) {

						this._cancelLongPressDelayTimeout();
					}
				} else {
					this._cancelLongPressDelayTimeout();
					this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);
				}
			},

			_remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {
				queryLayoutByID(this.state.touchable.responderID, null, this._handleQueryLayout);
			},

			_handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {
				this.state.touchable.positionOnActivate && Position.release(this.state.touchable.positionOnActivate);
				this.state.touchable.dimensionsOnActivate && BoundingDimensions.release(this.state.touchable.dimensionsOnActivate);
				this.state.touchable.positionOnActivate = Position.getPooled(globalX, globalY);
				this.state.touchable.dimensionsOnActivate = BoundingDimensions.getPooled(w, h);
			},

			_handleDelay: function _handleDelay(e) {
				this.touchableDelayTimeout = null;
				this._receiveSignal(Signals.DELAY, e);
			},

			_handleLongDelay: function _handleLongDelay(e) {
				this.longPressDelayTimeout = null;
				var curState = this.state.touchable.touchState;
				if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {
					console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');
				} else {
					this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);
				}
			},

			_receiveSignal: function _receiveSignal(signal, e) {
				var responderID = this.state.touchable.responderID;
				var curState = this.state.touchable.touchState;
				var nextState = Transitions[curState] && Transitions[curState][signal];
				if (!responderID && signal === Signals.RESPONDER_RELEASE) {
					return;
				}
				if (!nextState) {
					throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');
				}
				if (nextState === States.ERROR) {
					throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');
				}
				if (curState !== nextState) {
					this._performSideEffectsForTransition(curState, nextState, signal, e);
					this.state.touchable.touchState = nextState;
				}
			},

			_cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {
				this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);
				this.longPressDelayTimeout = null;
			},

			_isHighlight: function _isHighlight(state) {
				return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;
			},

			_savePressInLocation: function _savePressInLocation(e) {
				var touch = TouchEventUtils.extractSingleTouch(e.nativeEvent);
				var pageX = touch && touch.pageX;
				var pageY = touch && touch.pageY;
				var locationX = touch && touch.locationX;
				var locationY = touch && touch.locationY;
				this.pressInLocation = { pageX: pageX, pageY: pageY, locationX: locationX, locationY: locationY };
			},

			_getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {
				var deltaX = aX - bX;
				var deltaY = aY - bY;
				return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
			},

			_performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {
				var _this = this;
				var curIsHighlight = this._isHighlight(curState);
				var newIsHighlight = this._isHighlight(nextState);

				var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;

				if (isFinalSignal) {
					this._cancelLongPressDelayTimeout();
				}

				if (!IsActive[curState] && IsActive[nextState]) {
					this._remeasureMetricsOnActivation();
				}

				if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {
					this.touchableHandleLongPress && this.touchableHandleLongPress(e);
				}

				if (newIsHighlight && !curIsHighlight) {
					this._savePressInLocation(e);
					this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);
				} else if (!newIsHighlight && curIsHighlight && this.touchableHandleActivePressOut) {
					if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {
						this.pressOutDelayTimeout = setTimeout(function () {
							_this.touchableHandleActivePressOut(e);
						}, this.touchableGetPressOutDelayMS());
					} else {
						this.touchableHandleActivePressOut(e);
					}
				}

				if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {
					var hasLongPressHandler = !!this.props.onLongPress;
					var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && (!hasLongPressHandler || !this.touchableLongPressCancelsPress());

					var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;
					if (shouldInvokePress && this.touchableHandlePress) {
						this.touchableHandlePress(e);
					}
				}

				this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);
				this.touchableDelayTimeout = null;
			} };

		var Touchable = {
			Mixin: TouchableMixin,
			TOUCH_TARGET_DEBUG: false,

			renderDebugView: function renderDebugView(_ref) {
				var color = _ref.color,
				    hitSlop = _ref.hitSlop;
				if (!Touchable.TOUCH_TARGET_DEBUG) {
					return null;
				}
				if (!__DEV__) {
					throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');
				}
				var debugHitSlopStyle = {};
				hitSlop = hitSlop || { top: 0, bottom: 0, left: 0, right: 0 };
				for (var key in hitSlop) {
					debugHitSlopStyle[key] = -hitSlop[key];
				}
				var hexColor = '#' + ('00000000' + normalizeColor(color).toString(16)).substr(-8);
				return React.createElement(View, {
					pointerEvents: 'none',
					style: babelHelpers.extends({
						position: 'absolute',
						borderColor: hexColor.slice(0, -2) + '55',
						borderWidth: 1,
						borderStyle: 'dashed',
						backgroundColor: hexColor.slice(0, -2) + '0F' }, debugHitSlopStyle) });
			} };

		module.exports = Touchable;
	}, // Libraries/Components/Touchable/BoundingDimensions.js
	function (__inner_require__, exports, module) {
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');

		var twoArgumentPooler = PooledClass.twoArgumentPooler;

		function BoundingDimensions(width, height) {
			this.width = width;
			this.height = height;
		}

		BoundingDimensions.prototype.destructor = function () {
			this.width = null;
			this.height = null;
		};

		BoundingDimensions.getPooledFromElement = function (element) {
			return BoundingDimensions.getPooled(element.offsetWidth, element.offsetHeight);
		};

		PooledClass.addPoolingTo(BoundingDimensions, twoArgumentPooler);

		module.exports = BoundingDimensions;
	}, // Libraries/Components/Touchable/Position.js
	function (__inner_require__, exports, module) {
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');

		var twoArgumentPooler = PooledClass.twoArgumentPooler;

		function Position(left, top) {
			this.left = left;
			this.top = top;
		}

		Position.prototype.destructor = function () {
			this.left = null;
			this.top = null;
		};

		PooledClass.addPoolingTo(Position, twoArgumentPooler);

		module.exports = Position;
	}, // __fbjs__/lib/TouchEventUtils.js
	function (__inner_require__, exports, module) {
		var TouchEventUtils = {

			extractSingleTouch: function extractSingleTouch(nativeEvent) {
				var touches = nativeEvent.touches;
				var changedTouches = nativeEvent.changedTouches;
				var hasTouches = touches && touches.length > 0;
				var hasChangedTouches = changedTouches && changedTouches.length > 0;

				return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;
			} };

		module.exports = TouchEventUtils;
	}, // Libraries/RKBackendNode/queryLayoutByID.js
	function (__inner_require__, exports, module) {
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');

		var queryLayoutByID = function queryLayoutByID(tag, onError, onSuccess) {
			if (tag == null) {
				return;
			}

			UIManager.measure(tag, onSuccess);
		};

		module.exports = queryLayoutByID;
	}, // Libraries/Components/SwitchAndroid/SwitchAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Components/SwitchIOS/SwitchIOS.ios.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var SWITCH = 'switch';

		var SwitchIOS = React.createClass({ displayName: 'SwitchIOS',
			mixins: [NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, View.propTypes, {

				value: PropTypes.bool,

				disabled: PropTypes.bool,

				onValueChange: PropTypes.func,

				onTintColor: ColorPropType,

				thumbTintColor: ColorPropType,

				tintColor: ColorPropType }),

			getDefaultProps: function getDefaultProps() {
				return {
					value: false,
					disabled: false };
			},

			_onChange: function _onChange(event) {

				this.refs[SWITCH].setNativeProps({ value: this.props.value });

				if (this.props.value === event.nativeEvent.value || this.props.disabled) {
					return;
				}

				this.props.onChange && this.props.onChange(event);
				this.props.onValueChange && this.props.onValueChange(event.nativeEvent.value);
			},

			render: function render() {
				return React.createElement(RCTSwitch, babelHelpers.extends({}, this.props, {
					ref: SWITCH,
					onChange: this._onChange,
					style: [styles.rkSwitch, this.props.style] }));
			} });

		var styles = StyleSheet.create({
			rkSwitch: {
				height: 31,
				width: 51 } });

		var RCTSwitch = requireNativeComponent('RCTSwitch', SwitchIOS, {
			nativeOnly: { onChange: true } });

		module.exports = SwitchIOS;
	}, // Libraries/Components/TabBarIOS/TabBarIOS.ios.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var TabBarItemIOS = __inner_require__(177 /*Libraries/Components/TabBarIOS/TabBarItemIOS.ios.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);var TabBarIOS = function (_React$Component) {
			babelHelpers.inherits(TabBarIOS, _React$Component);function TabBarIOS() {
				babelHelpers.classCallCheck(this, TabBarIOS);return babelHelpers.possibleConstructorReturn(this, (TabBarIOS.__proto__ || Object.getPrototypeOf(TabBarIOS)).apply(this, arguments));
			}babelHelpers.createClass(TabBarIOS, [{ key: 'render', value: function render() {
					return React.createElement(RCTTabBar, {
						style: [styles.tabGroup, this.props.style],
						unselectedTintColor: this.props.unselectedTintColor,
						tintColor: this.props.tintColor,
						barTintColor: this.props.barTintColor,
						itemPositioning: this.props.itemPositioning,
						translucent: this.props.translucent !== false }, this.props.children);
				} }]);return TabBarIOS;
		}(React.Component);TabBarIOS.Item = TabBarItemIOS;TabBarIOS.propTypes = babelHelpers.extends({}, View.propTypes, { style: View.propTypes.style, unselectedTintColor: ColorPropType, tintColor: ColorPropType, barTintColor: ColorPropType, translucent: React.PropTypes.bool, itemPositioning: React.PropTypes.oneOf(['fill', 'center', 'auto']) });

		var styles = StyleSheet.create({
			tabGroup: {
				flex: 1 } });

		var RCTTabBar = requireNativeComponent('RCTTabBar', TabBarIOS);

		module.exports = TabBarIOS;
	}, // Libraries/Components/TabBarIOS/TabBarItemIOS.ios.js
	function (__inner_require__, exports, module) {
		var Image = __inner_require__(81 /*Libraries/Image/Image.ios.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StaticContainer = __inner_require__(142 /*Libraries/Components/StaticContainer.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);var TabBarItemIOS = function (_React$Component) {
			babelHelpers.inherits(TabBarItemIOS, _React$Component);function TabBarItemIOS() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, TabBarItemIOS);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = TabBarItemIOS.__proto__ || Object.getPrototypeOf(TabBarItemIOS)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
					hasBeenSelected: false }, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(TabBarItemIOS, [{ key: 'componentWillMount', value: function componentWillMount() {
					if (this.props.selected) {
						this.setState({ hasBeenSelected: true });
					}
				} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(nextProps) {
					if (this.state.hasBeenSelected || nextProps.selected) {
						this.setState({ hasBeenSelected: true });
					}
				} }, { key: 'render', value: function render() {
					var _props = this.props,
					    style = _props.style,
					    children = _props.children,
					    props = babelHelpers.objectWithoutProperties(_props, ['style', 'children']);

					if (this.state.hasBeenSelected) {
						var tabContents = React.createElement(StaticContainer, { shouldUpdate: this.props.selected }, children);
					} else {
						var tabContents = React.createElement(View, null);
					}

					return React.createElement(RCTTabBarItem, babelHelpers.extends({}, props, {
						style: [styles.tab, style] }), tabContents);
				} }]);return TabBarItemIOS;
		}(React.Component);TabBarItemIOS.propTypes = babelHelpers.extends({}, View.propTypes, { badge: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.number]), systemIcon: React.PropTypes.oneOf(['bookmarks', 'contacts', 'downloads', 'favorites', 'featured', 'history', 'more', 'most-recent', 'most-viewed', 'recents', 'search', 'top-rated']), icon: Image.propTypes.source, selectedIcon: Image.propTypes.source, onPress: React.PropTypes.func, renderAsOriginal: React.PropTypes.bool, selected: React.PropTypes.bool, style: View.propTypes.style, title: React.PropTypes.string });

		var styles = StyleSheet.create({
			tab: {
				position: 'absolute',
				top: 0,
				right: 0,
				bottom: 0,
				left: 0 } });

		var RCTTabBarItem = requireNativeComponent('RCTTabBarItem', TabBarItemIOS);

		module.exports = TabBarItemIOS;
	}, // Libraries/Components/TextInput/TextInput.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var DocumentSelectionState = __inner_require__(179 /*Libraries/vendor/document/selection/DocumentSelectionState.js*/);
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var ReactChildren = __inner_require__(14 /*__react__/lib/ReactChildren.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var TextInputState = __inner_require__(9 /*Libraries/Components/TextInput/TextInputState.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var TouchableWithoutFeedback = __inner_require__(185 /*Libraries/Components/Touchable/TouchableWithoutFeedback.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);

		var onlyMultiline = {
			onTextInput: true,
			children: true };

		if (Platform.OS === 'android') {
			var AndroidTextInput = requireNativeComponent('AndroidTextInput', null);
		} else if (Platform.OS === 'ios') {
			var RCTTextView = requireNativeComponent('RCTTextView', null);
			var RCTTextField = requireNativeComponent('RCTTextField', null);
		}

		var DataDetectorTypes = ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'];

		var TextInput = React.createClass({ displayName: 'TextInput',
			statics: {

				State: TextInputState },

			propTypes: babelHelpers.extends({}, View.propTypes, {

				autoCapitalize: PropTypes.oneOf(['none', 'sentences', 'words', 'characters']),

				autoCorrect: PropTypes.bool,

				autoFocus: PropTypes.bool,

				editable: PropTypes.bool,

				keyboardType: PropTypes.oneOf(['default', 'email-address', 'numeric', 'phone-pad', 'ascii-capable', 'numbers-and-punctuation', 'url', 'number-pad', 'name-phone-pad', 'decimal-pad', 'twitter', 'web-search']),

				keyboardAppearance: PropTypes.oneOf(['default', 'light', 'dark']),

				returnKeyType: PropTypes.oneOf(['done', 'go', 'next', 'search', 'send', 'none', 'previous', 'default', 'emergency-call', 'google', 'join', 'route', 'yahoo']),

				returnKeyLabel: PropTypes.string,

				maxLength: PropTypes.number,

				numberOfLines: PropTypes.number,

				enablesReturnKeyAutomatically: PropTypes.bool,

				multiline: PropTypes.bool,

				onBlur: PropTypes.func,

				onFocus: PropTypes.func,

				onChange: PropTypes.func,

				onChangeText: PropTypes.func,

				onContentSizeChange: PropTypes.func,

				onEndEditing: PropTypes.func,

				onSelectionChange: PropTypes.func,

				onSubmitEditing: PropTypes.func,

				onKeyPress: PropTypes.func,

				onLayout: PropTypes.func,

				placeholder: PropTypes.string,

				placeholderTextColor: ColorPropType,

				secureTextEntry: PropTypes.bool,

				selectionColor: ColorPropType,

				selectionState: PropTypes.instanceOf(DocumentSelectionState),

				value: PropTypes.string,

				defaultValue: PropTypes.string,

				clearButtonMode: PropTypes.oneOf(['never', 'while-editing', 'unless-editing', 'always']),

				clearTextOnFocus: PropTypes.bool,

				selectTextOnFocus: PropTypes.bool,

				blurOnSubmit: PropTypes.bool,

				style: Text.propTypes.style,

				underlineColorAndroid: ColorPropType,

				inlineImageLeft: PropTypes.string,

				inlineImagePadding: PropTypes.number,

				dataDetectorTypes: PropTypes.oneOfType([PropTypes.oneOf(DataDetectorTypes), PropTypes.arrayOf(PropTypes.oneOf(DataDetectorTypes))]) }),

			mixins: [NativeMethodsMixin, TimerMixin],

			viewConfig: Platform.OS === 'ios' && RCTTextField ? RCTTextField.viewConfig : Platform.OS === 'android' && AndroidTextInput ? AndroidTextInput.viewConfig : {},

			isFocused: function isFocused() {
				return TextInputState.currentlyFocusedField() === ReactNative.findNodeHandle(this.refs.input);
			},

			contextTypes: {
				onFocusRequested: React.PropTypes.func,
				focusEmitter: React.PropTypes.instanceOf(EventEmitter) },

			_focusSubscription: undefined,
			_lastNativeText: undefined,

			componentDidMount: function componentDidMount() {
				var _this = this;
				this._lastNativeText = this.props.value;
				if (!this.context.focusEmitter) {
					if (this.props.autoFocus) {
						this.requestAnimationFrame(this.focus);
					}
					return;
				}
				this._focusSubscription = this.context.focusEmitter.addListener('focus', function (el) {
					if (_this === el) {
						_this.requestAnimationFrame(_this.focus);
					} else if (_this.isFocused()) {
						_this.blur();
					}
				});

				if (this.props.autoFocus) {
					this.context.onFocusRequested(this);
				}
			},

			componentWillUnmount: function componentWillUnmount() {
				this._focusSubscription && this._focusSubscription.remove();
				if (this.isFocused()) {
					this.blur();
				}
			},

			getChildContext: function getChildContext() {
				return { isInAParentText: true };
			},

			childContextTypes: {
				isInAParentText: React.PropTypes.bool },

			clear: function clear() {
				this.setNativeProps({ text: '' });
			},

			render: function render() {
				if (Platform.OS === 'ios') {
					return this._renderIOS();
				} else if (Platform.OS === 'android') {
					return this._renderAndroid();
				}
			},

			_getText: function _getText() {
				return typeof this.props.value === 'string' ? this.props.value : this.props.defaultValue;
			},

			_renderIOS: function _renderIOS() {
				var _this2 = this;
				var textContainer;

				var onSelectionChange;
				if (this.props.selectionState || this.props.onSelectionChange) {
					onSelectionChange = function onSelectionChange(event) {
						if (_this2.props.selectionState) {
							var selection = event.nativeEvent.selection;
							_this2.props.selectionState.update(selection.start, selection.end);
						}
						_this2.props.onSelectionChange && _this2.props.onSelectionChange(event);
					};
				}

				var props = babelHelpers.extends({}, this.props);
				props.style = [styles.input, this.props.style];
				if (!props.multiline) {
					if (__DEV__) {
						for (var propKey in onlyMultiline) {
							if (props[propKey]) {
								var error = new Error('TextInput prop `' + propKey + '` is only supported with multiline.');

								warning(false, '%s', error.stack);
							}
						}
					}
					textContainer = React.createElement(RCTTextField, babelHelpers.extends({
						ref: 'input' }, props, {
						onFocus: this._onFocus,
						onBlur: this._onBlur,
						onChange: this._onChange,
						onSelectionChange: onSelectionChange,
						onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
						text: this._getText() }));
				} else {
					var children = props.children;
					var childCount = 0;
					ReactChildren.forEach(children, function () {
						return ++childCount;
					});
					invariant(!(props.value && childCount), 'Cannot specify both value and children.');

					if (childCount >= 1) {
						children = React.createElement(Text, { style: props.style }, children);
					}
					if (props.inputView) {
						children = [children, props.inputView];
					}
					textContainer = React.createElement(RCTTextView, babelHelpers.extends({
						ref: 'input' }, props, {
						children: children,
						onFocus: this._onFocus,
						onBlur: this._onBlur,
						onChange: this._onChange,
						onContentSizeChange: this.props.onContentSizeChange,
						onSelectionChange: onSelectionChange,
						onTextInput: this._onTextInput,
						onSelectionChangeShouldSetResponder: emptyFunction.thatReturnsTrue,
						text: this._getText(),
						dataDetectorTypes: this.props.dataDetectorTypes }));
				}

				return React.createElement(TouchableWithoutFeedback, {
					onLayout: props.onLayout,
					onPress: this._onPress,
					rejectResponderTermination: true,
					accessible: props.accessible,
					accessibilityLabel: props.accessibilityLabel,
					accessibilityTraits: props.accessibilityTraits,
					testID: props.testID }, textContainer);
			},

			_renderAndroid: function _renderAndroid() {
				var _this3 = this;
				var onSelectionChange;
				if (this.props.selectionState || this.props.onSelectionChange) {
					onSelectionChange = function onSelectionChange(event) {
						if (_this3.props.selectionState) {
							var selection = event.nativeEvent.selection;
							_this3.props.selectionState.update(selection.start, selection.end);
						}
						_this3.props.onSelectionChange && _this3.props.onSelectionChange(event);
					};
				}

				var props = babelHelpers.extends({}, this.props);
				props.style = [this.props.style];
				props.autoCapitalize = UIManager.AndroidTextInput.Constants.AutoCapitalizationType[this.props.autoCapitalize];
				var children = this.props.children;
				var childCount = 0;
				ReactChildren.forEach(children, function () {
					return ++childCount;
				});
				invariant(!(this.props.value && childCount), 'Cannot specify both value and children.');

				if (childCount > 1) {
					children = React.createElement(Text, null, children);
				}

				var textContainer = React.createElement(AndroidTextInput, babelHelpers.extends({
					ref: 'input' }, props, {
					mostRecentEventCount: 0,
					onFocus: this._onFocus,
					onBlur: this._onBlur,
					onChange: this._onChange,
					onSelectionChange: onSelectionChange,
					onTextInput: this._onTextInput,
					text: this._getText(),
					children: children }));

				return React.createElement(TouchableWithoutFeedback, {
					onLayout: this.props.onLayout,
					onPress: this._onPress,
					shouldBlockResponder: this.isFocused,
					accessible: this.props.accessible,
					accessibilityLabel: this.props.accessibilityLabel,
					accessibilityComponentType: this.props.accessibilityComponentType,
					testID: this.props.testID }, textContainer);
			},

			_onFocus: function _onFocus(event) {
				if (this.props.onFocus) {
					this.props.onFocus(event);
				}

				if (this.props.selectionState) {
					this.props.selectionState.focus();
				}
			},

			_onPress: function _onPress(event) {
				if (this.props.editable || this.props.editable === undefined) {
					this.focus();
				}
			},

			_onChange: function _onChange(event) {

				this.refs.input.setNativeProps({
					mostRecentEventCount: event.nativeEvent.eventCount });

				var text = event.nativeEvent.text;
				this.props.onChange && this.props.onChange(event);
				this.props.onChangeText && this.props.onChangeText(text);

				if (!this.refs.input) {

					return;
				}

				this._lastNativeText = text;
				this.forceUpdate();
			},

			componentDidUpdate: function componentDidUpdate() {

				if (this._lastNativeText !== this.props.value && typeof this.props.value === 'string') {
					this.refs.input.setNativeProps({
						text: this.props.value });
				}
			},

			_onBlur: function _onBlur(event) {
				this.blur();
				if (this.props.onBlur) {
					this.props.onBlur(event);
				}

				if (this.props.selectionState) {
					this.props.selectionState.blur();
				}
			},

			_onTextInput: function _onTextInput(event) {
				this.props.onTextInput && this.props.onTextInput(event);
			} });

		var styles = StyleSheet.create({
			input: {
				alignSelf: 'stretch' } });

		module.exports = TextInput;
	}, // Libraries/vendor/document/selection/DocumentSelectionState.js
	function (__inner_require__, exports, module) {
		var mixInEventEmitter = __inner_require__(180 /*Libraries/EventEmitter/mixInEventEmitter.js*/);var DocumentSelectionState = function () {

			function DocumentSelectionState(anchor, focus) {
				babelHelpers.classCallCheck(this, DocumentSelectionState);
				this._anchorOffset = anchor;
				this._focusOffset = focus;
				this._hasFocus = false;
			}babelHelpers.createClass(DocumentSelectionState, [{ key: 'update', value: function update(anchor, focus) {
					if (this._anchorOffset !== anchor || this._focusOffset !== focus) {
						this._anchorOffset = anchor;
						this._focusOffset = focus;
						this.emit('update');
					}
				} }, { key: 'constrainLength', value: function constrainLength(maxLength) {
					this.update(Math.min(this._anchorOffset, maxLength), Math.min(this._focusOffset, maxLength));
				} }, { key: 'focus', value: function focus() {
					if (!this._hasFocus) {
						this._hasFocus = true;
						this.emit('focus');
					}
				} }, { key: 'blur', value: function blur() {
					if (this._hasFocus) {
						this._hasFocus = false;
						this.emit('blur');
					}
				} }, { key: 'hasFocus', value: function hasFocus() {
					return this._hasFocus;
				} }, { key: 'isCollapsed', value: function isCollapsed() {
					return this._anchorOffset === this._focusOffset;
				} }, { key: 'isBackward', value: function isBackward() {
					return this._anchorOffset > this._focusOffset;
				} }, { key: 'getAnchorOffset', value: function getAnchorOffset() {
					return this._hasFocus ? this._anchorOffset : null;
				} }, { key: 'getFocusOffset', value: function getFocusOffset() {
					return this._hasFocus ? this._focusOffset : null;
				} }, { key: 'getStartOffset', value: function getStartOffset() {
					return this._hasFocus ? Math.min(this._anchorOffset, this._focusOffset) : null;
				} }, { key: 'getEndOffset', value: function getEndOffset() {
					return this._hasFocus ? Math.max(this._anchorOffset, this._focusOffset) : null;
				} }, { key: 'overlaps', value: function overlaps(start, end) {
					return this.hasFocus() && this.getStartOffset() <= end && start <= this.getEndOffset();
				} }]);return DocumentSelectionState;
		}();

		mixInEventEmitter(DocumentSelectionState, {
			'blur': true,
			'focus': true,
			'update': true });

		module.exports = DocumentSelectionState;
	}, // Libraries/EventEmitter/mixInEventEmitter.js
	function (__inner_require__, exports, module) {
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var EventEmitterWithHolding = __inner_require__(181 /*Libraries/EventEmitter/EventEmitterWithHolding.js*/);
		var EventHolder = __inner_require__(182 /*Libraries/EventEmitter/EventHolder.js*/);
		var EventValidator = __inner_require__(183 /*Libraries/EventEmitter/EventValidator.js*/);

		var copyProperties = __inner_require__(184 /*Libraries/vendor/core/copyProperties.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var TYPES_KEY = keyOf({ __types: true });

		function mixInEventEmitter(cls, types) {
			invariant(types, 'Must supply set of valid event types');

			var target = cls.prototype || cls;

			invariant(!target.__eventEmitter, 'An active emitter is already mixed in');

			var ctor = cls.constructor;
			if (ctor) {
				invariant(ctor === Object || ctor === Function, 'Mix EventEmitter into a class, not an instance');
			}

			if (target.hasOwnProperty(TYPES_KEY)) {
				copyProperties(target.__types, types);
			} else if (target.__types) {
				target.__types = copyProperties({}, target.__types, types);
			} else {
				target.__types = types;
			}
			copyProperties(target, EventEmitterMixin);
		}

		var EventEmitterMixin = {
			emit: function emit(eventType, a, b, c, d, e, _) {
				return this.__getEventEmitter().emit(eventType, a, b, c, d, e, _);
			},

			emitAndHold: function emitAndHold(eventType, a, b, c, d, e, _) {
				return this.__getEventEmitter().emitAndHold(eventType, a, b, c, d, e, _);
			},

			addListener: function addListener(eventType, listener, context) {
				return this.__getEventEmitter().addListener(eventType, listener, context);
			},

			once: function once(eventType, listener, context) {
				return this.__getEventEmitter().once(eventType, listener, context);
			},

			addRetroactiveListener: function addRetroactiveListener(eventType, listener, context) {
				return this.__getEventEmitter().addRetroactiveListener(eventType, listener, context);
			},

			addListenerMap: function addListenerMap(listenerMap, context) {
				return this.__getEventEmitter().addListenerMap(listenerMap, context);
			},

			addRetroactiveListenerMap: function addRetroactiveListenerMap(listenerMap, context) {
				return this.__getEventEmitter().addListenerMap(listenerMap, context);
			},

			removeAllListeners: function removeAllListeners() {
				this.__getEventEmitter().removeAllListeners();
			},

			removeCurrentListener: function removeCurrentListener() {
				this.__getEventEmitter().removeCurrentListener();
			},

			releaseHeldEventType: function releaseHeldEventType(eventType) {
				this.__getEventEmitter().releaseHeldEventType(eventType);
			},

			__getEventEmitter: function __getEventEmitter() {
				if (!this.__eventEmitter) {
					var emitter = new EventEmitter();
					emitter = EventValidator.addValidation(emitter, this.__types);

					var holder = new EventHolder();
					this.__eventEmitter = new EventEmitterWithHolding(emitter, holder);
				}
				return this.__eventEmitter;
			} };

		module.exports = mixInEventEmitter;
	}, // Libraries/EventEmitter/EventEmitterWithHolding.js
	function (__inner_require__, exports, module) {
		var EventEmitterWithHolding = function () {

			function EventEmitterWithHolding(emitter, holder) {
				babelHelpers.classCallCheck(this, EventEmitterWithHolding);
				this._emitter = emitter;
				this._eventHolder = holder;
				this._currentEventToken = null;
				this._emittingHeldEvents = false;
			}babelHelpers.createClass(EventEmitterWithHolding, [{ key: 'addListener', value: function addListener(eventType, listener, context) {
					return this._emitter.addListener(eventType, listener, context);
				} }, { key: 'once', value: function once(eventType, listener, context) {
					return this._emitter.once(eventType, listener, context);
				} }, { key: 'addRetroactiveListener', value: function addRetroactiveListener(eventType, listener, context) {
					var subscription = this._emitter.addListener(eventType, listener, context);

					this._emittingHeldEvents = true;
					this._eventHolder.emitToListener(eventType, listener, context);
					this._emittingHeldEvents = false;

					return subscription;
				} }, { key: 'removeAllListeners', value: function removeAllListeners(eventType) {
					this._emitter.removeAllListeners(eventType);
				} }, { key: 'removeCurrentListener', value: function removeCurrentListener() {
					this._emitter.removeCurrentListener();
				} }, { key: 'listeners', value: function listeners(eventType) {
					return this._emitter.listeners(eventType);
				} }, { key: 'emit', value: function emit(eventType) {
					var _emitter;for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						args[_key - 1] = arguments[_key];
					}
					(_emitter = this._emitter).emit.apply(_emitter, [eventType].concat(babelHelpers.toConsumableArray(args)));
				} }, { key: 'emitAndHold', value: function emitAndHold(eventType) {
					var _eventHolder, _emitter2;for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
						args[_key2 - 1] = arguments[_key2];
					}
					this._currentEventToken = (_eventHolder = this._eventHolder).holdEvent.apply(_eventHolder, [eventType].concat(babelHelpers.toConsumableArray(args)));
					(_emitter2 = this._emitter).emit.apply(_emitter2, [eventType].concat(babelHelpers.toConsumableArray(args)));
					this._currentEventToken = null;
				} }, { key: 'releaseCurrentEvent', value: function releaseCurrentEvent() {
					if (this._currentEventToken) {
						this._eventHolder.releaseEvent(this._currentEventToken);
					} else if (this._emittingHeldEvents) {
						this._eventHolder.releaseCurrentEvent();
					}
				} }, { key: 'releaseHeldEventType', value: function releaseHeldEventType(eventType) {
					this._eventHolder.releaseEventType(eventType);
				} }]);return EventEmitterWithHolding;
		}();

		module.exports = EventEmitterWithHolding;
	}, // Libraries/EventEmitter/EventHolder.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');var EventHolder = function () {

			function EventHolder() {
				babelHelpers.classCallCheck(this, EventHolder);
				this._heldEvents = {};
				this._currentEventKey = null;
			}babelHelpers.createClass(EventHolder, [{ key: 'holdEvent', value: function holdEvent(eventType) {
					this._heldEvents[eventType] = this._heldEvents[eventType] || [];
					var eventsOfType = this._heldEvents[eventType];
					var key = {
						eventType: eventType,
						index: eventsOfType.length };for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						args[_key - 1] = arguments[_key];
					}

					eventsOfType.push(args);
					return key;
				} }, { key: 'emitToListener', value: function emitToListener(eventType, listener, context) {
					var _this = this;
					var eventsOfType = this._heldEvents[eventType];
					if (!eventsOfType) {
						return;
					}
					var origEventKey = this._currentEventKey;
					eventsOfType.forEach(function (eventHeld, index) {
						if (!eventHeld) {
							return;
						}
						_this._currentEventKey = {
							eventType: eventType,
							index: index };

						listener.apply(context, eventHeld);
					});
					this._currentEventKey = origEventKey;
				} }, { key: 'releaseCurrentEvent', value: function releaseCurrentEvent() {
					invariant(this._currentEventKey !== null, 'Not in an emitting cycle; there is no current event');

					this._currentEventKey && this.releaseEvent(this._currentEventKey);
				} }, { key: 'releaseEvent', value: function releaseEvent(token) {
					delete this._heldEvents[token.eventType][token.index];
				} }, { key: 'releaseEventType', value: function releaseEventType(type) {
					this._heldEvents[type] = [];
				} }]);return EventHolder;
		}();

		module.exports = EventHolder;
	}, // Libraries/EventEmitter/EventValidator.js
	function (__inner_require__, exports, module) {
		var copyProperties = __inner_require__(184 /*Libraries/vendor/core/copyProperties.js*/);

		var EventValidator = {

			addValidation: function addValidation(emitter, types) {
				var eventTypes = Object.keys(types);
				var emitterWithValidation = Object.create(emitter);

				copyProperties(emitterWithValidation, {
					emit: function emit(type, a, b, c, d, e, _) {
						assertAllowsEventType(type, eventTypes);
						return emitter.emit.call(this, type, a, b, c, d, e, _);
					} });

				return emitterWithValidation;
			} };

		function assertAllowsEventType(type, allowedTypes) {
			if (allowedTypes.indexOf(type) === -1) {
				throw new TypeError(errorMessageFor(type, allowedTypes));
			}
		}

		function errorMessageFor(type, allowedTypes) {
			var message = 'Unknown event type "' + type + '". ';
			if (__DEV__) {
				message += recommendationFor(type, allowedTypes);
			}
			message += 'Known event types: ' + allowedTypes.join(', ') + '.';
			return message;
		}

		if (__DEV__) {
			var recommendationFor = function recommendationFor(type, allowedTypes) {
				var closestTypeRecommendation = closestTypeFor(type, allowedTypes);
				if (isCloseEnough(closestTypeRecommendation, type)) {
					return 'Did you mean "' + closestTypeRecommendation.type + '"? ';
				} else {
					return '';
				}
			};

			var closestTypeFor = function closestTypeFor(type, allowedTypes) {
				var typeRecommendations = allowedTypes.map(typeRecommendationFor.bind(this, type));

				return typeRecommendations.sort(recommendationSort)[0];
			};

			var typeRecommendationFor = function typeRecommendationFor(type, recomendedType) {
				return {
					type: recomendedType,
					distance: damerauLevenshteinDistance(type, recomendedType) };
			};

			var recommendationSort = function recommendationSort(recommendationA, recommendationB) {
				if (recommendationA.distance < recommendationB.distance) {
					return -1;
				} else if (recommendationA.distance > recommendationB.distance) {
					return 1;
				} else {
					return 0;
				}
			};

			var isCloseEnough = function isCloseEnough(closestType, actualType) {
				return closestType.distance / actualType.length < 0.334;
			};

			var damerauLevenshteinDistance = function damerauLevenshteinDistance(a, b) {
				var i = void 0,
				    j = void 0;
				var d = [];

				for (i = 0; i <= a.length; i++) {
					d[i] = [i];
				}

				for (j = 1; j <= b.length; j++) {
					d[0][j] = j;
				}

				for (i = 1; i <= a.length; i++) {
					for (j = 1; j <= b.length; j++) {
						var cost = a.charAt(i - 1) === b.charAt(j - 1) ? 0 : 1;

						d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);

						if (i > 1 && j > 1 && a.charAt(i - 1) === b.charAt(j - 2) && a.charAt(i - 2) === b.charAt(j - 1)) {
							d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
						}
					}
				}

				return d[a.length][b.length];
			};
		}

		module.exports = EventValidator;
	}, // Libraries/vendor/core/copyProperties.js
	function (__inner_require__, exports, module) {
		function copyProperties(obj, a, b, c, d, e, f) {
			obj = obj || {};

			if (__DEV__) {
				if (f) {
					throw new Error('Too many arguments passed to copyProperties');
				}
			}

			var args = [a, b, c, d, e];
			var ii = 0,
			    v;
			while (args[ii]) {
				v = args[ii++];
				for (var k in v) {
					obj[k] = v[k];
				}

				if (v.hasOwnProperty && v.hasOwnProperty('toString') && typeof v.toString != 'undefined' && obj.toString !== v.toString) {
					obj.toString = v.toString;
				}
			}

			return obj;
		}

		module.exports = copyProperties;
	}, // Libraries/Components/Touchable/TouchableWithoutFeedback.js
	function (__inner_require__, exports, module) {
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var ensurePositiveDelayProps = __inner_require__(186 /*Libraries/Components/Touchable/ensurePositiveDelayProps.js*/);
		var onlyChild = __inner_require__(25 /*__react__/lib/onlyChild.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var PRESS_RETENTION_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };

		var TouchableWithoutFeedback = React.createClass({ displayName: 'TouchableWithoutFeedback',
			mixins: [TimerMixin, Touchable.Mixin],

			propTypes: {
				accessible: React.PropTypes.bool,
				accessibilityComponentType: React.PropTypes.oneOf(View.AccessibilityComponentType),
				accessibilityTraits: React.PropTypes.oneOfType([React.PropTypes.oneOf(View.AccessibilityTraits), React.PropTypes.arrayOf(React.PropTypes.oneOf(View.AccessibilityTraits))]),

				disabled: React.PropTypes.bool,

				onPress: React.PropTypes.func,
				onPressIn: React.PropTypes.func,
				onPressOut: React.PropTypes.func,

				onLayout: React.PropTypes.func,

				onLongPress: React.PropTypes.func,

				delayPressIn: React.PropTypes.number,

				delayPressOut: React.PropTypes.number,

				delayLongPress: React.PropTypes.number,

				pressRetentionOffset: EdgeInsetsPropType,

				hitSlop: EdgeInsetsPropType },

			getInitialState: function getInitialState() {
				return this.touchableGetInitialState();
			},

			componentDidMount: function componentDidMount() {
				ensurePositiveDelayProps(this.props);
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
				ensurePositiveDelayProps(nextProps);
			},

			touchableHandlePress: function touchableHandlePress(e) {
				this.props.onPress && this.props.onPress(e);
			},

			touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
				this.props.onPressIn && this.props.onPressIn(e);
			},

			touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
				this.props.onPressOut && this.props.onPressOut(e);
			},

			touchableHandleLongPress: function touchableHandleLongPress(e) {
				this.props.onLongPress && this.props.onLongPress(e);
			},

			touchableGetPressRectOffset: function touchableGetPressRectOffset() {
				return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
			},

			touchableGetHitSlop: function touchableGetHitSlop() {
				return this.props.hitSlop;
			},

			touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
				return this.props.delayPressIn || 0;
			},

			touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
				return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
			},

			touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
				return this.props.delayPressOut || 0;
			},

			render: function render() {

				var child = onlyChild(this.props.children);
				var children = child.props.children;
				warning(!child.type || child.type.displayName !== 'Text', 'TouchableWithoutFeedback does not work well with Text children. Wrap children in a View instead. See ' + (child._owner && child._owner.getName && child._owner.getName() || '<unknown>'));

				if (Touchable.TOUCH_TARGET_DEBUG && child.type && child.type.displayName === 'View') {
					if (!Array.isArray(children)) {
						children = [children];
					}
					children.push(Touchable.renderDebugView({ color: 'red', hitSlop: this.props.hitSlop }));
				}
				var style = Touchable.TOUCH_TARGET_DEBUG && child.type && child.type.displayName === 'Text' ? [child.props.style, { color: 'red' }] : child.props.style;
				return React.cloneElement(child, {
					accessible: this.props.accessible !== false,
					accessibilityLabel: this.props.accessibilityLabel,
					accessibilityComponentType: this.props.accessibilityComponentType,
					accessibilityTraits: this.props.accessibilityTraits,
					testID: this.props.testID,
					onLayout: this.props.onLayout,
					hitSlop: this.props.hitSlop,
					onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
					onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
					onResponderGrant: this.touchableHandleResponderGrant,
					onResponderMove: this.touchableHandleResponderMove,
					onResponderRelease: this.touchableHandleResponderRelease,
					onResponderTerminate: this.touchableHandleResponderTerminate,
					style: style,
					children: children });
			} });

		module.exports = TouchableWithoutFeedback;
	}, // Libraries/Components/Touchable/ensurePositiveDelayProps.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var ensurePositiveDelayProps = function ensurePositiveDelayProps(props) {
			invariant(!(props.delayPressIn < 0 || props.delayPressOut < 0 || props.delayLongPress < 0), 'Touchable components cannot have negative delay properties');
		};

		module.exports = ensurePositiveDelayProps;
	}, // Libraries/Components/ToastAndroid/ToastAndroid.ios.js
	function (__inner_require__, exports, module) {
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ToastAndroid = {

			show: function show(message, duration) {
				warning(false, 'ToastAndroid is not supported on this platform.');
			} };

		module.exports = ToastAndroid;
	}, // Libraries/Components/ToolbarAndroid/ToolbarAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Components/Touchable/TouchableHighlight.js
	function (__inner_require__, exports, module) {
		var ColorPropType = __inner_require__(2 /*Libraries/StyleSheet/ColorPropType.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNativeViewAttributes = __inner_require__(49 /*Libraries/Components/View/ReactNativeViewAttributes.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
		var TouchableWithoutFeedback = __inner_require__(185 /*Libraries/Components/Touchable/TouchableWithoutFeedback.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var ensureComponentIsNative = __inner_require__(190 /*Libraries/Components/Touchable/ensureComponentIsNative.js*/);
		var ensurePositiveDelayProps = __inner_require__(186 /*Libraries/Components/Touchable/ensurePositiveDelayProps.js*/);
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);
		var merge = __inner_require__(41 /*Libraries/vendor/core/merge.js*/);
		var onlyChild = __inner_require__(25 /*__react__/lib/onlyChild.js*/);

		var DEFAULT_PROPS = {
			activeOpacity: 0.8,
			underlayColor: 'black' };

		var PRESS_RETENTION_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };

		var TouchableHighlight = React.createClass({ displayName: 'TouchableHighlight',
			propTypes: babelHelpers.extends({}, TouchableWithoutFeedback.propTypes, {

				activeOpacity: React.PropTypes.number,

				underlayColor: ColorPropType,
				style: View.propTypes.style,

				onShowUnderlay: React.PropTypes.func,

				onHideUnderlay: React.PropTypes.func }),

			mixins: [NativeMethodsMixin, TimerMixin, Touchable.Mixin],

			getDefaultProps: function getDefaultProps() {
				return DEFAULT_PROPS;
			},

			_computeSyntheticState: function _computeSyntheticState(props) {
				return {
					activeProps: {
						style: {
							opacity: props.activeOpacity } },

					activeUnderlayProps: {
						style: {
							backgroundColor: props.underlayColor } },

					underlayStyle: [INACTIVE_UNDERLAY_PROPS.style, props.style] };
			},

			getInitialState: function getInitialState() {
				return merge(this.touchableGetInitialState(), this._computeSyntheticState(this.props));
			},

			componentDidMount: function componentDidMount() {
				ensurePositiveDelayProps(this.props);
				ensureComponentIsNative(this.refs[CHILD_REF]);
			},

			componentDidUpdate: function componentDidUpdate() {
				ensureComponentIsNative(this.refs[CHILD_REF]);
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
				ensurePositiveDelayProps(nextProps);
				if (nextProps.activeOpacity !== this.props.activeOpacity || nextProps.underlayColor !== this.props.underlayColor || nextProps.style !== this.props.style) {
					this.setState(this._computeSyntheticState(nextProps));
				}
			},

			viewConfig: {
				uiViewClassName: 'RCTView',
				validAttributes: ReactNativeViewAttributes.RCTView },

			touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
				this.clearTimeout(this._hideTimeout);
				this._hideTimeout = null;
				this._showUnderlay();
				this.props.onPressIn && this.props.onPressIn(e);
			},

			touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
				if (!this._hideTimeout) {
					this._hideUnderlay();
				}
				this.props.onPressOut && this.props.onPressOut(e);
			},

			touchableHandlePress: function touchableHandlePress(e) {
				this.clearTimeout(this._hideTimeout);
				this._showUnderlay();
				this._hideTimeout = this.setTimeout(this._hideUnderlay, this.props.delayPressOut || 100);
				this.props.onPress && this.props.onPress(e);
			},

			touchableHandleLongPress: function touchableHandleLongPress(e) {
				this.props.onLongPress && this.props.onLongPress(e);
			},

			touchableGetPressRectOffset: function touchableGetPressRectOffset() {
				return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
			},

			touchableGetHitSlop: function touchableGetHitSlop() {
				return this.props.hitSlop;
			},

			touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
				return this.props.delayPressIn;
			},

			touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
				return this.props.delayLongPress;
			},

			touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
				return this.props.delayPressOut;
			},

			_showUnderlay: function _showUnderlay() {
				if (!this.isMounted() || !this._hasPressHandler()) {
					return;
				}

				this.refs[UNDERLAY_REF].setNativeProps(this.state.activeUnderlayProps);
				this.refs[CHILD_REF].setNativeProps(this.state.activeProps);
				this.props.onShowUnderlay && this.props.onShowUnderlay();
			},

			_hideUnderlay: function _hideUnderlay() {
				this.clearTimeout(this._hideTimeout);
				this._hideTimeout = null;
				if (this._hasPressHandler() && this.refs[UNDERLAY_REF]) {
					this.refs[CHILD_REF].setNativeProps(INACTIVE_CHILD_PROPS);
					this.refs[UNDERLAY_REF].setNativeProps(babelHelpers.extends({}, INACTIVE_UNDERLAY_PROPS, {
						style: this.state.underlayStyle }));

					this.props.onHideUnderlay && this.props.onHideUnderlay();
				}
			},

			_hasPressHandler: function _hasPressHandler() {
				return !!(this.props.onPress || this.props.onPressIn || this.props.onPressOut || this.props.onLongPress);
			},

			render: function render() {
				return React.createElement(View, {
					accessible: this.props.accessible !== false,
					accessibilityLabel: this.props.accessibilityLabel,
					accessibilityComponentType: this.props.accessibilityComponentType,
					accessibilityTraits: this.props.accessibilityTraits,
					ref: UNDERLAY_REF,
					style: this.state.underlayStyle,
					onLayout: this.props.onLayout,
					hitSlop: this.props.hitSlop,
					onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
					onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
					onResponderGrant: this.touchableHandleResponderGrant,
					onResponderMove: this.touchableHandleResponderMove,
					onResponderRelease: this.touchableHandleResponderRelease,
					onResponderTerminate: this.touchableHandleResponderTerminate,
					testID: this.props.testID }, React.cloneElement(onlyChild(this.props.children), {
					ref: CHILD_REF }), Touchable.renderDebugView({ color: 'green', hitSlop: this.props.hitSlop }));
			} });

		var CHILD_REF = keyOf({ childRef: null });
		var UNDERLAY_REF = keyOf({ underlayRef: null });
		var INACTIVE_CHILD_PROPS = {
			style: StyleSheet.create({ x: { opacity: 1.0 } }).x };

		var INACTIVE_UNDERLAY_PROPS = {
			style: StyleSheet.create({ x: { backgroundColor: 'transparent' } }).x };

		module.exports = TouchableHighlight;
	}, // Libraries/Components/Touchable/ensureComponentIsNative.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var ensureComponentIsNative = function ensureComponentIsNative(component) {
			invariant(component && typeof component.setNativeProps === 'function', 'Touchable child must either be native or forward setNativeProps to a ' + 'native component');
		};

		module.exports = ensureComponentIsNative;
	}, // Libraries/Components/Touchable/TouchableNativeFeedback.ios.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var DummyTouchableNativeFeedback = function (_React$Component) {
			babelHelpers.inherits(DummyTouchableNativeFeedback, _React$Component);function DummyTouchableNativeFeedback() {
				babelHelpers.classCallCheck(this, DummyTouchableNativeFeedback);return babelHelpers.possibleConstructorReturn(this, (DummyTouchableNativeFeedback.__proto__ || Object.getPrototypeOf(DummyTouchableNativeFeedback)).apply(this, arguments));
			}babelHelpers.createClass(DummyTouchableNativeFeedback, [{ key: 'render', value: function render() {
					return React.createElement(View, { style: [styles.container, this.props.style] }, React.createElement(Text, { style: styles.info }, 'TouchableNativeFeedback is not supported on this platform!'));
				} }]);return DummyTouchableNativeFeedback;
		}(React.Component);

		var styles = StyleSheet.create({
			container: {
				height: 100,
				width: 300,
				backgroundColor: '#ffbcbc',
				borderWidth: 1,
				borderColor: 'red',
				alignItems: 'center',
				justifyContent: 'center',
				margin: 10 },

			info: {
				color: '#333333',
				margin: 20 } });

		module.exports = DummyTouchableNativeFeedback;
	}, // Libraries/Components/Touchable/TouchableOpacity.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var NativeMethodsMixin = __inner_require__(3 /*__react__/lib/NativeMethodsMixin.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var TimerMixin = require('react-timer-mixin@0.13/TimerMixin.js');
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
		var TouchableWithoutFeedback = __inner_require__(185 /*Libraries/Components/Touchable/TouchableWithoutFeedback.js*/);

		var ensurePositiveDelayProps = __inner_require__(186 /*Libraries/Components/Touchable/ensurePositiveDelayProps.js*/);
		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');

		var PRESS_RETENTION_OFFSET = { top: 20, left: 20, right: 20, bottom: 30 };

		var TouchableOpacity = React.createClass({ displayName: 'TouchableOpacity',
			mixins: [TimerMixin, Touchable.Mixin, NativeMethodsMixin],

			propTypes: babelHelpers.extends({}, TouchableWithoutFeedback.propTypes, {

				activeOpacity: React.PropTypes.number }),

			getDefaultProps: function getDefaultProps() {
				return {
					activeOpacity: 0.2 };
			},

			getInitialState: function getInitialState() {
				return babelHelpers.extends({}, this.touchableGetInitialState(), {
					anim: new Animated.Value(1) });
			},

			componentDidMount: function componentDidMount() {
				ensurePositiveDelayProps(this.props);
			},

			componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
				ensurePositiveDelayProps(nextProps);
			},

			setOpacityTo: function setOpacityTo(value) {
				Animated.timing(this.state.anim, { toValue: value, duration: 150 }).start();
			},

			touchableHandleActivePressIn: function touchableHandleActivePressIn(e) {
				this.clearTimeout(this._hideTimeout);
				this._hideTimeout = null;
				this._opacityActive();
				this.props.onPressIn && this.props.onPressIn(e);
			},

			touchableHandleActivePressOut: function touchableHandleActivePressOut(e) {
				if (!this._hideTimeout) {
					this._opacityInactive();
				}
				this.props.onPressOut && this.props.onPressOut(e);
			},

			touchableHandlePress: function touchableHandlePress(e) {
				this.clearTimeout(this._hideTimeout);
				this._opacityActive();
				this._hideTimeout = this.setTimeout(this._opacityInactive, this.props.delayPressOut || 100);

				this.props.onPress && this.props.onPress(e);
			},

			touchableHandleLongPress: function touchableHandleLongPress(e) {
				this.props.onLongPress && this.props.onLongPress(e);
			},

			touchableGetPressRectOffset: function touchableGetPressRectOffset() {
				return this.props.pressRetentionOffset || PRESS_RETENTION_OFFSET;
			},

			touchableGetHitSlop: function touchableGetHitSlop() {
				return this.props.hitSlop;
			},

			touchableGetHighlightDelayMS: function touchableGetHighlightDelayMS() {
				return this.props.delayPressIn || 0;
			},

			touchableGetLongPressDelayMS: function touchableGetLongPressDelayMS() {
				return this.props.delayLongPress === 0 ? 0 : this.props.delayLongPress || 500;
			},

			touchableGetPressOutDelayMS: function touchableGetPressOutDelayMS() {
				return this.props.delayPressOut;
			},

			_opacityActive: function _opacityActive() {
				this.setOpacityTo(this.props.activeOpacity);
			},

			_opacityInactive: function _opacityInactive() {
				this.clearTimeout(this._hideTimeout);
				this._hideTimeout = null;
				var childStyle = flattenStyle(this.props.style) || {};
				this.setOpacityTo(childStyle.opacity === undefined ? 1 : childStyle.opacity);
			},

			render: function render() {
				return React.createElement(Animated.View, {
					accessible: this.props.accessible !== false,
					accessibilityLabel: this.props.accessibilityLabel,
					accessibilityComponentType: this.props.accessibilityComponentType,
					accessibilityTraits: this.props.accessibilityTraits,
					style: [this.props.style, { opacity: this.state.anim }],
					testID: this.props.testID,
					onLayout: this.props.onLayout,
					hitSlop: this.props.hitSlop,
					onStartShouldSetResponder: this.touchableHandleStartShouldSetResponder,
					onResponderTerminationRequest: this.touchableHandleResponderTerminationRequest,
					onResponderGrant: this.touchableHandleResponderGrant,
					onResponderMove: this.touchableHandleResponderMove,
					onResponderRelease: this.touchableHandleResponderRelease,
					onResponderTerminate: this.touchableHandleResponderTerminate }, this.props.children, Touchable.renderDebugView({ color: 'cyan', hitSlop: this.props.hitSlop }));
			} });

		module.exports = TouchableOpacity;
	}, // Libraries/Components/ViewPager/ViewPagerAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = __inner_require__(52 /*Libraries/Components/UnimplementedViews/UnimplementedView.js*/);
	}, // Libraries/Components/WebView/WebView.ios.js
	function (__inner_require__, exports, module) {
		var ActivityIndicator = __inner_require__(1 /*Libraries/Components/ActivityIndicator/ActivityIndicator.js*/);
		var EdgeInsetsPropType = __inner_require__(39 /*Libraries/StyleSheet/EdgeInsetsPropType.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var ScrollView = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);

		var deprecatedPropType = __inner_require__(35 /*Libraries/Utilities/deprecatedPropType.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyMirror = require('react-native@0.33/__fbjs__/lib/keyMirror.js');
		var processDecelerationRate = __inner_require__(117 /*Libraries/Components/ScrollView/processDecelerationRate.js*/);
		var requireNativeComponent = __inner_require__(51 /*Libraries/ReactIOS/requireNativeComponent.js*/);
		var resolveAssetSource = __inner_require__(71 /*Libraries/Image/resolveAssetSource.js*/);

		var PropTypes = React.PropTypes;
		var RCTWebViewManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').WebViewManager;

		var BGWASH = 'rgba(255,255,255,0.8)';
		var RCT_WEBVIEW_REF = 'webview';

		var WebViewState = keyMirror({
			IDLE: null,
			LOADING: null,
			ERROR: null });

		var NavigationType = keyMirror({
			click: true,
			formsubmit: true,
			backforward: true,
			reload: true,
			formresubmit: true,
			other: true });

		var JSNavigationScheme = 'react-js-navigation';

		var DataDetectorTypes = ['phoneNumber', 'link', 'address', 'calendarEvent', 'none', 'all'];

		var defaultRenderLoading = function defaultRenderLoading() {
			return React.createElement(View, { style: styles.loadingView }, React.createElement(ActivityIndicator, null));
		};

		var defaultRenderError = function defaultRenderError(errorDomain, errorCode, errorDesc) {
			return React.createElement(View, { style: styles.errorContainer }, React.createElement(Text, { style: styles.errorTextTitle }, 'Error loading page'), React.createElement(Text, { style: styles.errorText }, 'Domain: ' + errorDomain), React.createElement(Text, { style: styles.errorText }, 'Error Code: ' + errorCode), React.createElement(Text, { style: styles.errorText }, 'Description: ' + errorDesc));
		};var WebView = function (_React$Component) {
			babelHelpers.inherits(WebView, _React$Component);function WebView() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, WebView);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = WebView.__proto__ || Object.getPrototypeOf(WebView)).call.apply(_ref, [this].concat(args))), _this), _this.state = {
					viewState: WebViewState.IDLE,
					lastErrorEvent: null,
					startInLoadingState: true }, _this.goForward = function () {
					UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goForward, null);
				}, _this.goBack = function () {
					UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.goBack, null);
				}, _this.reload = function () {
					_this.setState({ viewState: WebViewState.LOADING });
					UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.reload, null);
				}, _this.stopLoading = function () {
					UIManager.dispatchViewManagerCommand(_this.getWebViewHandle(), UIManager.RCTWebView.Commands.stopLoading, null);
				}, _this._updateNavigationState = function (event) {
					if (_this.props.onNavigationStateChange) {
						_this.props.onNavigationStateChange(event.nativeEvent);
					}
				}, _this.getWebViewHandle = function () {
					return ReactNative.findNodeHandle(_this.refs[RCT_WEBVIEW_REF]);
				}, _this._onLoadingStart = function (event) {
					var onLoadStart = _this.props.onLoadStart;
					onLoadStart && onLoadStart(event);
					_this._updateNavigationState(event);
				}, _this._onLoadingError = function (event) {
					event.persist();var _this$props = _this.props,
					    onError = _this$props.onError,
					    onLoadEnd = _this$props.onLoadEnd;
					onError && onError(event);
					onLoadEnd && onLoadEnd(event);
					console.warn('Encountered an error loading page', event.nativeEvent);

					_this.setState({
						lastErrorEvent: event.nativeEvent,
						viewState: WebViewState.ERROR });
				}, _this._onLoadingFinish = function (event) {
					var _this$props2 = _this.props,
					    onLoad = _this$props2.onLoad,
					    onLoadEnd = _this$props2.onLoadEnd;
					onLoad && onLoad(event);
					onLoadEnd && onLoadEnd(event);
					_this.setState({
						viewState: WebViewState.IDLE });

					_this._updateNavigationState(event);
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(WebView, [{ key: 'componentWillMount', value: function componentWillMount() {
					if (this.props.startInLoadingState) {
						this.setState({ viewState: WebViewState.LOADING });
					}
				} }, { key: 'render', value: function render() {
					var _this2 = this;var otherView = null;if (this.state.viewState === WebViewState.LOADING) {
						otherView = (this.props.renderLoading || defaultRenderLoading)();
					} else if (this.state.viewState === WebViewState.ERROR) {
						var errorEvent = this.state.lastErrorEvent;invariant(errorEvent != null, 'lastErrorEvent expected to be non-null');otherView = (this.props.renderError || defaultRenderError)(errorEvent.domain, errorEvent.code, errorEvent.description);
					} else if (this.state.viewState !== WebViewState.IDLE) {
						console.error('RCTWebView invalid state encountered: ' + this.state.loading);
					}var webViewStyles = [styles.container, styles.webView, this.props.style];if (this.state.viewState === WebViewState.LOADING || this.state.viewState === WebViewState.ERROR) {
						webViewStyles.push(styles.hidden);
					}var onShouldStartLoadWithRequest = this.props.onShouldStartLoadWithRequest && function (event) {
						var shouldStart = _this2.props.onShouldStartLoadWithRequest && _this2.props.onShouldStartLoadWithRequest(event.nativeEvent);RCTWebViewManager.startLoadWithResult(!!shouldStart, event.nativeEvent.lockIdentifier);
					};var decelerationRate = processDecelerationRate(this.props.decelerationRate);var source = this.props.source || {};if (this.props.html) {
						source.html = this.props.html;
					} else if (this.props.url) {
						source.uri = this.props.url;
					}var webView = React.createElement(RCTWebView, { ref: RCT_WEBVIEW_REF, key: 'webViewKey', style: webViewStyles, source: resolveAssetSource(source), injectedJavaScript: this.props.injectedJavaScript, bounces: this.props.bounces, scrollEnabled: this.props.scrollEnabled, decelerationRate: decelerationRate, contentInset: this.props.contentInset, automaticallyAdjustContentInsets: this.props.automaticallyAdjustContentInsets, onLoadingStart: this._onLoadingStart, onLoadingFinish: this._onLoadingFinish, onLoadingError: this._onLoadingError, onShouldStartLoadWithRequest: onShouldStartLoadWithRequest, scalesPageToFit: this.props.scalesPageToFit, allowsInlineMediaPlayback: this.props.allowsInlineMediaPlayback, mediaPlaybackRequiresUserAction: this.props.mediaPlaybackRequiresUserAction, dataDetectorTypes: this.props.dataDetectorTypes });return React.createElement(View, { style: styles.container }, webView, otherView);
				} }]);return WebView;
		}(React.Component);WebView.JSNavigationScheme = JSNavigationScheme;WebView.NavigationType = NavigationType;WebView.propTypes = babelHelpers.extends({}, View.propTypes, { html: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'), url: deprecatedPropType(PropTypes.string, 'Use the `source` prop instead.'), source: PropTypes.oneOfType([PropTypes.shape({ uri: PropTypes.string, method: PropTypes.string, headers: PropTypes.object, body: PropTypes.string }), PropTypes.shape({ html: PropTypes.string, baseUrl: PropTypes.string }), PropTypes.number]), renderError: PropTypes.func, renderLoading: PropTypes.func, onLoad: PropTypes.func, onLoadEnd: PropTypes.func, onLoadStart: PropTypes.func, onError: PropTypes.func, bounces: PropTypes.bool, decelerationRate: ScrollView.propTypes.decelerationRate, scrollEnabled: PropTypes.bool, automaticallyAdjustContentInsets: PropTypes.bool, contentInset: EdgeInsetsPropType, onNavigationStateChange: PropTypes.func, startInLoadingState: PropTypes.bool, style: View.propTypes.style, dataDetectorTypes: PropTypes.oneOfType([PropTypes.oneOf(DataDetectorTypes), PropTypes.arrayOf(PropTypes.oneOf(DataDetectorTypes))]), javaScriptEnabled: PropTypes.bool, domStorageEnabled: PropTypes.bool, injectedJavaScript: PropTypes.string, userAgent: PropTypes.string, scalesPageToFit: PropTypes.bool, onShouldStartLoadWithRequest: PropTypes.func, allowsInlineMediaPlayback: PropTypes.bool, mediaPlaybackRequiresUserAction: PropTypes.bool });

		var RCTWebView = requireNativeComponent('RCTWebView', WebView, {
			nativeOnly: {
				onLoadingStart: true,
				onLoadingError: true,
				onLoadingFinish: true } });

		var styles = StyleSheet.create({
			container: {
				flex: 1 },

			errorContainer: {
				flex: 1,
				justifyContent: 'center',
				alignItems: 'center',
				backgroundColor: BGWASH },

			errorText: {
				fontSize: 14,
				textAlign: 'center',
				marginBottom: 2 },

			errorTextTitle: {
				fontSize: 15,
				fontWeight: '500',
				marginBottom: 10 },

			hidden: {
				height: 0,
				flex: 0 },

			loadingView: {
				backgroundColor: BGWASH,
				flex: 1,
				justifyContent: 'center',
				alignItems: 'center',
				height: 100 },

			webView: {
				backgroundColor: '#ffffff' } });

		module.exports = WebView;
	}, // Libraries/ActionSheetIOS/ActionSheetIOS.js
	function (__inner_require__, exports, module) {
		var RCTActionSheetManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').ActionSheetManager;

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');

		var ActionSheetIOS = {

			showActionSheetWithOptions: function showActionSheetWithOptions(options, callback) {
				invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');

				invariant(typeof callback === 'function', 'Must provide a valid callback');

				RCTActionSheetManager.showActionSheetWithOptions(babelHelpers.extends({}, options, { tintColor: processColor(options.tintColor) }), callback);
			},

			showShareActionSheetWithOptions: function showShareActionSheetWithOptions(options, failureCallback, successCallback) {
				invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');

				invariant(typeof failureCallback === 'function', 'Must provide a valid failureCallback');

				invariant(typeof successCallback === 'function', 'Must provide a valid successCallback');

				RCTActionSheetManager.showShareActionSheetWithOptions(babelHelpers.extends({}, options, { tintColor: processColor(options.tintColor) }), failureCallback, successCallback);
			} };

		module.exports = ActionSheetIOS;
	}, // Libraries/AdSupport/AdSupportIOS.js
	function (__inner_require__, exports, module) {
		var AdSupport = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').AdSupport;

		module.exports = {
			getAdvertisingId: function getAdvertisingId(onSuccess, onFailure) {
				AdSupport.getAdvertisingId(onSuccess, onFailure);
			},

			getAdvertisingTrackingEnabled: function getAdvertisingTrackingEnabled(onSuccess, onFailure) {
				AdSupport.getAdvertisingTrackingEnabled(onSuccess, onFailure);
			} };
	}, // Libraries/AppRegistry/AppRegistry.js
	function (__inner_require__, exports, module) {
		var BatchedBridge = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridge.js');
		var BugReporting = __inner_require__(198 /*Libraries/BugReporting/BugReporting.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var renderApplication = __inner_require__(201 /*Libraries/ReactIOS/renderApplication.js*/);
		var infoLog = __inner_require__(126 /*Libraries/Utilities/infoLog.js*/);

		if (__DEV__) {

			__inner_require__(221 /*Libraries/Utilities/RCTRenderingPerf.js*/);
		}

		var runnables = {};
		var runCount = 1;

		var AppRegistry = {
			registerConfig: function registerConfig(config) {
				for (var i = 0; i < config.length; ++i) {
					var appConfig = config[i];
					if (appConfig.run) {
						AppRegistry.registerRunnable(appConfig.appKey, appConfig.run);
					} else {
						invariant(appConfig.component, 'No component provider passed in');
						AppRegistry.registerComponent(appConfig.appKey, appConfig.component);
					}
				}
			},

			registerComponent: function registerComponent(appKey, getComponentFunc) {
				runnables[appKey] = {
					run: function run(appParameters) {
						return renderApplication(getComponentFunc(), appParameters.initialProps, appParameters.rootTag);
					} };

				return appKey;
			},

			registerRunnable: function registerRunnable(appKey, func) {
				runnables[appKey] = { run: func };
				return appKey;
			},

			getAppKeys: function getAppKeys() {
				return Object.keys(runnables);
			},

			runApplication: function runApplication(appKey, appParameters) {
				var msg = 'Running application "' + appKey + '" with appParams: ' + JSON.stringify(appParameters) + '. ' + '__DEV__ === ' + String(__DEV__) + ', development-level warning are ' + (__DEV__ ? 'ON' : 'OFF') + ', performance optimizations are ' + (__DEV__ ? 'OFF' : 'ON');
				infoLog(msg);
				BugReporting.addSource('AppRegistry.runApplication' + runCount++, function () {
					return msg;
				});
				invariant(runnables[appKey] && runnables[appKey].run, 'Application ' + appKey + ' has not been registered. This ' + 'is either due to a require() error during initialization ' + 'or failure to call AppRegistry.registerComponent.');

				runnables[appKey].run(appParameters);
			},

			unmountApplicationComponentAtRootTag: function unmountApplicationComponentAtRootTag(rootTag) {
				ReactNative.unmountComponentAtNodeAndRemoveContainer(rootTag);
			} };

		BatchedBridge.registerCallableModule('AppRegistry', AppRegistry);

		module.exports = AppRegistry;
	}, // Libraries/BugReporting/BugReporting.js
	function (__inner_require__, exports, module) {
		var RCTDeviceEventEmitter = require('react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js');
		var Map = require('react-native@0.33/Libraries/vendor/core/Map.js');
		var infoLog = __inner_require__(126 /*Libraries/Utilities/infoLog.js*/);

		function defaultExtras() {
			BugReporting.addFileSource('react_hierarchy.txt', function () {
				return __inner_require__(199 /*Libraries/BugReporting/dumpReactTree.js*/)();
			});
		}var BugReporting = function () {
			function BugReporting() {
				babelHelpers.classCallCheck(this, BugReporting);
			}babelHelpers.createClass(BugReporting, null, [{ key: '_maybeInit', value: function _maybeInit() {
					if (!BugReporting._subscription) {
						BugReporting._subscription = RCTDeviceEventEmitter.addListener('collectBugExtraData', BugReporting.collectExtraData, null);
						defaultExtras();
					}
				} }, { key: 'addSource', value: function addSource(key, callback) {
					return this._addSource(key, callback, BugReporting._extraSources);
				} }, { key: 'addFileSource', value: function addFileSource(key, callback) {
					return this._addSource(key, callback, BugReporting._fileSources);
				} }, { key: '_addSource', value: function _addSource(key, callback, source) {
					BugReporting._maybeInit();
					if (source.has(key)) {
						console.warn('BugReporting.add* called multiple times for same key \'' + key + '\'');
					}
					source.set(key, callback);
					return { remove: function remove() {
							source.delete(key);
						} };
				} }, { key: 'collectExtraData', value: function collectExtraData() {
					var extraData = {};
					for (var _iterator = BugReporting._extraSources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
						var _ref3;if (_isArray) {
							if (_i >= _iterator.length) break;_ref3 = _iterator[_i++];
						} else {
							_i = _iterator.next();if (_i.done) break;_ref3 = _i.value;
						}var _ref = _ref3;var _ref2 = babelHelpers.slicedToArray(_ref, 2);var _key = _ref2[0];var callback = _ref2[1];
						extraData[_key] = callback();
					}
					var fileData = {};
					for (var _iterator2 = BugReporting._fileSources, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
						var _ref6;if (_isArray2) {
							if (_i2 >= _iterator2.length) break;_ref6 = _iterator2[_i2++];
						} else {
							_i2 = _iterator2.next();if (_i2.done) break;_ref6 = _i2.value;
						}var _ref4 = _ref6;var _ref5 = babelHelpers.slicedToArray(_ref4, 2);var _key2 = _ref5[0];var _callback = _ref5[1];
						fileData[_key2] = _callback();
					}
					infoLog('BugReporting extraData:', extraData);
					var BugReportingNativeModule = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').BugReporting;
					BugReportingNativeModule && BugReportingNativeModule.setExtraData && BugReportingNativeModule.setExtraData(extraData, fileData);

					return { extras: extraData, files: fileData };
				} }]);return BugReporting;
		}();BugReporting._extraSources = new Map();BugReporting._fileSources = new Map();BugReporting._subscription = null;

		module.exports = BugReporting;
	}, // Libraries/BugReporting/dumpReactTree.js
	function (__inner_require__, exports, module) {
		var ReactNativeMount = require('react-native@0.33/__react__/lib/ReactNativeMount.js');
		var getReactData = __inner_require__(200 /*Libraries/BugReporting/getReactData.js*/);

		var INDENTATION_SIZE = 2;
		var MAX_DEPTH = 2;
		var MAX_STRING_LENGTH = 50;

		function dumpReactTree() {
			try {
				return getReactTree();
			} catch (e) {
				return 'Failed to dump react tree: ' + e;
			}
		}

		function getReactTree() {
			var output = '';
			var rootIds = Object.getOwnPropertyNames(ReactNativeMount._instancesByContainerID);
			for (var _iterator = rootIds, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
				var _ref;if (_isArray) {
					if (_i >= _iterator.length) break;_ref = _iterator[_i++];
				} else {
					_i = _iterator.next();if (_i.done) break;_ref = _i.value;
				}var rootId = _ref;
				var instance = ReactNativeMount._instancesByContainerID[rootId];
				output += '============ Root ID: ' + rootId + ' ============\n';
				output += dumpNode(instance, 0);
				output += '============ End root ID: ' + rootId + ' ============\n';
			}
			return output;
		}

		function dumpNode(node, identation) {
			var data = getReactData(node);
			if (data.nodeType === 'Text') {
				return indent(identation) + data.text + '\n';
			} else if (data.nodeType === 'Empty') {
				return '';
			}
			var output = indent(identation) + ('<' + data.name);
			if (data.nodeType === 'Composite') {
				for (var _iterator2 = Object.getOwnPropertyNames(data.props || {}), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
					var _ref2;if (_isArray2) {
						if (_i2 >= _iterator2.length) break;_ref2 = _iterator2[_i2++];
					} else {
						_i2 = _iterator2.next();if (_i2.done) break;_ref2 = _i2.value;
					}var propName = _ref2;
					if (isNormalProp(propName)) {
						try {
							var value = convertValue(data.props[propName]);
							if (value) {
								output += ' ' + propName + '=' + value;
							}
						} catch (e) {
							var message = '[Failed to get property: ' + e + ']';
							output += ' ' + propName + '=' + message;
						}
					}
				}
			}
			var childOutput = '';
			for (var _iterator3 = data.children || [], _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
				var _ref3;if (_isArray3) {
					if (_i3 >= _iterator3.length) break;_ref3 = _iterator3[_i3++];
				} else {
					_i3 = _iterator3.next();if (_i3.done) break;_ref3 = _i3.value;
				}var child = _ref3;
				childOutput += dumpNode(child, identation + 1);
			}

			if (childOutput) {
				output += '>\n' + childOutput + indent(identation) + ('</' + data.name + '>\n');
			} else {
				output += ' />\n';
			}

			return output;
		}

		function isNormalProp(name) {
			switch (name) {
				case 'children':
				case 'key':
				case 'ref':
					return false;
				default:
					return true;}
		}

		function convertObject(object, depth) {
			if (depth >= MAX_DEPTH) {
				return '[...omitted]';
			}
			var output = '{';
			var first = true;
			for (var _iterator4 = Object.getOwnPropertyNames(object), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[typeof Symbol === 'function' ? Symbol.iterator : '@@iterator']();;) {
				var _ref4;if (_isArray4) {
					if (_i4 >= _iterator4.length) break;_ref4 = _iterator4[_i4++];
				} else {
					_i4 = _iterator4.next();if (_i4.done) break;_ref4 = _i4.value;
				}var key = _ref4;
				if (!first) {
					output += ', ';
				}

				output += key + ': ' + convertValue(object[key], depth + 1);
				first = false;
			}
			return output + '}';
		}

		function convertValue(value) {
			var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
			if (!value) {
				return null;
			}

			switch (typeof value) {
				case 'string':
					return JSON.stringify(possiblyEllipsis(value).replace('\n', '\\n'));
				case 'boolean':
				case 'number':
					return JSON.stringify(value);
				case 'function':
					return '[function]';
				case 'object':
					return convertObject(value, depth);
				default:
					return null;}
		}

		function possiblyEllipsis(value) {
			if (value.length > MAX_STRING_LENGTH) {
				return value.slice(0, MAX_STRING_LENGTH) + '...';
			} else {
				return value;
			}
		}

		function indent(size) {
			return ' '.repeat(size * INDENTATION_SIZE);
		}

		module.exports = dumpReactTree;
	}, // Libraries/BugReporting/getReactData.js
	function (__inner_require__, exports, module) {
		function getData(element) {
			var children = null;
			var props = null;
			var state = null;
			var context = null;
			var updater = null;
			var name = null;
			var type = null;
			var text = null;
			var publicInstance = null;
			var nodeType = 'Native';

			if (typeof element !== 'object') {
				nodeType = 'Text';
				text = element + '';
			} else if (element._currentElement === null || element._currentElement === false) {
				nodeType = 'Empty';
			} else if (element._renderedComponent) {
				nodeType = 'NativeWrapper';
				children = [element._renderedComponent];
				props = element._instance.props;
				state = element._instance.state;
				context = element._instance.context;
				if (context && Object.keys(context).length === 0) {
					context = null;
				}
			} else if (element._renderedChildren) {
				children = childrenList(element._renderedChildren);
			} else if (element._currentElement && element._currentElement.props) {

				children = element._currentElement.props.children;
			}

			if (!props && element._currentElement && element._currentElement.props) {
				props = element._currentElement.props;
			}

			if (element._currentElement != null) {
				type = element._currentElement.type;
				if (typeof type === 'string') {
					name = type;
				} else if (element.getName) {
					nodeType = 'Composite';
					name = element.getName();

					if (element._renderedComponent && element._currentElement.props === element._renderedComponent._currentElement) {
						nodeType = 'Wrapper';
					}
					if (name === null) {
						name = 'No display name';
					}
				} else if (element._stringText) {
					nodeType = 'Text';
					text = element._stringText;
				} else {
					name = type.displayName || type.name || 'Unknown';
				}
			}

			if (element._instance) {
				var inst = element._instance;
				updater = {
					setState: inst.setState && inst.setState.bind(inst),
					forceUpdate: inst.forceUpdate && inst.forceUpdate.bind(inst),
					setInProps: inst.forceUpdate && setInProps.bind(null, element),
					setInState: inst.forceUpdate && setInState.bind(null, inst),
					setInContext: inst.forceUpdate && setInContext.bind(null, inst) };

				publicInstance = inst;

				if (inst._renderedChildren) {
					children = childrenList(inst._renderedChildren);
				}
			}

			return {
				nodeType: nodeType,
				type: type,
				name: name,
				props: props,
				state: state,
				context: context,
				children: children,
				text: text,
				updater: updater,
				publicInstance: publicInstance };
		}

		function setInProps(internalInst, path, value) {
			var element = internalInst._currentElement;
			internalInst._currentElement = babelHelpers.extends({}, element, {
				props: copyWithSet(element.props, path, value) });

			internalInst._instance.forceUpdate();
		}

		function setInState(inst, path, value) {
			setIn(inst.state, path, value);
			inst.forceUpdate();
		}

		function setInContext(inst, path, value) {
			setIn(inst.context, path, value);
			inst.forceUpdate();
		}

		function setIn(obj, path, value) {
			var last = path.pop();
			var parent = path.reduce(function (obj_, attr) {
				return obj_ ? obj_[attr] : null;
			}, obj);
			if (parent) {
				parent[last] = value;
			}
		}

		function childrenList(children) {
			var res = [];
			for (var name in children) {
				res.push(children[name]);
			}
			return res;
		}

		function copyWithSetImpl(obj, path, idx, value) {
			if (idx >= path.length) {
				return value;
			}
			var key = path[idx];
			var updated = Array.isArray(obj) ? obj.slice() : babelHelpers.extends({}, obj);

			updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
			return updated;
		}

		function copyWithSet(obj, path, value) {
			return copyWithSetImpl(obj, path, 0, value);
		}

		module.exports = getData;
	}, // Libraries/ReactIOS/renderApplication.js
	function (__inner_require__, exports, module) {
		var AppContainer = __inner_require__(202 /*Libraries/ReactIOS/AppContainer.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		__inner_require__(220 /*Libraries/Utilities/BackAndroid.ios.js*/);

		function renderApplication(RootComponent, initialProps, rootTag) {
			invariant(rootTag, 'Expect to have a valid rootTag, instead got ', rootTag);

			ReactNative.render(React.createElement(AppContainer, null, React.createElement(RootComponent, babelHelpers.extends({}, initialProps, {
				rootTag: rootTag }))), rootTag);
		}

		module.exports = renderApplication;
	}, // Libraries/ReactIOS/AppContainer.js
	function (__inner_require__, exports, module) {
		var RCTDeviceEventEmitter = require('react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = __inner_require__(90 /*__react__/lib/ReactNative.js*/);
		var Subscribable = __inner_require__(115 /*Libraries/Components/Subscribable.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		var Inspector = __DEV__ ? __inner_require__(203 /*Libraries/Inspector/Inspector.js*/) : null;
		var YellowBox = __DEV__ ? __inner_require__(219 /*Libraries/ReactIOS/YellowBox.js*/) : null;

		var AppContainer = React.createClass({ displayName: 'AppContainer',
			mixins: [Subscribable.Mixin],

			getInitialState: function getInitialState() {
				return { inspector: null, mainKey: 1 };
			},

			toggleElementInspector: function toggleElementInspector() {
				var _this = this;
				var inspector = !__DEV__ || this.state.inspector ? null : React.createElement(Inspector, {
					inspectedViewTag: ReactNative.findNodeHandle(this.refs.main),
					onRequestRerenderApp: function onRequestRerenderApp(updateInspectedViewTag) {
						_this.setState(function (s) {
							return { mainKey: s.mainKey + 1 };
						}, function () {
							return updateInspectedViewTag(ReactNative.findNodeHandle(_this.refs.main));
						});
					} });

				this.setState({ inspector: inspector });
			},

			componentDidMount: function componentDidMount() {
				this.addListenerOn(RCTDeviceEventEmitter, 'toggleElementInspector', this.toggleElementInspector);
			},

			render: function render() {
				var yellowBox = null;
				if (__DEV__) {
					yellowBox = React.createElement(YellowBox, null);
				}
				return React.createElement(View, { style: styles.appContainer }, React.createElement(View, {
					collapsable: !this.state.inspector,
					key: this.state.mainKey,
					style: styles.appContainer, ref: 'main' }, this.props.children), yellowBox, this.state.inspector);
			} });

		var styles = StyleSheet.create({
			appContainer: {
				flex: 1 } });

		module.exports = AppContainer;
	}, // Libraries/Inspector/Inspector.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var InspectorOverlay = __inner_require__(204 /*Libraries/Inspector/InspectorOverlay.js*/);
		var InspectorPanel = __inner_require__(209 /*Libraries/Inspector/InspectorPanel.js*/);
		var InspectorUtils = __inner_require__(205 /*Libraries/Inspector/InspectorUtils.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

		if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {

			window.__REACT_DEVTOOLS_GLOBAL_HOOK__.resolveRNStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		}var Inspector = function (_React$Component) {
			babelHelpers.inherits(Inspector, _React$Component);

			function Inspector(props) {
				babelHelpers.classCallCheck(this, Inspector);var _this = babelHelpers.possibleConstructorReturn(this, (Inspector.__proto__ || Object.getPrototypeOf(Inspector)).call(this, props));

				_this.state = {
					devtoolsAgent: null,
					hierarchy: null,
					panelPos: 'bottom',
					inspecting: true,
					perfing: false,
					inspected: null,
					selection: null,
					inspectedViewTag: _this.props.inspectedViewTag,
					networking: false };return _this;
			}babelHelpers.createClass(Inspector, [{ key: 'componentDidMount', value: function componentDidMount() {
					if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
						this.attachToDevtools = this.attachToDevtools.bind(this);
						window.__REACT_DEVTOOLS_GLOBAL_HOOK__.on('react-devtools', this.attachToDevtools);

						if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent) {
							this.attachToDevtools(window.__REACT_DEVTOOLS_GLOBAL_HOOK__.reactDevtoolsAgent);
						}
					}
				} }, { key: 'componentWillUnmount', value: function componentWillUnmount() {
					if (this._subs) {
						this._subs.map(function (fn) {
							return fn();
						});
					}
					if (window.__REACT_DEVTOOLS_GLOBAL_HOOK__) {
						window.__REACT_DEVTOOLS_GLOBAL_HOOK__.off('react-devtools', this.attachToDevtools);
					}
				} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(newProps) {
					this.setState({ inspectedViewTag: newProps.inspectedViewTag });
				} }, { key: 'attachToDevtools', value: function attachToDevtools(agent) {
					var _this2 = this;
					var _hideWait = null;
					var hlSub = agent.sub('highlight', function (_ref) {
						var node = _ref.node,
						    name = _ref.name,
						    props = _ref.props;
						clearTimeout(_hideWait);
						UIManager.measure(node, function (x, y, width, height, left, top) {
							_this2.setState({
								hierarchy: [],
								inspected: {
									frame: { left: left, top: top, width: width, height: height },
									style: props ? props.style : {} } });
						});
					});
					var hideSub = agent.sub('hideHighlight', function () {
						if (_this2.state.inspected === null) {
							return;
						}

						_hideWait = setTimeout(function () {
							_this2.setState({
								inspected: null });
						}, 100);
					});
					this._subs = [hlSub, hideSub];

					agent.on('shutdown', function () {
						_this2.setState({ devtoolsAgent: null });
						_this2._subs = null;
					});
					this.setState({
						devtoolsAgent: agent });
				} }, { key: 'setSelection', value: function setSelection(i) {
					var _this3 = this;
					var instance = this.state.hierarchy[i];

					var publicInstance = instance['_instance'] || {};
					var source = instance['_currentElement'] && instance['_currentElement']['_source'];
					UIManager.measure(instance.getHostNode(), function (x, y, width, height, left, top) {
						_this3.setState({
							inspected: {
								frame: { left: left, top: top, width: width, height: height },
								style: publicInstance.props ? publicInstance.props.style : {},
								source: source },

							selection: i });
					});
				} }, { key: 'onTouchInstance', value: function onTouchInstance(touched, frame, pointerY) {

					var hierarchy = InspectorUtils.getOwnerHierarchy(touched);
					var instance = InspectorUtils.lastNotNativeInstance(hierarchy);

					if (this.state.devtoolsAgent) {
						this.state.devtoolsAgent.selectFromReactInstance(instance, true);
					}

					var publicInstance = instance['_instance'] || {};
					var props = publicInstance.props || {};
					var source = instance['_currentElement'] && instance['_currentElement']['_source'];
					this.setState({
						panelPos: pointerY > Dimensions.get('window').height / 2 ? 'top' : 'bottom',
						selection: hierarchy.indexOf(instance),
						hierarchy: hierarchy,
						inspected: {
							style: props.style || {},
							frame: frame,
							source: source } });
				} }, { key: 'setPerfing', value: function setPerfing(val) {
					this.setState({
						perfing: val,
						inspecting: false,
						inspected: null,
						networking: false });
				} }, { key: 'setInspecting', value: function setInspecting(val) {
					this.setState({
						inspecting: val,
						inspected: null });
				} }, { key: 'setTouchTargetting', value: function setTouchTargetting(val) {
					var _this4 = this;
					Touchable.TOUCH_TARGET_DEBUG = val;
					this.props.onRequestRerenderApp(function (inspectedViewTag) {
						_this4.setState({ inspectedViewTag: inspectedViewTag });
					});
				} }, { key: 'setNetworking', value: function setNetworking(val) {
					this.setState({
						networking: val,
						perfing: false,
						inspecting: false,
						inspected: null });
				} }, { key: 'render', value: function render() {
					var panelContainerStyle = this.state.panelPos === 'bottom' ? { bottom: 0 } : { top: 0 };
					return React.createElement(View, { style: styles.container, pointerEvents: 'box-none' }, this.state.inspecting && React.createElement(InspectorOverlay, {
						inspected: this.state.inspected,
						inspectedViewTag: this.state.inspectedViewTag,
						onTouchInstance: this.onTouchInstance.bind(this) }), React.createElement(View, { style: [styles.panelContainer, panelContainerStyle] }, React.createElement(InspectorPanel, {
						devtoolsIsOpen: !!this.state.devtoolsAgent,
						inspecting: this.state.inspecting,
						perfing: this.state.perfing,
						setPerfing: this.setPerfing.bind(this),
						setInspecting: this.setInspecting.bind(this),
						inspected: this.state.inspected,
						hierarchy: this.state.hierarchy,
						selection: this.state.selection,
						setSelection: this.setSelection.bind(this),
						touchTargetting: Touchable.TOUCH_TARGET_DEBUG,
						setTouchTargetting: this.setTouchTargetting.bind(this),
						networking: this.state.networking,
						setNetworking: this.setNetworking.bind(this) })));
				} }]);return Inspector;
		}(React.Component);

		var styles = StyleSheet.create({
			container: {
				position: 'absolute',
				backgroundColor: 'transparent',
				top: 0,
				left: 0,
				right: 0,
				bottom: 0 },

			panelContainer: {
				position: 'absolute',
				left: 0,
				right: 0 } });

		module.exports = Inspector;
	}, // Libraries/Inspector/InspectorOverlay.js
	function (__inner_require__, exports, module) {
		var Dimensions = __inner_require__(28 /*Libraries/Utilities/Dimensions.js*/);
		var InspectorUtils = __inner_require__(205 /*Libraries/Inspector/InspectorUtils.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var UIManager = require('react-native@0.33/Libraries/Utilities/UIManager.js');
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var ElementBox = __inner_require__(206 /*Libraries/Inspector/ElementBox.js*/);

		var PropTypes = React.PropTypes;var InspectorOverlay = function (_React$Component) {
			babelHelpers.inherits(InspectorOverlay, _React$Component);function InspectorOverlay() {
				var _ref;var _temp, _this, _ret;babelHelpers.classCallCheck(this, InspectorOverlay);for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
					args[_key] = arguments[_key];
				}return _ret = (_temp = (_this = babelHelpers.possibleConstructorReturn(this, (_ref = InspectorOverlay.__proto__ || Object.getPrototypeOf(InspectorOverlay)).call.apply(_ref, [this].concat(args))), _this), _this.findViewForTouchEvent = function (e) {
					var _e$nativeEvent$touche = e.nativeEvent.touches[0],
					    locationX = _e$nativeEvent$touche.locationX,
					    locationY = _e$nativeEvent$touche.locationY;
					UIManager.findSubviewIn(_this.props.inspectedViewTag, [locationX, locationY], function (nativeViewTag, left, top, width, height) {
						var instance = InspectorUtils.findInstanceByNativeTag(nativeViewTag);
						if (!instance) {
							return;
						}
						_this.props.onTouchInstance(instance, { left: left, top: top, width: width, height: height }, locationY);
					});
				}, _this.shouldSetResponser = function (e) {
					_this.findViewForTouchEvent(e);
					return true;
				}, _temp), babelHelpers.possibleConstructorReturn(_this, _ret);
			}babelHelpers.createClass(InspectorOverlay, [{ key: 'render', value: function render() {
					var content = null;
					if (this.props.inspected) {
						content = React.createElement(ElementBox, { frame: this.props.inspected.frame, style: this.props.inspected.style });
					}

					return React.createElement(View, {
						onStartShouldSetResponder: this.shouldSetResponser,
						onResponderMove: this.findViewForTouchEvent,
						style: [styles.inspector, { height: Dimensions.get('window').height }] }, content);
				} }]);return InspectorOverlay;
		}(React.Component);InspectorOverlay.propTypes = { inspected: PropTypes.shape({ frame: PropTypes.object, style: PropTypes.any }), inspectedViewTag: PropTypes.number, onTouchInstance: PropTypes.func.isRequired };

		var styles = StyleSheet.create({
			inspector: {
				backgroundColor: 'transparent',
				position: 'absolute',
				left: 0,
				top: 0,
				right: 0 } });

		module.exports = InspectorOverlay;
	}, // Libraries/Inspector/InspectorUtils.js
	function (__inner_require__, exports, module) {
		var ReactNativeComponentTree = require('react-native@0.33/__react__/lib/ReactNativeComponentTree.js');

		function traverseOwnerTreeUp(hierarchy, instance) {
			if (instance) {
				hierarchy.unshift(instance);
				traverseOwnerTreeUp(hierarchy, instance._currentElement._owner);
			}
		}

		function findInstanceByNativeTag(nativeTag) {
			return ReactNativeComponentTree.getInstanceFromNode(nativeTag);
		}

		function getOwnerHierarchy(instance) {
			var hierarchy = [];
			traverseOwnerTreeUp(hierarchy, instance);
			return hierarchy;
		}

		function lastNotNativeInstance(hierarchy) {
			for (var i = hierarchy.length - 1; i > 1; i--) {
				var instance = hierarchy[i];
				if (!instance.viewConfig) {
					return instance;
				}
			}
			return hierarchy[0];
		}

		module.exports = { findInstanceByNativeTag: findInstanceByNativeTag, getOwnerHierarchy: getOwnerHierarchy, lastNotNativeInstance: lastNotNativeInstance };
	}, // Libraries/Inspector/ElementBox.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var BorderBox = __inner_require__(207 /*Libraries/Inspector/BorderBox.js*/);
		var resolveBoxStyle = __inner_require__(208 /*Libraries/Inspector/resolveBoxStyle.js*/);

		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');var ElementBox = function (_React$Component) {
			babelHelpers.inherits(ElementBox, _React$Component);function ElementBox() {
				babelHelpers.classCallCheck(this, ElementBox);return babelHelpers.possibleConstructorReturn(this, (ElementBox.__proto__ || Object.getPrototypeOf(ElementBox)).apply(this, arguments));
			}babelHelpers.createClass(ElementBox, [{ key: 'render', value: function render() {
					var style = flattenStyle(this.props.style) || {};
					var margin = resolveBoxStyle('margin', style);
					var padding = resolveBoxStyle('padding', style);
					var frameStyle = this.props.frame;
					if (margin) {
						frameStyle = {
							top: frameStyle.top - margin.top,
							left: frameStyle.left - margin.left,
							height: frameStyle.height + margin.top + margin.bottom,
							width: frameStyle.width + margin.left + margin.right };
					}
					var contentStyle = {
						width: this.props.frame.width,
						height: this.props.frame.height };

					if (padding) {
						contentStyle = {
							width: contentStyle.width - padding.left - padding.right,
							height: contentStyle.height - padding.top - padding.bottom };
					}
					return React.createElement(View, { style: [styles.frame, frameStyle], pointerEvents: 'none' }, React.createElement(BorderBox, { box: margin, style: styles.margin }, React.createElement(BorderBox, { box: padding, style: styles.padding }, React.createElement(View, { style: [styles.content, contentStyle] }))));
				} }]);return ElementBox;
		}(React.Component);

		var styles = StyleSheet.create({
			frame: {
				position: 'absolute' },

			content: {
				backgroundColor: 'rgba(200, 230, 255, 0.8)' },

			padding: {
				borderColor: 'rgba(77, 255, 0, 0.3)' },

			margin: {
				borderColor: 'rgba(255, 132, 0, 0.3)' } });

		module.exports = ElementBox;
	}, // Libraries/Inspector/BorderBox.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var BorderBox = function (_React$Component) {
			babelHelpers.inherits(BorderBox, _React$Component);function BorderBox() {
				babelHelpers.classCallCheck(this, BorderBox);return babelHelpers.possibleConstructorReturn(this, (BorderBox.__proto__ || Object.getPrototypeOf(BorderBox)).apply(this, arguments));
			}babelHelpers.createClass(BorderBox, [{ key: 'render', value: function render() {
					var box = this.props.box;
					if (!box) {
						return this.props.children;
					}
					var style = {
						borderTopWidth: box.top,
						borderBottomWidth: box.bottom,
						borderLeftWidth: box.left,
						borderRightWidth: box.right };

					return React.createElement(View, { style: [style, this.props.style] }, this.props.children);
				} }]);return BorderBox;
		}(React.Component);

		module.exports = BorderBox;
	}, // Libraries/Inspector/resolveBoxStyle.js
	function (__inner_require__, exports, module) {
		function resolveBoxStyle(prefix, style) {
			var res = {};
			var subs = ['top', 'left', 'bottom', 'right'];
			var set = false;
			subs.forEach(function (sub) {
				res[sub] = style[prefix] || 0;
			});
			if (style[prefix]) {
				set = true;
			}
			if (style[prefix + 'Vertical']) {
				res.top = res.bottom = style[prefix + 'Vertical'];
				set = true;
			}
			if (style[prefix + 'Horizontal']) {
				res.left = res.right = style[prefix + 'Horizontal'];
				set = true;
			}
			subs.forEach(function (sub) {
				var val = style[prefix + capFirst(sub)];
				if (val) {
					res[sub] = val;
					set = true;
				}
			});
			if (!set) {
				return;
			}
			return res;
		}

		function capFirst(text) {
			return text[0].toUpperCase() + text.slice(1);
		}

		module.exports = resolveBoxStyle;
	}, // Libraries/Inspector/InspectorPanel.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var ElementProperties = __inner_require__(210 /*Libraries/Inspector/ElementProperties.js*/);
		var PerformanceOverlay = __inner_require__(215 /*Libraries/Inspector/PerformanceOverlay.js*/);
		var Touchable = __inner_require__(169 /*Libraries/Components/Touchable/Touchable.js*/);
		var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
		var NetworkOverlay = __inner_require__(216 /*Libraries/Inspector/NetworkOverlay.js*/);

		var PropTypes = React.PropTypes;var InspectorPanel = function (_React$Component) {
			babelHelpers.inherits(InspectorPanel, _React$Component);function InspectorPanel() {
				babelHelpers.classCallCheck(this, InspectorPanel);return babelHelpers.possibleConstructorReturn(this, (InspectorPanel.__proto__ || Object.getPrototypeOf(InspectorPanel)).apply(this, arguments));
			}babelHelpers.createClass(InspectorPanel, [{ key: 'renderWaiting', value: function renderWaiting() {
					if (this.props.inspecting) {
						return React.createElement(Text, { style: styles.waitingText }, 'Tap something to inspect it');
					}
					return React.createElement(Text, { style: styles.waitingText }, 'Nothing is inspected');
				} }, { key: 'render', value: function render() {
					var contents;
					if (this.props.inspected) {
						contents = React.createElement(ElementProperties, {
							style: this.props.inspected.style,
							frame: this.props.inspected.frame,
							source: this.props.inspected.source,
							hierarchy: this.props.hierarchy,
							selection: this.props.selection,
							setSelection: this.props.setSelection });
					} else if (this.props.perfing) {
						contents = React.createElement(PerformanceOverlay, null);
					} else if (this.props.networking) {
						contents = React.createElement(NetworkOverlay, null);
					} else {
						contents = React.createElement(View, { style: styles.waiting }, this.renderWaiting());
					}
					return React.createElement(View, { style: styles.container }, !this.props.devtoolsIsOpen && contents, React.createElement(View, { style: styles.buttonRow }, React.createElement(Button, {
						title: 'Inspect',
						pressed: this.props.inspecting,
						onClick: this.props.setInspecting }), React.createElement(Button, { title: 'Perf',
						pressed: this.props.perfing,
						onClick: this.props.setPerfing }), React.createElement(Button, { title: 'Network',
						pressed: this.props.networking,
						onClick: this.props.setNetworking }), React.createElement(Button, { title: 'Touchables',
						pressed: this.props.touchTargetting,
						onClick: this.props.setTouchTargetting })));
				} }]);return InspectorPanel;
		}(React.Component);

		InspectorPanel.propTypes = {
			devtoolsIsOpen: PropTypes.bool,
			inspecting: PropTypes.bool,
			setInspecting: PropTypes.func,
			inspected: PropTypes.object,
			perfing: PropTypes.bool,
			setPerfing: PropTypes.func,
			touchTargetting: PropTypes.bool,
			setTouchTargetting: PropTypes.func,
			networking: PropTypes.bool,
			setNetworking: PropTypes.func };var Button = function (_React$Component2) {
			babelHelpers.inherits(Button, _React$Component2);function Button() {
				babelHelpers.classCallCheck(this, Button);return babelHelpers.possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
			}babelHelpers.createClass(Button, [{ key: 'render', value: function render() {
					var _this3 = this;
					return React.createElement(TouchableHighlight, { onPress: function onPress() {
							return _this3.props.onClick(!_this3.props.pressed);
						}, style: [styles.button, this.props.pressed && styles.buttonPressed] }, React.createElement(Text, { style: styles.buttonText }, this.props.title));
				} }]);return Button;
		}(React.Component);

		var styles = StyleSheet.create({
			buttonRow: {
				flexDirection: 'row' },

			button: {
				backgroundColor: 'rgba(0, 0, 0, 0.3)',
				margin: 2,
				height: 30,
				justifyContent: 'center',
				alignItems: 'center' },

			buttonPressed: {
				backgroundColor: 'rgba(255, 255, 255, 0.3)' },

			buttonText: {
				textAlign: 'center',
				color: 'white',
				margin: 5 },

			container: {
				backgroundColor: 'rgba(0, 0, 0, 0.7)' },

			waiting: {
				height: 100 },

			waitingText: {
				fontSize: 20,
				textAlign: 'center',
				marginVertical: 20,
				color: 'white' } });

		module.exports = InspectorPanel;
	}, // Libraries/Inspector/ElementProperties.js
	function (__inner_require__, exports, module) {
		var BoxInspector = __inner_require__(211 /*Libraries/Inspector/BoxInspector.js*/);
		var PropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleInspector = __inner_require__(212 /*Libraries/Inspector/StyleInspector.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
		var TouchableWithoutFeedback = __inner_require__(185 /*Libraries/Components/Touchable/TouchableWithoutFeedback.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var _require = require('react-native@0.33/Libraries/Fetch/fetch.js'),
		    fetch = _require.fetch;

		var flattenStyle = require('react-native@0.33/Libraries/StyleSheet/flattenStyle.js');
		var mapWithSeparator = __inner_require__(213 /*Libraries/Utilities/mapWithSeparator.js*/);
		var openFileInEditor = __inner_require__(214 /*Libraries/JavaScriptAppEngine/Initialization/openFileInEditor.js*/);var ElementProperties = function (_React$Component) {
			babelHelpers.inherits(ElementProperties, _React$Component);function ElementProperties() {
				babelHelpers.classCallCheck(this, ElementProperties);return babelHelpers.possibleConstructorReturn(this, (ElementProperties.__proto__ || Object.getPrototypeOf(ElementProperties)).apply(this, arguments));
			}babelHelpers.createClass(ElementProperties, [{ key: 'render', value: function render() {
					var _this2 = this;
					var style = flattenStyle(this.props.style);

					var selection = this.props.selection;
					var openFileButton;
					var source = this.props.source;var _ref = source || {},
					    fileName = _ref.fileName,
					    lineNumber = _ref.lineNumber;
					if (fileName && lineNumber) {
						var parts = fileName.split('/');
						var fileNameShort = parts[parts.length - 1];
						openFileButton = React.createElement(TouchableHighlight, {
							style: styles.openButton,
							onPress: openFileInEditor.bind(null, fileName, lineNumber) }, React.createElement(Text, { style: styles.openButtonTitle, numberOfLines: 1 }, fileNameShort, ':', lineNumber));
					}

					return React.createElement(TouchableWithoutFeedback, null, React.createElement(View, { style: styles.info }, React.createElement(View, { style: styles.breadcrumb }, mapWithSeparator(this.props.hierarchy, function (item, i) {
						return React.createElement(TouchableHighlight, {
							key: 'item-' + i,
							style: [styles.breadItem, i === selection && styles.selected],

							onPress: function onPress() {
								return _this2.props.setSelection(i);
							} }, React.createElement(Text, { style: styles.breadItemText }, getInstanceName(item)));
					}, function (i) {
						return React.createElement(Text, { key: 'sep-' + i, style: styles.breadSep }, '\u25B8');
					})), React.createElement(View, { style: styles.row }, React.createElement(View, { style: styles.col }, React.createElement(StyleInspector, { style: style }), openFileButton), React.createElement(BoxInspector, { style: style, frame: this.props.frame }))));
				} }]);return ElementProperties;
		}(React.Component);ElementProperties.propTypes = { hierarchy: PropTypes.array.isRequired, style: PropTypes.oneOfType([PropTypes.object, PropTypes.array, PropTypes.number]), source: PropTypes.shape({ fileName: PropTypes.string, lineNumber: PropTypes.number }) };

		function getInstanceName(instance) {
			if (instance.getName) {
				return instance.getName();
			}
			if (instance.constructor && instance.constructor.displayName) {
				return instance.constructor.displayName;
			}
			return 'Unknown';
		}

		var styles = StyleSheet.create({
			breadSep: {
				fontSize: 8,
				color: 'white' },

			breadcrumb: {
				flexDirection: 'row',
				flexWrap: 'wrap',
				alignItems: 'flex-start',
				marginBottom: 5 },

			selected: {
				borderColor: 'white',
				borderRadius: 5 },

			breadItem: {
				borderWidth: 1,
				borderColor: 'transparent',
				marginHorizontal: 2 },

			breadItemText: {
				fontSize: 10,
				color: 'white',
				marginHorizontal: 5 },

			row: {
				flexDirection: 'row',
				alignItems: 'center',
				justifyContent: 'space-between' },

			col: {
				flex: 1 },

			info: {
				padding: 10 },

			path: {
				color: 'white',
				fontSize: 9 },

			openButton: {
				padding: 10,
				backgroundColor: '#000',
				marginVertical: 5,
				marginRight: 5,
				borderRadius: 2 },

			openButtonTitle: {
				color: 'white',
				fontSize: 8 } });

		module.exports = ElementProperties;
	}, // Libraries/Inspector/BoxInspector.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var resolveBoxStyle = __inner_require__(208 /*Libraries/Inspector/resolveBoxStyle.js*/);

		var blank = {
			top: 0,
			left: 0,
			right: 0,
			bottom: 0 };var BoxInspector = function (_React$Component) {
			babelHelpers.inherits(BoxInspector, _React$Component);function BoxInspector() {
				babelHelpers.classCallCheck(this, BoxInspector);return babelHelpers.possibleConstructorReturn(this, (BoxInspector.__proto__ || Object.getPrototypeOf(BoxInspector)).apply(this, arguments));
			}babelHelpers.createClass(BoxInspector, [{ key: 'render', value: function render() {
					var frame = this.props.frame;
					var style = this.props.style;
					var margin = style && resolveBoxStyle('margin', style) || blank;
					var padding = style && resolveBoxStyle('padding', style) || blank;
					return React.createElement(BoxContainer, { title: 'margin', titleStyle: styles.marginLabel, box: margin }, React.createElement(BoxContainer, { title: 'padding', box: padding }, React.createElement(View, null, React.createElement(Text, { style: styles.innerText }, '(', frame.left, ', ', frame.top, ')'), React.createElement(Text, { style: styles.innerText }, frame.width, ' \xD7 ', frame.height))));
				} }]);return BoxInspector;
		}(React.Component);var BoxContainer = function (_React$Component2) {
			babelHelpers.inherits(BoxContainer, _React$Component2);function BoxContainer() {
				babelHelpers.classCallCheck(this, BoxContainer);return babelHelpers.possibleConstructorReturn(this, (BoxContainer.__proto__ || Object.getPrototypeOf(BoxContainer)).apply(this, arguments));
			}babelHelpers.createClass(BoxContainer, [{ key: 'render', value: function render() {
					var box = this.props.box;
					return React.createElement(View, { style: styles.box }, React.createElement(View, { style: styles.row }, React.createElement(Text, { style: [this.props.titleStyle, styles.label] }, this.props.title), React.createElement(Text, { style: styles.boxText }, box.top)), React.createElement(View, { style: styles.row }, React.createElement(Text, { style: styles.boxText }, box.left), this.props.children, React.createElement(Text, { style: styles.boxText }, box.right)), React.createElement(Text, { style: styles.boxText }, box.bottom));
				} }]);return BoxContainer;
		}(React.Component);

		var styles = StyleSheet.create({
			row: {
				flexDirection: 'row',
				alignItems: 'center',
				justifyContent: 'space-around' },

			marginLabel: {
				width: 60 },

			label: {
				fontSize: 10,
				color: 'rgb(255,100,0)',
				marginLeft: 5,
				flex: 1,
				textAlign: 'left',
				top: -3 },

			buffer: {
				fontSize: 10,
				color: 'yellow',
				flex: 1,
				textAlign: 'center' },

			innerText: {
				color: 'yellow',
				fontSize: 12,
				textAlign: 'center',
				width: 70 },

			box: {
				borderWidth: 1,
				borderColor: 'grey' },

			boxText: {
				color: 'white',
				fontSize: 12,
				marginHorizontal: 3,
				marginVertical: 2,
				textAlign: 'center' } });

		module.exports = BoxInspector;
	}, // Libraries/Inspector/StyleInspector.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var StyleInspector = function (_React$Component) {
			babelHelpers.inherits(StyleInspector, _React$Component);function StyleInspector() {
				babelHelpers.classCallCheck(this, StyleInspector);return babelHelpers.possibleConstructorReturn(this, (StyleInspector.__proto__ || Object.getPrototypeOf(StyleInspector)).apply(this, arguments));
			}babelHelpers.createClass(StyleInspector, [{ key: 'render', value: function render() {
					var _this2 = this;
					if (!this.props.style) {
						return React.createElement(Text, { style: styles.noStyle }, 'No style');
					}
					var names = Object.keys(this.props.style);
					return React.createElement(View, { style: styles.container }, React.createElement(View, null, names.map(function (name) {
						return React.createElement(Text, { key: name, style: styles.attr }, name, ':');
					})), React.createElement(View, null, names.map(function (name) {
						var value = typeof _this2.props.style[name] === 'object' ? JSON.stringify(_this2.props.style[name]) : _this2.props.style[name];
						return React.createElement(Text, { key: name, style: styles.value }, value);
					})));
				} }]);return StyleInspector;
		}(React.Component);

		var styles = StyleSheet.create({
			container: {
				flexDirection: 'row' },

			row: {
				flexDirection: 'row',
				alignItems: 'center',
				justifyContent: 'space-around' },

			attr: {
				fontSize: 10,
				color: '#ccc' },

			value: {
				fontSize: 10,
				color: 'white',
				marginLeft: 10 },

			noStyle: {
				color: 'white',
				fontSize: 10 } });

		module.exports = StyleInspector;
	}, // Libraries/Utilities/mapWithSeparator.js
	function (__inner_require__, exports, module) {
		function mapWithSeparator(items, itemRenderer, spacerRenderer) {
			var mapped = [];
			if (items.length > 0) {
				mapped.push(itemRenderer(items[0], 0, items));
				for (var ii = 1; ii < items.length; ii++) {
					mapped.push(spacerRenderer(ii - 1), itemRenderer(items[ii], ii, items));
				}
			}
			return mapped;
		}

		module.exports = mapWithSeparator;
	}, // Libraries/JavaScriptAppEngine/Initialization/openFileInEditor.js
	function (__inner_require__, exports, module) {
		var getDevServer = require('react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/getDevServer.js');

		function openFileInEditor(file, lineNumber) {
			fetch(getDevServer().url + 'open-stack-frame', {
				method: 'POST',
				body: JSON.stringify({ file: file, lineNumber: lineNumber }) });
		}

		module.exports = openFileInEditor;
	}, // Libraries/Inspector/PerformanceOverlay.js
	function (__inner_require__, exports, module) {
		var PerformanceLogger = require('react-native@0.33/Libraries/Utilities/PerformanceLogger.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var PerformanceOverlay = function (_React$Component) {
			babelHelpers.inherits(PerformanceOverlay, _React$Component);function PerformanceOverlay() {
				babelHelpers.classCallCheck(this, PerformanceOverlay);return babelHelpers.possibleConstructorReturn(this, (PerformanceOverlay.__proto__ || Object.getPrototypeOf(PerformanceOverlay)).apply(this, arguments));
			}babelHelpers.createClass(PerformanceOverlay, [{ key: 'render', value: function render() {
					var perfLogs = PerformanceLogger.getTimespans();
					var items = [];

					for (var key in perfLogs) {
						if (perfLogs[key].totalTime) {
							var unit = key === 'BundleSize' ? 'b' : 'ms';
							items.push(React.createElement(View, { style: styles.row, key: key }, React.createElement(Text, { style: [styles.text, styles.label] }, key), React.createElement(Text, { style: [styles.text, styles.totalTime] }, perfLogs[key].totalTime + unit)));
						}
					}

					return React.createElement(View, { style: styles.container }, items);
				} }]);return PerformanceOverlay;
		}(React.Component);

		var styles = StyleSheet.create({
			container: {
				height: 100,
				paddingTop: 10 },

			label: {
				flex: 1 },

			row: {
				flexDirection: 'row',
				paddingHorizontal: 10 },

			text: {
				color: 'white',
				fontSize: 12 },

			totalTime: {
				paddingRight: 100 } });

		module.exports = PerformanceOverlay;
	}, // Libraries/Inspector/NetworkOverlay.js
	function (__inner_require__, exports, module) {
		var ListView = __inner_require__(87 /*Libraries/CustomComponents/ListView/ListView.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var RecyclerViewBackedScrollView = __inner_require__(153 /*Libraries/Components/ScrollView/RecyclerViewBackedScrollView.ios.js*/);
		var ScrollView = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
		var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);
		var WebSocketInterceptor = __inner_require__(217 /*Libraries/Utilities/WebSocketInterceptor.js*/);
		var XHRInterceptor = __inner_require__(218 /*Libraries/Utilities/XHRInterceptor.js*/);

		var LISTVIEW_CELL_HEIGHT = 15;
		var SEPARATOR_THICKNESS = 2;

		var nextXHRId = 0;var NetworkOverlay = function (_React$Component) {
			babelHelpers.inherits(NetworkOverlay, _React$Component);

			function NetworkOverlay(props) {
				babelHelpers.classCallCheck(this, NetworkOverlay);var _this = babelHelpers.possibleConstructorReturn(this, (NetworkOverlay.__proto__ || Object.getPrototypeOf(NetworkOverlay)).call(this, props));
				_this._requests = [];
				_this._detailViewItems = [];
				_this._listViewDataSource = new ListView.DataSource({ rowHasChanged: function rowHasChanged(r1, r2) {
						return r1 !== r2;
					} });
				_this.state = {
					dataSource: _this._listViewDataSource.cloneWithRows([]),
					newDetailInfo: false,
					detailRowID: null };

				_this._listViewHighlighted = false;
				_this._listViewHeight = 0;
				_this._captureRequestListView = _this._captureRequestListView.bind(_this);
				_this._captureDetailScrollView = _this._captureDetailScrollView.bind(_this);
				_this._listViewOnLayout = _this._listViewOnLayout.bind(_this);
				_this._renderRow = _this._renderRow.bind(_this);
				_this._renderScrollComponent = _this._renderScrollComponent.bind(_this);
				_this._closeButtonClicked = _this._closeButtonClicked.bind(_this);
				_this._socketIdMap = {};
				_this._xhrIdMap = {};return _this;
			}babelHelpers.createClass(NetworkOverlay, [{ key: '_enableXHRInterception', value: function _enableXHRInterception() {
					var _this2 = this;
					if (XHRInterceptor.isInterceptorEnabled()) {
						return;
					}

					XHRInterceptor.setOpenCallback(function (method, url, xhr) {

						xhr._index = nextXHRId++;
						var xhrIndex = _this2._requests.length;
						_this2._xhrIdMap[xhr._index] = xhrIndex;

						var _xhr = {
							'type': 'XMLHttpRequest',
							'method': method,
							'url': url };

						_this2._requests.push(_xhr);
						_this2._detailViewItems.push([]);
						_this2._genDetailViewItem(xhrIndex);
						_this2.setState({ dataSource: _this2._listViewDataSource.cloneWithRows(_this2._requests) }, _this2._scrollToBottom());
					});

					XHRInterceptor.setRequestHeaderCallback(function (header, value, xhr) {
						var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);
						if (xhrIndex === -1) {
							return;
						}
						var networkInfo = _this2._requests[xhrIndex];
						if (!networkInfo.requestHeaders) {
							networkInfo.requestHeaders = {};
						}
						networkInfo.requestHeaders[header] = value;
						_this2._genDetailViewItem(xhrIndex);
					});

					XHRInterceptor.setSendCallback(function (data, xhr) {
						var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);
						if (xhrIndex === -1) {
							return;
						}
						_this2._requests[xhrIndex].dataSent = data;
						_this2._genDetailViewItem(xhrIndex);
					});

					XHRInterceptor.setHeaderReceivedCallback(function (type, size, responseHeaders, xhr) {
						var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);
						if (xhrIndex === -1) {
							return;
						}
						var networkInfo = _this2._requests[xhrIndex];
						networkInfo.responseContentType = type;
						networkInfo.responseSize = size;
						networkInfo.responseHeaders = responseHeaders;
						_this2._genDetailViewItem(xhrIndex);
					});

					XHRInterceptor.setResponseCallback(function (status, timeout, response, responseURL, responseType, xhr) {
						var xhrIndex = _this2._getRequestIndexByXHRID(xhr._index);
						if (xhrIndex === -1) {
							return;
						}
						var networkInfo = _this2._requests[xhrIndex];
						networkInfo.status = status;
						networkInfo.timeout = timeout;
						networkInfo.response = response;
						networkInfo.responseURL = responseURL;
						networkInfo.responseType = responseType;
						_this2._genDetailViewItem(xhrIndex);
					});

					XHRInterceptor.enableInterception();
				} }, { key: '_enableWebSocketInterception', value: function _enableWebSocketInterception() {
					var _this3 = this;
					if (WebSocketInterceptor.isInterceptorEnabled()) {
						return;
					}

					WebSocketInterceptor.setConnectCallback(function (url, protocols, options, socketId) {
						var socketIndex = _this3._requests.length;
						_this3._socketIdMap[socketId] = socketIndex;
						var _webSocket = {
							'type': 'WebSocket',
							'url': url,
							'protocols': protocols };

						_this3._requests.push(_webSocket);
						_this3._detailViewItems.push([]);
						_this3._genDetailViewItem(socketIndex);
						_this3.setState({ dataSource: _this3._listViewDataSource.cloneWithRows(_this3._requests) }, _this3._scrollToBottom());
					});

					WebSocketInterceptor.setCloseCallback(function (statusCode, closeReason, socketId) {
						var socketIndex = _this3._socketIdMap[socketId];
						if (socketIndex === undefined) {
							return;
						}
						if (statusCode !== null && closeReason !== null) {
							_this3._requests[socketIndex].status = statusCode;
							_this3._requests[socketIndex].closeReason = closeReason;
						}
						_this3._genDetailViewItem(socketIndex);
					});

					WebSocketInterceptor.setSendCallback(function (data, socketId) {
						var socketIndex = _this3._socketIdMap[socketId];
						if (socketIndex === undefined) {
							return;
						}
						if (!_this3._requests[socketIndex].messages) {
							_this3._requests[socketIndex].messages = '';
						}
						_this3._requests[socketIndex].messages += 'Sent: ' + JSON.stringify(data) + '\n';
						_this3._genDetailViewItem(socketIndex);
					});

					WebSocketInterceptor.setOnMessageCallback(function (socketId, message) {
						var socketIndex = _this3._socketIdMap[socketId];
						if (socketIndex === undefined) {
							return;
						}
						if (!_this3._requests[socketIndex].messages) {
							_this3._requests[socketIndex].messages = '';
						}
						_this3._requests[socketIndex].messages += 'Received: ' + JSON.stringify(message) + '\n';
						_this3._genDetailViewItem(socketIndex);
					});

					WebSocketInterceptor.setOnCloseCallback(function (socketId, message) {
						var socketIndex = _this3._socketIdMap[socketId];
						if (socketIndex === undefined) {
							return;
						}
						_this3._requests[socketIndex].serverClose = message;
						_this3._genDetailViewItem(socketIndex);
					});

					WebSocketInterceptor.setOnErrorCallback(function (socketId, message) {
						var socketIndex = _this3._socketIdMap[socketId];
						if (socketIndex === undefined) {
							return;
						}
						_this3._requests[socketIndex].serverError = message;
						_this3._genDetailViewItem(socketIndex);
					});

					WebSocketInterceptor.enableInterception();
				} }, { key: 'componentDidMount', value: function componentDidMount() {
					this._enableXHRInterception();
					this._enableWebSocketInterception();
				} }, { key: 'componentWillUnmount', value: function componentWillUnmount() {
					XHRInterceptor.disableInterception();
					WebSocketInterceptor.disableInterception();
				} }, { key: '_renderRow', value: function _renderRow(rowData, sectionID, rowID, highlightRow) {
					var _this4 = this;
					var urlCellViewStyle = styles.urlEvenCellView;
					var methodCellViewStyle = styles.methodEvenCellView;
					if (rowID % 2 === 1) {
						urlCellViewStyle = styles.urlOddCellView;
						methodCellViewStyle = styles.methodOddCellView;
					}
					return React.createElement(TouchableHighlight, { onPress: function onPress() {
							_this4._pressRow(rowID);
							highlightRow(sectionID, rowID);
						} }, React.createElement(View, null, React.createElement(View, { style: styles.tableRow }, React.createElement(View, { style: urlCellViewStyle }, React.createElement(Text, { style: styles.cellText, numberOfLines: 1 }, rowData.url)), React.createElement(View, { style: methodCellViewStyle }, React.createElement(Text, { style: styles.cellText, numberOfLines: 1 }, this._getTypeShortName(rowData.type))))));
				} }, { key: '_renderSeperator', value: function _renderSeperator(sectionID, rowID, adjacentRowHighlighted) {
					return React.createElement(View, {
						key: sectionID + '-' + rowID,
						style: {
							height: adjacentRowHighlighted ? SEPARATOR_THICKNESS : 0,
							backgroundColor: adjacentRowHighlighted ? '#3B5998' : '#CCCCCC' } });
				} }, { key: '_scrollToBottom', value: function _scrollToBottom() {
					if (this._listView) {
						var scrollResponder = this._listView.getScrollResponder();
						if (scrollResponder) {
							var scrollY = Math.max(this._requests.length * LISTVIEW_CELL_HEIGHT + (this._listViewHighlighted ? 2 * SEPARATOR_THICKNESS : 0) - this._listViewHeight, 0);

							scrollResponder.scrollResponderScrollTo({
								x: 0,
								y: scrollY,
								animated: true });
						}
					}
				} }, { key: '_captureRequestListView', value: function _captureRequestListView(listRef) {
					this._listView = listRef;
				} }, { key: '_listViewOnLayout', value: function _listViewOnLayout(event) {
					var height = event.nativeEvent.layout.height;
					this._listViewHeight = height;
				} }, { key: '_renderScrollComponent', value: function _renderScrollComponent(props) {
					return React.createElement(RecyclerViewBackedScrollView, props);
				} }, { key: '_pressRow', value: function _pressRow(rowID) {
					this._listViewHighlighted = true;
					this.setState({ detailRowID: rowID }, this._scrollToTop());
				} }, { key: '_scrollToTop', value: function _scrollToTop() {
					if (this._scrollView) {
						this._scrollView.scrollTo({
							y: 0,
							animated: false });
					}
				} }, { key: '_captureDetailScrollView', value: function _captureDetailScrollView(scrollRef) {
					this._scrollView = scrollRef;
				} }, { key: '_closeButtonClicked', value: function _closeButtonClicked() {
					this.setState({ detailRowID: null });
				} }, { key: '_getStringByValue', value: function _getStringByValue(value) {
					if (value === undefined) {
						return 'undefined';
					}
					if (typeof value === 'object') {
						return JSON.stringify(value);
					}
					if (typeof value === 'string' && value.length > 500) {
						return String(value).substr(0, 500).concat('\n***TRUNCATED TO 500 CHARACTERS***');
					}
					return value;
				} }, { key: '_getRequestIndexByXHRID', value: function _getRequestIndexByXHRID(index) {
					if (index === undefined) {
						return -1;
					}
					var xhrIndex = this._xhrIdMap[index];
					if (xhrIndex === undefined) {
						return -1;
					} else {
						return xhrIndex;
					}
				} }, { key: '_getTypeShortName', value: function _getTypeShortName(type) {
					if (type === 'XMLHttpRequest') {
						return 'XHR';
					} else if (type === 'WebSocket') {
						return 'WS';
					}

					return '';
				} }, { key: '_genDetailViewItem', value: function _genDetailViewItem(index) {
					this._detailViewItems[index] = [];
					var detailViewItem = this._detailViewItems[index];
					var requestItem = this._requests[index];
					for (var _key in requestItem) {
						detailViewItem.push(React.createElement(View, { style: styles.detailViewRow, key: _key }, React.createElement(Text, { style: [styles.detailViewText, styles.detailKeyCellView] }, _key), React.createElement(Text, { style: [styles.detailViewText, styles.detailValueCellView] }, this._getStringByValue(requestItem[_key]))));
					}

					if (this.state.detailRowID != null && Number(this.state.detailRowID) === index) {
						this.setState({ newDetailInfo: true });
					}
				} }, { key: 'render', value: function render() {
					return React.createElement(View, { style: styles.container }, this.state.detailRowID != null && React.createElement(TouchableHighlight, {
						style: styles.closeButton,
						onPress: this._closeButtonClicked }, React.createElement(View, null, React.createElement(Text, { style: styles.clostButtonText }, 'v'))), this.state.detailRowID != null && React.createElement(ScrollView, {
						style: styles.detailScrollView,
						ref: this._captureDetailScrollView }, this._detailViewItems[this.state.detailRowID]), React.createElement(View, { style: styles.listViewTitle }, this._requests.length > 0 && React.createElement(View, { style: styles.tableRow }, React.createElement(View, { style: styles.urlTitleCellView }, React.createElement(Text, { style: styles.cellText, numberOfLines: 1 }, 'URL')), React.createElement(View, { style: styles.methodTitleCellView }, React.createElement(Text, { style: styles.cellText, numberOfLines: 1 }, 'Type')))), React.createElement(ListView, {
						style: styles.listView,
						ref: this._captureRequestListView,
						dataSource: this.state.dataSource,
						renderRow: this._renderRow,
						renderScrollComponent: this._renderScrollComponent,
						enableEmptySections: true,
						renderSeparator: this._renderSeperator,
						onLayout: this._listViewOnLayout }));
				} }]);return NetworkOverlay;
		}(React.Component);

		var styles = StyleSheet.create({
			container: {
				paddingTop: 10,
				paddingBottom: 10,
				paddingLeft: 5,
				paddingRight: 5 },

			listViewTitle: {
				height: 20 },

			listView: {
				flex: 1,
				height: 60 },

			tableRow: {
				flexDirection: 'row',
				flex: 1 },

			cellText: {
				color: 'white',
				fontSize: 12 },

			methodTitleCellView: {
				height: 18,
				borderColor: '#DCD7CD',
				borderTopWidth: 1,
				borderBottomWidth: 1,
				borderRightWidth: 1,
				alignItems: 'center',
				justifyContent: 'center',
				backgroundColor: '#444',
				flex: 1 },

			urlTitleCellView: {
				height: 18,
				borderColor: '#DCD7CD',
				borderTopWidth: 1,
				borderBottomWidth: 1,
				borderLeftWidth: 1,
				borderRightWidth: 1,
				justifyContent: 'center',
				backgroundColor: '#444',
				flex: 5,
				paddingLeft: 3 },

			methodOddCellView: {
				height: 15,
				borderColor: '#DCD7CD',
				borderRightWidth: 1,
				alignItems: 'center',
				justifyContent: 'center',
				backgroundColor: '#000',
				flex: 1 },

			urlOddCellView: {
				height: 15,
				borderColor: '#DCD7CD',
				borderLeftWidth: 1,
				borderRightWidth: 1,
				justifyContent: 'center',
				backgroundColor: '#000',
				flex: 5,
				paddingLeft: 3 },

			methodEvenCellView: {
				height: 15,
				borderColor: '#DCD7CD',
				borderRightWidth: 1,
				alignItems: 'center',
				justifyContent: 'center',
				backgroundColor: '#888',
				flex: 1 },

			urlEvenCellView: {
				height: 15,
				borderColor: '#DCD7CD',
				borderLeftWidth: 1,
				borderRightWidth: 1,
				justifyContent: 'center',
				backgroundColor: '#888',
				flex: 5,
				paddingLeft: 3 },

			detailScrollView: {
				flex: 1,
				height: 180,
				marginTop: 5,
				marginBottom: 5 },

			detailKeyCellView: {
				flex: 1.3 },

			detailValueCellView: {
				flex: 2 },

			detailViewRow: {
				flexDirection: 'row',
				paddingHorizontal: 3 },

			detailViewText: {
				color: 'white',
				fontSize: 11 },

			clostButtonText: {
				color: 'white',
				fontSize: 10 },

			closeButton: {
				marginTop: 5,
				backgroundColor: '#888',
				justifyContent: 'center',
				alignItems: 'center' } });

		module.exports = NetworkOverlay;
	}, // Libraries/Utilities/WebSocketInterceptor.js
	function (__inner_require__, exports, module) {
		var RCTWebSocketModule = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').WebSocketModule;
		var NativeEventEmitter = require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');
		var base64 = require('base64-js@0.0.8/lib/b64.js');

		var originalRCTWebSocketConnect = RCTWebSocketModule.connect;
		var originalRCTWebSocketSend = RCTWebSocketModule.send;
		var originalRCTWebSocketSendBinary = RCTWebSocketModule.sendBinary;
		var originalRCTWebSocketClose = RCTWebSocketModule.close;

		var eventEmitter = void 0;
		var subscriptions = void 0;

		var closeCallback = void 0;
		var sendCallback = void 0;
		var connectCallback = void 0;
		var onOpenCallback = void 0;
		var onMessageCallback = void 0;
		var onErrorCallback = void 0;
		var onCloseCallback = void 0;

		var _isInterceptorEnabled = false;

		var WebSocketInterceptor = {

			setCloseCallback: function setCloseCallback(callback) {
				closeCallback = callback;
			},

			setSendCallback: function setSendCallback(callback) {
				sendCallback = callback;
			},

			setConnectCallback: function setConnectCallback(callback) {
				connectCallback = callback;
			},

			setOnOpenCallback: function setOnOpenCallback(callback) {
				onOpenCallback = callback;
			},

			setOnMessageCallback: function setOnMessageCallback(callback) {
				onMessageCallback = callback;
			},

			setOnErrorCallback: function setOnErrorCallback(callback) {
				onErrorCallback = callback;
			},

			setOnCloseCallback: function setOnCloseCallback(callback) {
				onCloseCallback = callback;
			},

			isInterceptorEnabled: function isInterceptorEnabled() {
				return _isInterceptorEnabled;
			},

			_unregisterEvents: function _unregisterEvents() {
				subscriptions.forEach(function (e) {
					return e.remove();
				});
				subscriptions = [];
			},

			_registerEvents: function _registerEvents() {
				subscriptions = [eventEmitter.addListener('websocketMessage', function (ev) {
					if (onMessageCallback) {
						onMessageCallback(ev.id, ev.type === 'binary' ? WebSocketInterceptor._arrayBufferToString(ev.data) : ev.data);
					}
				}), eventEmitter.addListener('websocketOpen', function (ev) {
					if (onOpenCallback) {
						onOpenCallback(ev.id);
					}
				}), eventEmitter.addListener('websocketClosed', function (ev) {
					if (onCloseCallback) {
						onCloseCallback(ev.id, { code: ev.code, reason: ev.reason });
					}
				}), eventEmitter.addListener('websocketFailed', function (ev) {
					if (onErrorCallback) {
						onErrorCallback(ev.id, { message: ev.message });
					}
				})];
			},

			enableInterception: function enableInterception() {
				if (_isInterceptorEnabled) {
					return;
				}
				eventEmitter = new NativeEventEmitter(RCTWebSocketModule);
				WebSocketInterceptor._registerEvents();

				RCTWebSocketModule.connect = function (url, protocols, options, socketId) {
					if (connectCallback) {
						connectCallback(url, protocols, options, socketId);
					}
					originalRCTWebSocketConnect.apply(this, arguments);
				};

				RCTWebSocketModule.send = function (data, socketId) {
					if (sendCallback) {
						sendCallback(data, socketId);
					}
					originalRCTWebSocketSend.apply(this, arguments);
				};

				RCTWebSocketModule.sendBinary = function (data, socketId) {
					if (sendCallback) {
						sendCallback(WebSocketInterceptor._arrayBufferToString(data), socketId);
					}
					originalRCTWebSocketSendBinary.apply(this, arguments);
				};

				RCTWebSocketModule.close = function () {
					if (closeCallback) {
						if (arguments.length === 3) {
							closeCallback(arguments[0], arguments[1], arguments[2]);
						} else {
							closeCallback(null, null, arguments[0]);
						}
					}
					originalRCTWebSocketClose.apply(this, arguments);
				};

				_isInterceptorEnabled = true;
			},

			_arrayBufferToString: function _arrayBufferToString(data) {
				var value = base64.toByteArray(data).buffer;
				if (value === undefined || value === null) {
					return '(no value)';
				}
				if (typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && value instanceof ArrayBuffer) {
					return 'ArrayBuffer {' + String(Array.from(new Uint8Array(value))) + '}';
				}
				return value;
			},

			disableInterception: function disableInterception() {
				if (!_isInterceptorEnabled) {
					return;
				}
				_isInterceptorEnabled = false;
				RCTWebSocketModule.send = originalRCTWebSocketSend;
				RCTWebSocketModule.sendBinary = originalRCTWebSocketSendBinary;
				RCTWebSocketModule.close = originalRCTWebSocketClose;
				RCTWebSocketModule.connect = originalRCTWebSocketConnect;

				connectCallback = null;
				closeCallback = null;
				sendCallback = null;
				onOpenCallback = null;
				onMessageCallback = null;
				onCloseCallback = null;
				onErrorCallback = null;

				WebSocketInterceptor._unregisterEvents();
			} };

		module.exports = WebSocketInterceptor;
	}, // Libraries/Utilities/XHRInterceptor.js
	function (__inner_require__, exports, module) {
		var XMLHttpRequest = require('react-native@0.33/Libraries/Network/XMLHttpRequest.js');
		var originalXHROpen = XMLHttpRequest.prototype.open;
		var originalXHRSend = XMLHttpRequest.prototype.send;
		var originalXHRSetRequestHeader = XMLHttpRequest.prototype.setRequestHeader;

		var openCallback;
		var sendCallback;
		var requestHeaderCallback;
		var headerReceivedCallback;
		var responseCallback;

		var _isInterceptorEnabled = false;

		var XHRInterceptor = {

			setOpenCallback: function setOpenCallback(callback) {
				openCallback = callback;
			},

			setSendCallback: function setSendCallback(callback) {
				sendCallback = callback;
			},

			setHeaderReceivedCallback: function setHeaderReceivedCallback(callback) {
				headerReceivedCallback = callback;
			},

			setResponseCallback: function setResponseCallback(callback) {
				responseCallback = callback;
			},

			setRequestHeaderCallback: function setRequestHeaderCallback(callback) {
				requestHeaderCallback = callback;
			},

			isInterceptorEnabled: function isInterceptorEnabled() {
				return _isInterceptorEnabled;
			},

			enableInterception: function enableInterception() {
				if (_isInterceptorEnabled) {
					return;
				}

				XMLHttpRequest.prototype.open = function (method, url) {
					if (openCallback) {
						openCallback(method, url, this);
					}
					originalXHROpen.apply(this, arguments);
				};

				XMLHttpRequest.prototype.setRequestHeader = function (header, value) {
					if (requestHeaderCallback) {
						requestHeaderCallback(header, value, this);
					}
					originalXHRSetRequestHeader.apply(this, arguments);
				};

				XMLHttpRequest.prototype.send = function (data) {
					var _this = this;
					if (sendCallback) {
						sendCallback(data, this);
					}
					if (this.addEventListener) {
						this.addEventListener('readystatechange', function () {
							if (!_isInterceptorEnabled) {
								return;
							}
							if (_this.readyState === _this.HEADERS_RECEIVED) {
								var contentTypeString = _this.getResponseHeader('Content-Type');
								var contentLengthString = _this.getResponseHeader('Content-Length');
								var responseContentType = void 0,
								    responseSize = void 0;
								if (contentTypeString) {
									responseContentType = contentTypeString.split(';')[0];
								}
								if (contentLengthString) {
									responseSize = parseInt(contentLengthString, 10);
								}
								if (headerReceivedCallback) {
									headerReceivedCallback(responseContentType, responseSize, _this.getAllResponseHeaders(), _this);
								}
							}
							if (_this.readyState === _this.DONE) {
								if (responseCallback) {
									responseCallback(_this.status, _this.timeout, _this.response, _this.responseURL, _this.responseType, _this);
								}
							}
						}, false);
					}
					originalXHRSend.apply(this, arguments);
				};
				_isInterceptorEnabled = true;
			},

			disableInterception: function disableInterception() {
				if (!_isInterceptorEnabled) {
					return;
				}
				_isInterceptorEnabled = false;
				XMLHttpRequest.prototype.send = originalXHRSend;
				XMLHttpRequest.prototype.open = originalXHROpen;
				XMLHttpRequest.prototype.setRequestHeader = originalXHRSetRequestHeader;
				responseCallback = null;
				openCallback = null;
				sendCallback = null;
				headerReceivedCallback = null;
				requestHeaderCallback = null;
			} };

		module.exports = XHRInterceptor;
	}, // Libraries/ReactIOS/YellowBox.js
	function (__inner_require__, exports, module) {
		var EventEmitter = require('react-native@0.33/Libraries/EventEmitter/EventEmitter.js');
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);

		var infoLog = __inner_require__(126 /*Libraries/Utilities/infoLog.js*/);
		var openFileInEditor = __inner_require__(214 /*Libraries/JavaScriptAppEngine/Initialization/openFileInEditor.js*/);
		var parseErrorStack = require('react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/parseErrorStack.js');
		var symbolicateStackTrace = require('react-native@0.33/Libraries/JavaScriptAppEngine/Initialization/symbolicateStackTrace.js');

		var _warningEmitter = new EventEmitter();
		var _warningMap = new Map();

		if (__DEV__) {
			(function () {
				var _console = console,
				    error = _console.error,
				    warn = _console.warn;
				console.error = function () {
					error.apply(console, arguments);

					if (typeof arguments[0] === 'string' && arguments[0].startsWith('Warning: ')) {
						updateWarningMap.apply(null, arguments);
					}
				};
				console.warn = function () {
					warn.apply(console, arguments);
					updateWarningMap.apply(null, arguments);
				};
			})();
		}

		function sprintf(format) {
			for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
				args[_key - 1] = arguments[_key];
			}
			var index = 0;
			return format.replace(/%s/g, function (match) {
				return args[index++];
			});
		}

		function updateWarningMap(format) {
			if (console.disableYellowBox) {
				return;
			}
			var stringifySafe = require('react-native@0.33/Libraries/Utilities/stringifySafe.js');

			format = String(format);
			var argCount = (format.match(/%s/g) || []).length;for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
				args[_key2 - 1] = arguments[_key2];
			}
			var warning = [sprintf.apply(undefined, [format].concat(babelHelpers.toConsumableArray(args.slice(0, argCount))))].concat(babelHelpers.toConsumableArray(args.slice(argCount).map(stringifySafe))).join(' ');

			var warningInfo = _warningMap.get(warning);
			if (warningInfo) {
				warningInfo.count += 1;
			} else {
				var _error = new Error();
				_error.framesToPop = 2;

				_warningMap.set(warning, {
					count: 1,
					stacktrace: parseErrorStack(_error),
					symbolicated: false });
			}

			_warningEmitter.emit('warning', _warningMap);
		}

		function ensureSymbolicatedWarning(warning) {
			var prevWarningInfo = _warningMap.get(warning);
			if (!prevWarningInfo || prevWarningInfo.symbolicated) {
				return;
			}
			prevWarningInfo.symbolicated = true;

			symbolicateStackTrace(prevWarningInfo.stacktrace).then(function (stack) {
				var nextWarningInfo = _warningMap.get(warning);
				if (nextWarningInfo) {
					nextWarningInfo.stacktrace = stack;
					_warningEmitter.emit('warning', _warningMap);
				}
			}, function (error) {
				var nextWarningInfo = _warningMap.get(warning);
				if (nextWarningInfo) {
					infoLog('Failed to symbolicate warning, "%s":', warning, error);
					_warningEmitter.emit('warning', _warningMap);
				}
			});
		}

		function isWarningIgnored(warning) {
			return Array.isArray(console.ignoredYellowBox) && console.ignoredYellowBox.some(function (ignorePrefix) {
				return warning.startsWith(ignorePrefix);
			});
		}

		var WarningRow = function WarningRow(_ref) {
			var count = _ref.count,
			    warning = _ref.warning,
			    onPress = _ref.onPress;
			var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
			var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
			var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);

			var countText = count > 1 ? React.createElement(Text, { style: styles.listRowCount }, '(' + count + ') ') : null;

			return React.createElement(View, { style: styles.listRow }, React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				onPress: onPress,
				style: styles.listRowContent,
				underlayColor: 'transparent' }, React.createElement(Text, { style: styles.listRowText, numberOfLines: 2 }, countText, warning)));
		};

		var StackRow = function StackRow(_ref2) {
			var frame = _ref2.frame;
			var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
			var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);var file = frame.file,
			    lineNumber = frame.lineNumber;
			var fileParts = file.split('/');
			var fileName = fileParts[fileParts.length - 1];

			return React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				style: styles.openInEditorButton,
				underlayColor: 'transparent',
				onPress: openFileInEditor.bind(null, file, lineNumber) }, React.createElement(Text, { style: styles.inspectorCountText }, fileName, ':', lineNumber));
		};

		var WarningInspector = function WarningInspector(_ref3) {
			var warningInfo = _ref3.warningInfo,
			    warning = _ref3.warning,
			    stacktraceVisible = _ref3.stacktraceVisible,
			    onDismiss = _ref3.onDismiss,
			    onDismissAll = _ref3.onDismissAll,
			    onMinimize = _ref3.onMinimize,
			    toggleStacktrace = _ref3.toggleStacktrace;
			var ScrollView = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
			var Text = __inner_require__(168 /*Libraries/Text/Text.js*/);
			var TouchableHighlight = __inner_require__(189 /*Libraries/Components/Touchable/TouchableHighlight.js*/);
			var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var _ref4 = warningInfo || {},
			    count = _ref4.count,
			    stacktrace = _ref4.stacktrace;

			var countSentence = 'Warning encountered ' + count + ' time' + (count - 1 ? 's' : '') + '.';

			var stacktraceList = void 0;
			if (stacktraceVisible && stacktrace) {
				stacktraceList = React.createElement(View, { style: styles.stacktraceList }, stacktrace.map(function (frame, ii) {
					return React.createElement(StackRow, { frame: frame, key: ii });
				}));
			}

			return React.createElement(View, { style: styles.inspector }, React.createElement(View, { style: styles.inspectorCount }, React.createElement(Text, { style: styles.inspectorCountText }, countSentence), React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				onPress: toggleStacktrace,
				style: styles.toggleStacktraceButton,
				underlayColor: 'transparent' }, React.createElement(Text, { style: styles.inspectorButtonText }, stacktraceVisible ? 'Hide' : 'Show', ' Stacktrace'))), React.createElement(ScrollView, { style: styles.inspectorWarning }, stacktraceList, React.createElement(Text, { style: styles.inspectorWarningText }, warning)), React.createElement(View, { style: styles.inspectorButtons }, React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				onPress: onMinimize,
				style: styles.inspectorButton,
				underlayColor: 'transparent' }, React.createElement(Text, { style: styles.inspectorButtonText }, 'Minimize')), React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				onPress: onDismiss,
				style: styles.inspectorButton,
				underlayColor: 'transparent' }, React.createElement(Text, { style: styles.inspectorButtonText }, 'Dismiss')), React.createElement(TouchableHighlight, {
				activeOpacity: 0.5,
				onPress: onDismissAll,
				style: styles.inspectorButton,
				underlayColor: 'transparent' }, React.createElement(Text, { style: styles.inspectorButtonText }, 'Dismiss All'))));
		};var YellowBox = function (_React$Component) {
			babelHelpers.inherits(YellowBox, _React$Component);

			function YellowBox(props, context) {
				babelHelpers.classCallCheck(this, YellowBox);var _this = babelHelpers.possibleConstructorReturn(this, (YellowBox.__proto__ || Object.getPrototypeOf(YellowBox)).call(this, props, context));
				_this.state = {
					inspecting: null,
					stacktraceVisible: false,
					warningMap: _warningMap };

				_this.dismissWarning = function (warning) {
					var _this$state = _this.state,
					    inspecting = _this$state.inspecting,
					    warningMap = _this$state.warningMap;
					if (warning) {
						warningMap.delete(warning);
					} else {
						warningMap.clear();
					}
					_this.setState({
						inspecting: warning && inspecting !== warning ? inspecting : null,
						warningMap: warningMap });
				};return _this;
			}babelHelpers.createClass(YellowBox, [{ key: 'componentDidMount', value: function componentDidMount() {
					var _this2 = this;
					var scheduled = null;
					this._listener = _warningEmitter.addListener('warning', function (warningMap) {

						scheduled = scheduled || setImmediate(function () {
							scheduled = null;
							_this2.setState({
								warningMap: warningMap });
						});
					});
				} }, { key: 'componentDidUpdate', value: function componentDidUpdate() {
					var inspecting = this.state.inspecting;
					if (inspecting != null) {
						ensureSymbolicatedWarning(inspecting);
					}
				} }, { key: 'componentWillUnmount', value: function componentWillUnmount() {
					if (this._listener) {
						this._listener.remove();
					}
				} }, { key: 'render', value: function render() {
					var _this3 = this;
					if (console.disableYellowBox || this.state.warningMap.size === 0) {
						return null;
					}
					var ScrollView = __inner_require__(112 /*Libraries/Components/ScrollView/ScrollView.js*/);
					var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var _state = this.state,
					    inspecting = _state.inspecting,
					    stacktraceVisible = _state.stacktraceVisible;
					var inspector = inspecting !== null ? React.createElement(WarningInspector, {
						warningInfo: this.state.warningMap.get(inspecting),
						warning: inspecting,
						stacktraceVisible: stacktraceVisible,
						onDismiss: function onDismiss() {
							return _this3.dismissWarning(inspecting);
						},
						onDismissAll: function onDismissAll() {
							return _this3.dismissWarning(null);
						},
						onMinimize: function onMinimize() {
							return _this3.setState({ inspecting: null });
						},
						toggleStacktrace: function toggleStacktrace() {
							return _this3.setState({ stacktraceVisible: !stacktraceVisible });
						} }) : null;

					var rows = [];
					this.state.warningMap.forEach(function (warningInfo, warning) {
						if (!isWarningIgnored(warning)) {
							rows.push(React.createElement(WarningRow, {
								key: warning,
								count: warningInfo.count,
								warning: warning,
								onPress: function onPress() {
									return _this3.setState({ inspecting: warning });
								},
								onDismiss: function onDismiss() {
									return _this3.dismissWarning(warning);
								} }));
						}
					});

					var listStyle = [styles.list, { height: Math.min(rows.length, 4.4) * (rowGutter + rowHeight) }];

					return React.createElement(View, { style: inspector ? styles.fullScreen : listStyle }, React.createElement(ScrollView, { style: listStyle, scrollsToTop: false }, rows), inspector);
				} }]);return YellowBox;
		}(React.Component);

		var backgroundColor = function backgroundColor(opacity) {
			return 'rgba(250, 186, 48, ' + opacity + ')';
		};
		var textColor = 'white';
		var rowGutter = 1;
		var rowHeight = 46;

		var styles = StyleSheet.create({
			fullScreen: {
				backgroundColor: 'transparent',
				position: 'absolute',
				left: 0,
				right: 0,
				top: 0,
				bottom: 0 },

			inspector: {
				backgroundColor: backgroundColor(0.95),
				flex: 1,
				paddingTop: 5 },

			inspectorButtons: {
				flexDirection: 'row' },

			inspectorButton: {
				flex: 1,
				paddingVertical: 22,
				backgroundColor: backgroundColor(1) },

			toggleStacktraceButton: {
				flex: 1,
				padding: 5 },

			stacktraceList: {
				paddingBottom: 5 },

			inspectorButtonText: {
				color: textColor,
				fontSize: 14,
				opacity: 0.8,
				textAlign: 'center' },

			openInEditorButton: {
				paddingTop: 5,
				paddingBottom: 5 },

			inspectorCount: {
				padding: 15,
				paddingBottom: 0 },

			inspectorCountText: {
				color: textColor,
				fontSize: 14 },

			inspectorWarning: {
				flex: 1,
				paddingHorizontal: 15 },

			inspectorWarningText: {
				color: textColor,
				fontSize: 16,
				fontWeight: '600' },

			list: {
				backgroundColor: 'transparent',
				position: 'absolute',
				left: 0,
				right: 0,
				bottom: 0 },

			listRow: {
				position: 'relative',
				backgroundColor: backgroundColor(0.95),
				flex: 1,
				height: rowHeight,
				marginTop: rowGutter },

			listRowContent: {
				flex: 1 },

			listRowCount: {
				color: 'rgba(255, 255, 255, 0.5)' },

			listRowText: {
				color: textColor,
				position: 'absolute',
				left: 0,
				top: Platform.OS === 'android' ? 5 : 7,
				marginLeft: 15,
				marginRight: 15 } });

		module.exports = YellowBox;
	}, // Libraries/Utilities/BackAndroid.ios.js
	function (__inner_require__, exports, module) {
		function emptyFunction() {}

		var BackAndroid = {
			exitApp: emptyFunction,
			addEventListener: emptyFunction,
			removeEventListener: emptyFunction };

		module.exports = BackAndroid;
	}, // Libraries/Utilities/RCTRenderingPerf.js
	function (__inner_require__, exports, module) {
		var ReactPerf = __inner_require__(222 /*__react__/lib/ReactPerf.js*/);
		var ReactDebugTool = require('react-native@0.33/__react__/lib/ReactDebugTool.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var performanceNow = require('react-native@0.33/__fbjs__/lib/performanceNow.js');

		var perfModules = [];
		var enabled = false;
		var lastRenderStartTime = 0;
		var totalRenderDuration = 0;

		var RCTRenderingPerfDevtool = {
			onBeginLifeCycleTimer: function onBeginLifeCycleTimer(debugID, timerType) {
				if (timerType === 'render') {
					lastRenderStartTime = performanceNow();
				}
			},
			onEndLifeCycleTimer: function onEndLifeCycleTimer(debugID, timerType) {
				if (timerType === 'render') {
					var lastRenderDuration = performanceNow() - lastRenderStartTime;
					totalRenderDuration += lastRenderDuration;
				}
			} };

		var RCTRenderingPerf = {

			toggle: function toggle() {
				console.log('Render perfomance measurements enabled');
				enabled = true;
			},

			start: function start() {
				if (!enabled) {
					return;
				}

				ReactPerf.start();
				ReactDebugTool.addDevtool(RCTRenderingPerfDevtool);
				perfModules.forEach(function (module) {
					return module.start();
				});
			},

			stop: function stop() {
				if (!enabled) {
					return;
				}

				ReactPerf.stop();
				ReactPerf.printInclusive();
				ReactPerf.printWasted();
				ReactDebugTool.removeDevtool(RCTRenderingPerfDevtool);

				console.log('Total time spent in render(): ' + totalRenderDuration.toFixed(2) + ' ms');
				lastRenderStartTime = 0;
				totalRenderDuration = 0;

				perfModules.forEach(function (module) {
					return module.stop();
				});
			},

			register: function register(module) {
				invariant(typeof module.start === 'function', 'Perf module should have start() function');

				invariant(typeof module.stop === 'function', 'Perf module should have stop() function');

				perfModules.push(module);
			} };

		module.exports = RCTRenderingPerf;
	}, // __react__/lib/ReactPerf.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var _extends = _assign || function (target) {
			for (var i = 1; i < arguments.length; i++) {
				var source = arguments[i];for (var key in source) {
					if (Object.prototype.hasOwnProperty.call(source, key)) {
						target[key] = source[key];
					}
				}
			}return target;
		};

		var ReactDebugTool = require('react-native@0.33/__react__/lib/ReactDebugTool.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');
		var alreadyWarned = false;

		function roundFloat(val) {
			var base = arguments.length <= 1 || arguments[1] === undefined ? 2 : arguments[1];

			var n = Math.pow(10, base);
			return Math.floor(val * n) / n;
		}

		function warnInProduction() {
			if (alreadyWarned) {
				return;
			}
			alreadyWarned = true;
			if (typeof console !== 'undefined') {
				console.error('ReactPerf is not supported in the production builds of React. ' + 'To collect measurements, please use the development build of React instead.');
			}
		}

		function getLastMeasurements() {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return [];
			}

			return ReactDebugTool.getFlushHistory();
		}

		function getExclusive() {
			var flushHistory = arguments.length <= 0 || arguments[0] === undefined ? getLastMeasurements() : arguments[0];

			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return [];
			}

			var aggregatedStats = {};
			var affectedIDs = {};

			function updateAggregatedStats(treeSnapshot, instanceID, timerType, applyUpdate) {
				var displayName = treeSnapshot[instanceID].displayName;

				var key = displayName;
				var stats = aggregatedStats[key];
				if (!stats) {
					affectedIDs[key] = {};
					stats = aggregatedStats[key] = {
						key: key,
						instanceCount: 0,
						counts: {},
						durations: {},
						totalDuration: 0 };
				}
				if (!stats.durations[timerType]) {
					stats.durations[timerType] = 0;
				}
				if (!stats.counts[timerType]) {
					stats.counts[timerType] = 0;
				}
				affectedIDs[key][instanceID] = true;
				applyUpdate(stats);
			}

			flushHistory.forEach(function (flush) {
				var measurements = flush.measurements;
				var treeSnapshot = flush.treeSnapshot;

				measurements.forEach(function (measurement) {
					var duration = measurement.duration;
					var instanceID = measurement.instanceID;
					var timerType = measurement.timerType;

					updateAggregatedStats(treeSnapshot, instanceID, timerType, function (stats) {
						stats.totalDuration += duration;
						stats.durations[timerType] += duration;
						stats.counts[timerType]++;
					});
				});
			});

			return Object.keys(aggregatedStats).map(function (key) {
				return _extends({}, aggregatedStats[key], {
					instanceCount: Object.keys(affectedIDs[key]).length });
			}).sort(function (a, b) {
				return b.totalDuration - a.totalDuration;
			});
		}

		function getInclusive() {
			var flushHistory = arguments.length <= 0 || arguments[0] === undefined ? getLastMeasurements() : arguments[0];

			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return [];
			}

			var aggregatedStats = {};
			var affectedIDs = {};

			function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
				var _treeSnapshot$instanc = treeSnapshot[instanceID];
				var displayName = _treeSnapshot$instanc.displayName;
				var ownerID = _treeSnapshot$instanc.ownerID;

				var owner = treeSnapshot[ownerID];
				var key = (owner ? owner.displayName + ' > ' : '') + displayName;
				var stats = aggregatedStats[key];
				if (!stats) {
					affectedIDs[key] = {};
					stats = aggregatedStats[key] = {
						key: key,
						instanceCount: 0,
						inclusiveRenderDuration: 0,
						renderCount: 0 };
				}
				affectedIDs[key][instanceID] = true;
				applyUpdate(stats);
			}

			var isCompositeByID = {};
			flushHistory.forEach(function (flush) {
				var measurements = flush.measurements;

				measurements.forEach(function (measurement) {
					var instanceID = measurement.instanceID;
					var timerType = measurement.timerType;

					if (timerType !== 'render') {
						return;
					}
					isCompositeByID[instanceID] = true;
				});
			});

			flushHistory.forEach(function (flush) {
				var measurements = flush.measurements;
				var treeSnapshot = flush.treeSnapshot;

				measurements.forEach(function (measurement) {
					var duration = measurement.duration;
					var instanceID = measurement.instanceID;
					var timerType = measurement.timerType;

					if (timerType !== 'render') {
						return;
					}
					updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
						stats.renderCount++;
					});
					var nextParentID = instanceID;
					while (nextParentID) {

						if (isCompositeByID[nextParentID]) {
							updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
								stats.inclusiveRenderDuration += duration;
							});
						}
						nextParentID = treeSnapshot[nextParentID].parentID;
					}
				});
			});

			return Object.keys(aggregatedStats).map(function (key) {
				return _extends({}, aggregatedStats[key], {
					instanceCount: Object.keys(affectedIDs[key]).length });
			}).sort(function (a, b) {
				return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
			});
		}

		function getWasted() {
			var flushHistory = arguments.length <= 0 || arguments[0] === undefined ? getLastMeasurements() : arguments[0];

			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return [];
			}

			var aggregatedStats = {};
			var affectedIDs = {};

			function updateAggregatedStats(treeSnapshot, instanceID, applyUpdate) {
				var _treeSnapshot$instanc2 = treeSnapshot[instanceID];
				var displayName = _treeSnapshot$instanc2.displayName;
				var ownerID = _treeSnapshot$instanc2.ownerID;

				var owner = treeSnapshot[ownerID];
				var key = (owner ? owner.displayName + ' > ' : '') + displayName;
				var stats = aggregatedStats[key];
				if (!stats) {
					affectedIDs[key] = {};
					stats = aggregatedStats[key] = {
						key: key,
						instanceCount: 0,
						inclusiveRenderDuration: 0,
						renderCount: 0 };
				}
				affectedIDs[key][instanceID] = true;
				applyUpdate(stats);
			}

			flushHistory.forEach(function (flush) {
				var measurements = flush.measurements;
				var treeSnapshot = flush.treeSnapshot;
				var operations = flush.operations;

				var isDefinitelyNotWastedByID = {};

				operations.forEach(function (operation) {
					var instanceID = operation.instanceID;

					var nextParentID = instanceID;
					while (nextParentID) {
						isDefinitelyNotWastedByID[nextParentID] = true;
						nextParentID = treeSnapshot[nextParentID].parentID;
					}
				});

				var renderedCompositeIDs = {};
				measurements.forEach(function (measurement) {
					var instanceID = measurement.instanceID;
					var timerType = measurement.timerType;

					if (timerType !== 'render') {
						return;
					}
					renderedCompositeIDs[instanceID] = true;
				});

				measurements.forEach(function (measurement) {
					var duration = measurement.duration;
					var instanceID = measurement.instanceID;
					var timerType = measurement.timerType;

					if (timerType !== 'render') {
						return;
					}

					var updateCount = treeSnapshot[instanceID].updateCount;

					if (isDefinitelyNotWastedByID[instanceID] || updateCount === 0) {
						return;
					}

					updateAggregatedStats(treeSnapshot, instanceID, function (stats) {
						stats.renderCount++;
					});

					var nextParentID = instanceID;
					while (nextParentID) {

						var isWasted = renderedCompositeIDs[nextParentID] && !isDefinitelyNotWastedByID[nextParentID];
						if (isWasted) {
							updateAggregatedStats(treeSnapshot, nextParentID, function (stats) {
								stats.inclusiveRenderDuration += duration;
							});
						}
						nextParentID = treeSnapshot[nextParentID].parentID;
					}
				});
			});

			return Object.keys(aggregatedStats).map(function (key) {
				return _extends({}, aggregatedStats[key], {
					instanceCount: Object.keys(affectedIDs[key]).length });
			}).sort(function (a, b) {
				return b.inclusiveRenderDuration - a.inclusiveRenderDuration;
			});
		}

		function getOperations() {
			var flushHistory = arguments.length <= 0 || arguments[0] === undefined ? getLastMeasurements() : arguments[0];

			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return [];
			}

			var stats = [];
			flushHistory.forEach(function (flush, flushIndex) {
				var operations = flush.operations;
				var treeSnapshot = flush.treeSnapshot;

				operations.forEach(function (operation) {
					var instanceID = operation.instanceID;
					var type = operation.type;
					var payload = operation.payload;
					var _treeSnapshot$instanc3 = treeSnapshot[instanceID];
					var displayName = _treeSnapshot$instanc3.displayName;
					var ownerID = _treeSnapshot$instanc3.ownerID;

					var owner = treeSnapshot[ownerID];
					var key = (owner ? owner.displayName + ' > ' : '') + displayName;

					stats.push({
						flushIndex: flushIndex,
						instanceID: instanceID,
						key: key,
						type: type,
						ownerID: ownerID,
						payload: payload });
				});
			});
			return stats;
		}

		function printExclusive(flushHistory) {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			var stats = getExclusive(flushHistory);
			var table = stats.map(function (item) {
				var key = item.key;
				var instanceCount = item.instanceCount;
				var totalDuration = item.totalDuration;

				var renderCount = item.counts.render || 0;
				var renderDuration = item.durations.render || 0;
				return {
					'Component': key,
					'Total time (ms)': roundFloat(totalDuration),
					'Instance count': instanceCount,
					'Total render time (ms)': roundFloat(renderDuration),
					'Average render time (ms)': renderCount ? roundFloat(renderDuration / renderCount) : undefined,
					'Render count': renderCount,
					'Total lifecycle time (ms)': roundFloat(totalDuration - renderDuration) };
			});
			console.table(table);
		}

		function printInclusive(flushHistory) {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			var stats = getInclusive(flushHistory);
			var table = stats.map(function (item) {
				var key = item.key;
				var instanceCount = item.instanceCount;
				var inclusiveRenderDuration = item.inclusiveRenderDuration;
				var renderCount = item.renderCount;

				return {
					'Owner > Component': key,
					'Inclusive render time (ms)': roundFloat(inclusiveRenderDuration),
					'Instance count': instanceCount,
					'Render count': renderCount };
			});
			console.table(table);
		}

		function printWasted(flushHistory) {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			var stats = getWasted(flushHistory);
			var table = stats.map(function (item) {
				var key = item.key;
				var instanceCount = item.instanceCount;
				var inclusiveRenderDuration = item.inclusiveRenderDuration;
				var renderCount = item.renderCount;

				return {
					'Owner > Component': key,
					'Inclusive wasted time (ms)': roundFloat(inclusiveRenderDuration),
					'Instance count': instanceCount,
					'Render count': renderCount };
			});
			console.table(table);
		}

		function printOperations(flushHistory) {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			var stats = getOperations(flushHistory);
			var table = stats.map(function (stat) {
				return {
					'Owner > Node': stat.key,
					'Operation': stat.type,
					'Payload': typeof stat.payload === 'object' ? JSON.stringify(stat.payload) : stat.payload,
					'Flush index': stat.flushIndex,
					'Owner Component ID': stat.ownerID,
					'DOM Component ID': stat.instanceID };
			});
			console.table(table);
		}

		var warnedAboutPrintDOM = false;
		function printDOM(measurements) {
			process.env.NODE_ENV !== 'production' ? warning(warnedAboutPrintDOM, '`ReactPerf.printDOM(...)` is deprecated. Use ' + '`ReactPerf.printOperations(...)` instead.') : void 0;
			warnedAboutPrintDOM = true;
			return printOperations(measurements);
		}

		var warnedAboutGetMeasurementsSummaryMap = false;
		function getMeasurementsSummaryMap(measurements) {
			process.env.NODE_ENV !== 'production' ? warning(warnedAboutGetMeasurementsSummaryMap, '`ReactPerf.getMeasurementsSummaryMap(...)` is deprecated. Use ' + '`ReactPerf.getWasted(...)` instead.') : void 0;
			warnedAboutGetMeasurementsSummaryMap = true;
			return getWasted(measurements);
		}

		function start() {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			ReactDebugTool.beginProfiling();
		}

		function stop() {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return;
			}

			ReactDebugTool.endProfiling();
		}

		function isRunning() {
			if (!(process.env.NODE_ENV !== 'production')) {
				warnInProduction();
				return false;
			}

			return ReactDebugTool.isProfiling();
		}

		var ReactPerfAnalysis = {
			getLastMeasurements: getLastMeasurements,
			getExclusive: getExclusive,
			getInclusive: getInclusive,
			getWasted: getWasted,
			getOperations: getOperations,
			printExclusive: printExclusive,
			printInclusive: printInclusive,
			printWasted: printWasted,
			printOperations: printOperations,
			start: start,
			stop: stop,
			isRunning: isRunning,

			printDOM: printDOM,
			getMeasurementsSummaryMap: getMeasurementsSummaryMap };

		module.exports = ReactPerfAnalysis;
	}, // Libraries/AppState/AppStateIOS.js
	function (__inner_require__, exports, module) {
		var AppState = require('react-native@0.33/Libraries/AppState/AppState.js');

		console.warn('AppStateIOS is deprecated. Use AppState instead');

		module.exports = AppState;
	}, // Libraries/Storage/AsyncStorage.js
	function (__inner_require__, exports, module) {
		var NativeModules = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js');
		var RCTAsyncSQLiteStorage = NativeModules.AsyncSQLiteDBStorage;
		var RCTAsyncRocksDBStorage = NativeModules.AsyncRocksDBStorage;
		var RCTAsyncFileStorage = NativeModules.AsyncLocalStorage;

		var RCTAsyncStorage = RCTAsyncRocksDBStorage || RCTAsyncSQLiteStorage || RCTAsyncFileStorage;

		var AsyncStorage = {
			_getRequests: [],
			_getKeys: [],
			_immediate: null,

			getItem: function getItem(key, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiGet([key], function (errors, result) {

						var value = result && result[0] && result[0][1] ? result[0][1] : null;
						var errs = convertErrors(errors);
						callback && callback(errs && errs[0], value);
						if (errs) {
							reject(errs[0]);
						} else {
							resolve(value);
						}
					});
				});
			},

			setItem: function setItem(key, value, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiSet([[key, value]], function (errors) {
						var errs = convertErrors(errors);
						callback && callback(errs && errs[0]);
						if (errs) {
							reject(errs[0]);
						} else {
							resolve(null);
						}
					});
				});
			},

			removeItem: function removeItem(key, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiRemove([key], function (errors) {
						var errs = convertErrors(errors);
						callback && callback(errs && errs[0]);
						if (errs) {
							reject(errs[0]);
						} else {
							resolve(null);
						}
					});
				});
			},

			mergeItem: function mergeItem(key, value, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiMerge([[key, value]], function (errors) {
						var errs = convertErrors(errors);
						callback && callback(errs && errs[0]);
						if (errs) {
							reject(errs[0]);
						} else {
							resolve(null);
						}
					});
				});
			},

			clear: function clear(callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.clear(function (error) {
						callback && callback(convertError(error));
						if (error && convertError(error)) {
							reject(convertError(error));
						} else {
							resolve(null);
						}
					});
				});
			},

			getAllKeys: function getAllKeys(callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.getAllKeys(function (error, keys) {
						callback && callback(convertError(error), keys);
						if (error) {
							reject(convertError(error));
						} else {
							resolve(keys);
						}
					});
				});
			},

			flushGetRequests: function flushGetRequests() {
				var getRequests = this._getRequests;
				var getKeys = this._getKeys;

				this._getRequests = [];
				this._getKeys = [];

				RCTAsyncStorage.multiGet(getKeys, function (errors, result) {

					var map = {};
					result.forEach(function (_ref) {
						var _ref2 = babelHelpers.slicedToArray(_ref, 2),
						    key = _ref2[0],
						    value = _ref2[1];return map[key] = value;
					});
					var reqLength = getRequests.length;
					for (var i = 0; i < reqLength; i++) {
						var request = getRequests[i];
						var requestKeys = request.keys;
						var requestResult = requestKeys.map(function (key) {
							return [key, map[key]];
						});
						request.callback && request.callback(null, requestResult);
						request.resolve && request.resolve(requestResult);
					}
				});
			},

			multiGet: function multiGet(keys, callback) {
				var _this = this;
				if (!this._immediate) {
					this._immediate = setImmediate(function () {
						_this._immediate = null;
						_this.flushGetRequests();
					});
				}

				var getRequest = {
					keys: keys,
					callback: callback,

					keyIndex: this._getKeys.length,
					resolve: null,
					reject: null };

				var promiseResult = new Promise(function (resolve, reject) {
					getRequest.resolve = resolve;
					getRequest.reject = reject;
				});

				this._getRequests.push(getRequest);

				keys.forEach(function (key) {
					if (_this._getKeys.indexOf(key) === -1) {
						_this._getKeys.push(key);
					}
				});

				return promiseResult;
			},

			multiSet: function multiSet(keyValuePairs, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiSet(keyValuePairs, function (errors) {
						var error = convertErrors(errors);
						callback && callback(error);
						if (error) {
							reject(error);
						} else {
							resolve(null);
						}
					});
				});
			},

			multiRemove: function multiRemove(keys, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiRemove(keys, function (errors) {
						var error = convertErrors(errors);
						callback && callback(error);
						if (error) {
							reject(error);
						} else {
							resolve(null);
						}
					});
				});
			},

			multiMerge: function multiMerge(keyValuePairs, callback) {
				return new Promise(function (resolve, reject) {
					RCTAsyncStorage.multiMerge(keyValuePairs, function (errors) {
						var error = convertErrors(errors);
						callback && callback(error);
						if (error) {
							reject(error);
						} else {
							resolve(null);
						}
					});
				});
			} };

		if (!RCTAsyncStorage.multiMerge) {
			delete AsyncStorage.mergeItem;
			delete AsyncStorage.multiMerge;
		}

		function convertErrors(errs) {
			if (!errs) {
				return null;
			}
			return (Array.isArray(errs) ? errs : [errs]).map(function (e) {
				return convertError(e);
			});
		}

		function convertError(error) {
			if (!error) {
				return null;
			}
			var out = new Error(error.message);
			out.key = error.key;
			return out;
		}

		module.exports = AsyncStorage;
	}, // Libraries/CameraRoll/CameraRoll.js
	function (__inner_require__, exports, module) {
		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var RCTCameraRollManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').CameraRollManager;

		var createStrictShapeTypeChecker = __inner_require__(40 /*Libraries/Utilities/createStrictShapeTypeChecker.js*/);
		var deepFreezeAndThrowOnMutationInDev = __inner_require__(68 /*Libraries/Utilities/deepFreezeAndThrowOnMutationInDev.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var GROUP_TYPES_OPTIONS = ['Album', 'All', 'Event', 'Faces', 'Library', 'PhotoStream', 'SavedPhotos'];

		var ASSET_TYPE_OPTIONS = ['All', 'Videos', 'Photos'];

		deepFreezeAndThrowOnMutationInDev(GROUP_TYPES_OPTIONS);
		deepFreezeAndThrowOnMutationInDev(ASSET_TYPE_OPTIONS);

		var getPhotosParamChecker = createStrictShapeTypeChecker({

			first: ReactPropTypes.number.isRequired,

			after: ReactPropTypes.string,

			groupTypes: ReactPropTypes.oneOf(GROUP_TYPES_OPTIONS),

			groupName: ReactPropTypes.string,

			assetType: ReactPropTypes.oneOf(ASSET_TYPE_OPTIONS),

			mimeTypes: ReactPropTypes.arrayOf(ReactPropTypes.string) });

		var getPhotosReturnChecker = createStrictShapeTypeChecker({
			edges: ReactPropTypes.arrayOf(createStrictShapeTypeChecker({
				node: createStrictShapeTypeChecker({
					type: ReactPropTypes.string.isRequired,
					group_name: ReactPropTypes.string.isRequired,
					image: createStrictShapeTypeChecker({
						uri: ReactPropTypes.string.isRequired,
						height: ReactPropTypes.number.isRequired,
						width: ReactPropTypes.number.isRequired,
						isStored: ReactPropTypes.bool }).isRequired,
					timestamp: ReactPropTypes.number.isRequired,
					location: createStrictShapeTypeChecker({
						latitude: ReactPropTypes.number,
						longitude: ReactPropTypes.number,
						altitude: ReactPropTypes.number,
						heading: ReactPropTypes.number,
						speed: ReactPropTypes.number }) }).isRequired })).isRequired,
			page_info: createStrictShapeTypeChecker({
				has_next_page: ReactPropTypes.bool.isRequired,
				start_cursor: ReactPropTypes.string,
				end_cursor: ReactPropTypes.string }).isRequired });var CameraRoll = function () {
			function CameraRoll() {
				babelHelpers.classCallCheck(this, CameraRoll);
			}babelHelpers.createClass(CameraRoll, null, [{ key: 'saveImageWithTag', value: function saveImageWithTag(tag) {
					console.warn('CameraRoll.saveImageWithTag is deprecated. Use CameraRoll.saveToCameraRoll instead');
					return this.saveToCameraRoll(tag, 'photo');
				} }, { key: 'saveToCameraRoll', value: function saveToCameraRoll(tag, type) {
					invariant(typeof tag === 'string', 'CameraRoll.saveToCameraRoll must be a valid string.');

					invariant(type === 'photo' || type === 'video' || type === undefined, 'The second argument to saveToCameraRoll must be \'photo\' or \'video\'. You passed ' + type);

					var mediaType = 'photo';
					if (type) {
						mediaType = type;
					} else if (['mov', 'mp4'].indexOf(tag.split('.').slice(-1)[0]) >= 0) {
						mediaType = 'video';
					}

					return RCTCameraRollManager.saveToCameraRoll(tag, mediaType);
				} }, { key: 'getPhotos', value: function getPhotos(params) {
					var _arguments = arguments;
					if (__DEV__) {
						getPhotosParamChecker({ params: params }, 'params', 'CameraRoll.getPhotos');
					}
					if (arguments.length > 1) {
						console.warn('CameraRoll.getPhotos(tag, success, error) is deprecated.  Use the returned Promise instead');
						var successCallback = arguments[1];
						if (__DEV__) {
							(function () {
								var callback = _arguments[1];
								successCallback = function successCallback(response) {
									getPhotosReturnChecker({ response: response }, 'response', 'CameraRoll.getPhotos callback');

									callback(response);
								};
							})();
						}
						var errorCallback = arguments[2] || function () {};
						RCTCameraRollManager.getPhotos(params).then(successCallback, errorCallback);
					}

					return RCTCameraRollManager.getPhotos(params);
				} }]);return CameraRoll;
		}();

		CameraRoll.GroupTypesOptions = GROUP_TYPES_OPTIONS;
		CameraRoll.AssetTypeOptions = ASSET_TYPE_OPTIONS;

		module.exports = CameraRoll;
	}, // Libraries/Components/Clipboard/Clipboard.js
	function (__inner_require__, exports, module) {
		var Clipboard = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').Clipboard;
		var deprecatedCallback = __inner_require__(227 /*Libraries/Utilities/deprecatedCallback.js*/);

		module.exports = {

			getString: function getString() {
				return deprecatedCallback(Clipboard.getString(), Array.prototype.slice.call(arguments), 'success-first', 'Clipboard.getString(callback) is deprecated. Use the returned Promise instead');
			},

			setString: function setString(content) {
				Clipboard.setString(content);
			} };
	}, // Libraries/Utilities/deprecatedCallback.js
	function (__inner_require__, exports, module) {
		module.exports = function (promise, callbacks, type, warning) {
			if (callbacks.length === 0) {
				return promise;
			}

			var success = void 0,
			    error = void 0,
			    callback = void 0;

			console.warn(warning);

			switch (type) {
				case 'success-first':
					var _callbacks = babelHelpers.slicedToArray(callbacks, 2);success = _callbacks[0];error = _callbacks[1];
					return promise.then(function (res) {
						return success(res);
					}, function (err) {
						return error && error(err);
					});

				case 'error-first':
					var _callbacks2 = babelHelpers.slicedToArray(callbacks, 2);error = _callbacks2[0];success = _callbacks2[1];
					return promise.then(function (res) {
						return success(res);
					}, function (err) {
						return error(err);
					});

				case 'single-callback-value-first':
					var _callbacks3 = babelHelpers.slicedToArray(callbacks, 1);callback = _callbacks3[0];
					return promise.then(function (res) {
						return callback(res);
					}, function (err) {
						return callback(null, err);
					});

				case 'node':
					var _callbacks4 = babelHelpers.slicedToArray(callbacks, 1);callback = _callbacks4[0];
					return promise.then(function (res) {
						return callback(null, res);
					}, function (err) {
						return callback(err);
					});

				default:
					throw new Error('Type of callbacks not specified. Must be one of \'success-first\', \'error-first\', \'single-callback-value-first\', or \'node\'');}
		};
	}, // Libraries/Components/DatePickerAndroid/DatePickerAndroid.ios.js
	function (__inner_require__, exports, module) {
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var DatePickerAndroid = {
			open: function open(options) {
				return regeneratorRuntime.async(function open$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {case 0:
								return _context.abrupt('return', Promise.reject({
									message: 'DatePickerAndroid is not supported on this platform.' }));case 1:case 'end':
								return _context.stop();}
					}
				}, null, this);
			} };

		module.exports = DatePickerAndroid;
	}, // Libraries/CameraRoll/ImagePickerIOS.js
	function (__inner_require__, exports, module) {
		var RCTImagePicker = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').ImagePickerIOS;

		var ImagePickerIOS = {
			canRecordVideos: function canRecordVideos(callback) {
				return RCTImagePicker.canRecordVideos(callback);
			},
			canUseCamera: function canUseCamera(callback) {
				return RCTImagePicker.canUseCamera(callback);
			},
			openCameraDialog: function openCameraDialog(config, successCallback, cancelCallback) {
				config = babelHelpers.extends({
					videoMode: false }, config);

				return RCTImagePicker.openCameraDialog(config, successCallback, cancelCallback);
			},
			openSelectDialog: function openSelectDialog(config, successCallback, cancelCallback) {
				config = babelHelpers.extends({
					showImages: true,
					showVideos: false }, config);

				return RCTImagePicker.openSelectDialog(config, successCallback, cancelCallback);
			} };

		module.exports = ImagePickerIOS;
	}, // Libraries/Components/Intent/IntentAndroid.ios.js
	function (__inner_require__, exports, module) {
		module.exports = {
			openURL: function openURL(url) {
				console.error('IntentAndroid is not supported on iOS');
			} };
	}, // Libraries/Linking/Linking.js
	function (__inner_require__, exports, module) {
		var NativeEventEmitter = require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');
		var NativeModules = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js');
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var LinkingManager = Platform.OS === 'android' ? NativeModules.IntentAndroid : NativeModules.LinkingManager;var Linking = function (_NativeEventEmitter) {
			babelHelpers.inherits(Linking, _NativeEventEmitter);

			function Linking() {
				babelHelpers.classCallCheck(this, Linking);return babelHelpers.possibleConstructorReturn(this, (Linking.__proto__ || Object.getPrototypeOf(Linking)).call(this, LinkingManager));
			}babelHelpers.createClass(Linking, [{ key: 'addEventListener', value: function addEventListener(type, handler) {
					this.addListener(type, handler);
				} }, { key: 'removeEventListener', value: function removeEventListener(type, handler) {
					this.removeListener(type, handler);
				} }, { key: 'openURL', value: function openURL(url) {
					this._validateURL(url);
					return LinkingManager.openURL(url);
				} }, { key: 'canOpenURL', value: function canOpenURL(url) {
					this._validateURL(url);
					return LinkingManager.canOpenURL(url);
				} }, { key: 'getInitialURL', value: function getInitialURL() {
					return LinkingManager.getInitialURL();
				} }, { key: '_validateURL', value: function _validateURL(url) {
					invariant(typeof url === 'string', 'Invalid URL: should be a string. Was: ' + url);

					invariant(url, 'Invalid URL: cannot be empty');
				} }]);return Linking;
		}(NativeEventEmitter);

		module.exports = new Linking();
	}, // Libraries/LinkingIOS/LinkingIOS.js
	function (__inner_require__, exports, module) {
		var Linking = __inner_require__(231 /*Libraries/Linking/Linking.js*/);

		console.warn('LinkingIOS is deprecated. Use Linking instead');

		module.exports = Linking;
	}, // Libraries/NavigationExperimental/NavigationExperimental.js
	function (__inner_require__, exports, module) {
		var NavigationCard = __inner_require__(234 /*Libraries/CustomComponents/NavigationExperimental/NavigationCard.js*/);
		var NavigationCardStack = __inner_require__(243 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStack.js*/);
		var NavigationHeader = __inner_require__(246 /*Libraries/CustomComponents/NavigationExperimental/NavigationHeader.js*/);
		var NavigationPropTypes = __inner_require__(242 /*Libraries/NavigationExperimental/NavigationPropTypes.js*/);
		var NavigationStateUtils = __inner_require__(252 /*Libraries/NavigationExperimental/NavigationStateUtils.js*/);
		var NavigationTransitioner = __inner_require__(244 /*Libraries/NavigationExperimental/NavigationTransitioner.js*/);

		var NavigationExperimental = {

			StateUtils: NavigationStateUtils,

			Transitioner: NavigationTransitioner,

			Card: NavigationCard,
			CardStack: NavigationCardStack,
			Header: NavigationHeader,

			PropTypes: NavigationPropTypes };

		module.exports = NavigationExperimental;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationCard.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var NavigationCardStackPanResponder = __inner_require__(235 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStackPanResponder.js*/);
		var NavigationCardStackStyleInterpolator = __inner_require__(237 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStackStyleInterpolator.js*/);
		var NavigationPagerPanResponder = __inner_require__(238 /*Libraries/CustomComponents/NavigationExperimental/NavigationPagerPanResponder.js*/);
		var NavigationPagerStyleInterpolator = __inner_require__(239 /*Libraries/CustomComponents/NavigationExperimental/NavigationPagerStyleInterpolator.js*/);
		var NavigationPointerEventsContainer = __inner_require__(240 /*Libraries/CustomComponents/NavigationExperimental/NavigationPointerEventsContainer.js*/);
		var NavigationPropTypes = __inner_require__(242 /*Libraries/NavigationExperimental/NavigationPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var PropTypes = React.PropTypes;var NavigationCard = function (_React$Component) {
			babelHelpers.inherits(NavigationCard, _React$Component);function NavigationCard() {
				babelHelpers.classCallCheck(this, NavigationCard);return babelHelpers.possibleConstructorReturn(this, (NavigationCard.__proto__ || Object.getPrototypeOf(NavigationCard)).apply(this, arguments));
			}babelHelpers.createClass(NavigationCard, [{ key: 'render', value: function render() {
					var _props = this.props,
					    panHandlers = _props.panHandlers,
					    pointerEvents = _props.pointerEvents,
					    renderScene = _props.renderScene,
					    style = _props.style,
					    props = babelHelpers.objectWithoutProperties(_props, ['panHandlers', 'pointerEvents', 'renderScene', 'style']);

					var viewStyle = style === undefined ? NavigationCardStackStyleInterpolator.forHorizontal(props) : style;

					var viewPanHandlers = panHandlers === undefined ? NavigationCardStackPanResponder.forHorizontal(babelHelpers.extends({}, props, {
						onNavigateBack: this.props.onNavigateBack })) : panHandlers;

					return React.createElement(Animated.View, babelHelpers.extends({}, viewPanHandlers, {
						pointerEvents: pointerEvents,
						ref: this.props.onComponentRef,
						style: [styles.main, viewStyle] }), renderScene(props));
				} }]);return NavigationCard;
		}(React.Component);NavigationCard.propTypes = babelHelpers.extends({}, NavigationPropTypes.SceneRendererProps, { onComponentRef: PropTypes.func.isRequired, onNavigateBack: PropTypes.func, panHandlers: NavigationPropTypes.panHandlers, pointerEvents: PropTypes.string.isRequired, renderScene: PropTypes.func.isRequired, style: PropTypes.any });

		var styles = StyleSheet.create({
			main: {
				backgroundColor: '#E9E9EF',
				bottom: 0,
				left: 0,
				position: 'absolute',
				right: 0,
				shadowColor: 'black',
				shadowOffset: { width: 0, height: 0 },
				shadowOpacity: 0.4,
				shadowRadius: 10,
				top: 0 } });

		NavigationCard = NavigationPointerEventsContainer.create(NavigationCard);

		NavigationCard.CardStackPanResponder = NavigationCardStackPanResponder;
		NavigationCard.CardStackStyleInterpolator = NavigationCardStackStyleInterpolator;
		NavigationCard.PagerPanResponder = NavigationPagerPanResponder;
		NavigationCard.PagerStyleInterpolator = NavigationPagerStyleInterpolator;

		module.exports = NavigationCard;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationCardStackPanResponder.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);
		var NavigationAbstractPanResponder = __inner_require__(236 /*Libraries/NavigationExperimental/NavigationAbstractPanResponder.js*/);

		var clamp = __inner_require__(140 /*Libraries/Utilities/clamp.js*/);

		var ANIMATION_DURATION = 250;

		var POSITION_THRESHOLD = 1 / 3;

		var RESPOND_THRESHOLD = 15;

		var DISTANCE_THRESHOLD = 100;

		var Directions = {
			'HORIZONTAL': 'horizontal',
			'VERTICAL': 'vertical' };var NavigationCardStackPanResponder = function (_NavigationAbstractPa) {
			babelHelpers.inherits(NavigationCardStackPanResponder, _NavigationAbstractPa);

			function NavigationCardStackPanResponder(direction, props) {
				babelHelpers.classCallCheck(this, NavigationCardStackPanResponder);var _this = babelHelpers.possibleConstructorReturn(this, (NavigationCardStackPanResponder.__proto__ || Object.getPrototypeOf(NavigationCardStackPanResponder)).call(this));

				_this._isResponding = false;
				_this._isVertical = direction === Directions.VERTICAL;
				_this._props = props;
				_this._startValue = 0;return _this;
			}babelHelpers.createClass(NavigationCardStackPanResponder, [{ key: 'onMoveShouldSetPanResponder', value: function onMoveShouldSetPanResponder(event, gesture) {
					var props = this._props;

					if (props.navigationState.index !== props.scene.index) {
						return false;
					}

					var layout = props.layout;
					var isVertical = this._isVertical;
					var index = props.navigationState.index;
					var currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];
					var currentDragPosition = gesture[isVertical ? 'moveY' : 'moveX'];
					var maxDragDistance = isVertical ? layout.height.__getValue() : layout.width.__getValue();

					var positionMax = isVertical ? props.gestureResponseDistance : props.gestureResponseDistance || 30;

					if (positionMax != null && currentDragPosition > positionMax) {
						return false;
					}

					return Math.abs(currentDragDistance) > RESPOND_THRESHOLD && maxDragDistance > 0 && index > 0;
				} }, { key: 'onPanResponderGrant', value: function onPanResponderGrant() {
					var _this2 = this;
					this._isResponding = false;
					this._props.position.stopAnimation(function (value) {
						_this2._isResponding = true;
						_this2._startValue = value;
					});
				} }, { key: 'onPanResponderMove', value: function onPanResponderMove(event, gesture) {
					if (!this._isResponding) {
						return;
					}

					var props = this._props;
					var layout = props.layout;
					var isVertical = this._isVertical;
					var axis = isVertical ? 'dy' : 'dx';
					var index = props.navigationState.index;
					var distance = isVertical ? layout.height.__getValue() : layout.width.__getValue();
					var currentValue = I18nManager.isRTL && axis === 'dx' ? this._startValue + gesture[axis] / distance : this._startValue - gesture[axis] / distance;

					var value = clamp(index - 1, currentValue, index);

					props.position.setValue(value);
				} }, { key: 'onPanResponderRelease', value: function onPanResponderRelease(event, gesture) {
					var _this3 = this;
					if (!this._isResponding) {
						return;
					}

					this._isResponding = false;

					var props = this._props;
					var isVertical = this._isVertical;
					var axis = isVertical ? 'dy' : 'dx';
					var index = props.navigationState.index;
					var distance = I18nManager.isRTL && axis === 'dx' ? -gesture[axis] : gesture[axis];

					props.position.stopAnimation(function (value) {
						_this3._reset();

						if (!props.onNavigateBack) {
							return;
						}

						if (distance > DISTANCE_THRESHOLD || value <= index - POSITION_THRESHOLD) {
							props.onNavigateBack();
						}
					});
				} }, { key: 'onPanResponderTerminate', value: function onPanResponderTerminate() {
					this._isResponding = false;
					this._reset();
				} }, { key: '_reset', value: function _reset() {
					var props = this._props;
					Animated.timing(props.position, {
						toValue: props.navigationState.index,
						duration: ANIMATION_DURATION }).start();
				} }]);return NavigationCardStackPanResponder;
		}(NavigationAbstractPanResponder);

		function createPanHandlers(direction, props) {
			var responder = new NavigationCardStackPanResponder(direction, props);
			return responder.panHandlers;
		}

		function forHorizontal(props) {
			return createPanHandlers(Directions.HORIZONTAL, props);
		}

		function forVertical(props) {
			return createPanHandlers(Directions.VERTICAL, props);
		}

		module.exports = {

			ANIMATION_DURATION: ANIMATION_DURATION,
			DISTANCE_THRESHOLD: DISTANCE_THRESHOLD,
			POSITION_THRESHOLD: POSITION_THRESHOLD,
			RESPOND_THRESHOLD: RESPOND_THRESHOLD,

			Directions: Directions,

			forHorizontal: forHorizontal,
			forVertical: forVertical };
	}, // Libraries/NavigationExperimental/NavigationAbstractPanResponder.js
	function (__inner_require__, exports, module) {
		var PanResponder = __inner_require__(138 /*Libraries/Interaction/PanResponder.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var EmptyPanHandlers = {
			onMoveShouldSetPanResponder: null,
			onPanResponderGrant: null,
			onPanResponderMove: null,
			onPanResponderRelease: null,
			onPanResponderTerminate: null };var NavigationAbstractPanResponder = function NavigationAbstractPanResponder() {
			var _this = this;babelHelpers.classCallCheck(this, NavigationAbstractPanResponder);
			var config = {};
			Object.keys(EmptyPanHandlers).forEach(function (name) {
				var fn = _this[name];

				invariant(typeof fn === 'function', 'subclass of `NavigationAbstractPanResponder` must implement method %s', name);

				config[name] = fn.bind(_this);
			}, this);

			this.panHandlers = PanResponder.create(config).panHandlers;
		};

		module.exports = NavigationAbstractPanResponder;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationCardStackStyleInterpolator.js
	function (__inner_require__, exports, module) {
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);

		function forInitial(props) {
			var navigationState = props.navigationState,
			    scene = props.scene;

			var focused = navigationState.index === scene.index;
			var opacity = focused ? 1 : 0;

			var translate = focused ? 0 : 1000000;
			return {
				opacity: opacity,
				transform: [{ translateX: translate }, { translateY: translate }] };
		}

		function forHorizontal(props) {
			var layout = props.layout,
			    position = props.position,
			    scene = props.scene;

			if (!layout.isMeasured) {
				return forInitial(props);
			}

			var index = scene.index;
			var inputRange = [index - 1, index, index + 1];
			var width = layout.initWidth;
			var outputRange = I18nManager.isRTL ? [-width, 0, 10] : [width, 0, -10];

			var opacity = position.interpolate({
				inputRange: inputRange,
				outputRange: [1, 1, 0.3] });

			var scale = position.interpolate({
				inputRange: inputRange,
				outputRange: [1, 1, 0.95] });

			var translateY = 0;
			var translateX = position.interpolate({
				inputRange: inputRange,
				outputRange: outputRange });

			return {
				opacity: opacity,
				transform: [{ scale: scale }, { translateX: translateX }, { translateY: translateY }] };
		}

		function forVertical(props) {
			var layout = props.layout,
			    position = props.position,
			    scene = props.scene;

			if (!layout.isMeasured) {
				return forInitial(props);
			}

			var index = scene.index;
			var inputRange = [index - 1, index, index + 1];
			var height = layout.initHeight;

			var opacity = position.interpolate({
				inputRange: inputRange,
				outputRange: [1, 1, 0.3] });

			var scale = position.interpolate({
				inputRange: inputRange,
				outputRange: [1, 1, 0.95] });

			var translateX = 0;
			var translateY = position.interpolate({
				inputRange: inputRange,
				outputRange: [height, 0, -10] });

			return {
				opacity: opacity,
				transform: [{ scale: scale }, { translateX: translateX }, { translateY: translateY }] };
		}

		module.exports = {
			forHorizontal: forHorizontal,
			forVertical: forVertical };
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationPagerPanResponder.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var NavigationAbstractPanResponder = __inner_require__(236 /*Libraries/NavigationExperimental/NavigationAbstractPanResponder.js*/);
		var NavigationCardStackPanResponder = __inner_require__(235 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStackPanResponder.js*/);
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);

		var clamp = __inner_require__(140 /*Libraries/Utilities/clamp.js*/);var ANIMATION_DURATION = NavigationCardStackPanResponder.ANIMATION_DURATION,
		    POSITION_THRESHOLD = NavigationCardStackPanResponder.POSITION_THRESHOLD,
		    RESPOND_THRESHOLD = NavigationCardStackPanResponder.RESPOND_THRESHOLD,
		    Directions = NavigationCardStackPanResponder.Directions;

		var DISTANCE_THRESHOLD = 50;

		var VELOCITY_THRESHOLD = 1.5;var NavigationPagerPanResponder = function (_NavigationAbstractPa) {
			babelHelpers.inherits(NavigationPagerPanResponder, _NavigationAbstractPa);

			function NavigationPagerPanResponder(direction, props) {
				babelHelpers.classCallCheck(this, NavigationPagerPanResponder);var _this = babelHelpers.possibleConstructorReturn(this, (NavigationPagerPanResponder.__proto__ || Object.getPrototypeOf(NavigationPagerPanResponder)).call(this));

				_this._isResponding = false;
				_this._isVertical = direction === Directions.VERTICAL;
				_this._props = props;
				_this._startValue = 0;return _this;
			}babelHelpers.createClass(NavigationPagerPanResponder, [{ key: 'onMoveShouldSetPanResponder', value: function onMoveShouldSetPanResponder(event, gesture) {
					var props = this._props;

					if (props.navigationState.index !== props.scene.index) {
						return false;
					}

					var layout = props.layout;
					var isVertical = this._isVertical;
					var axis = isVertical ? 'dy' : 'dx';
					var index = props.navigationState.index;
					var distance = isVertical ? layout.height.__getValue() : layout.width.__getValue();

					return Math.abs(gesture[axis]) > RESPOND_THRESHOLD && distance > 0 && index >= 0;
				} }, { key: 'onPanResponderGrant', value: function onPanResponderGrant() {
					var _this2 = this;
					this._isResponding = false;
					this._props.position.stopAnimation(function (value) {
						_this2._isResponding = true;
						_this2._startValue = value;
					});
				} }, { key: 'onPanResponderMove', value: function onPanResponderMove(event, gesture) {
					if (!this._isResponding) {
						return;
					}var _props = this._props,
					    layout = _props.layout,
					    navigationState = _props.navigationState,
					    position = _props.position,
					    scenes = _props.scenes;

					var isVertical = this._isVertical;
					var axis = isVertical ? 'dy' : 'dx';
					var index = navigationState.index;
					var distance = isVertical ? layout.height.__getValue() : layout.width.__getValue();
					var currentValue = I18nManager.isRTL && axis === 'dx' ? this._startValue + gesture[axis] / distance : this._startValue - gesture[axis] / distance;

					var prevIndex = Math.max(0, index - 1);

					var nextIndex = Math.min(index + 1, scenes.length - 1);

					var value = clamp(prevIndex, currentValue, nextIndex);

					position.setValue(value);
				} }, { key: 'onPanResponderRelease', value: function onPanResponderRelease(event, gesture) {
					var _this3 = this;
					if (!this._isResponding) {
						return;
					}

					this._isResponding = false;var _props2 = this._props,
					    navigationState = _props2.navigationState,
					    onNavigateBack = _props2.onNavigateBack,
					    onNavigateForward = _props2.onNavigateForward,
					    position = _props2.position;

					var isVertical = this._isVertical;
					var axis = isVertical ? 'dy' : 'dx';
					var velocityAxis = isVertical ? 'vy' : 'vx';
					var index = navigationState.index;
					var distance = I18nManager.isRTL && axis === 'dx' ? -gesture[axis] : gesture[axis];
					var moveSpeed = I18nManager.isRTL && velocityAxis === 'vx' ? -gesture[velocityAxis] : gesture[velocityAxis];

					position.stopAnimation(function (value) {
						_this3._reset();
						if (distance > DISTANCE_THRESHOLD || value <= index - POSITION_THRESHOLD || moveSpeed > VELOCITY_THRESHOLD) {
							onNavigateBack && onNavigateBack();
							return;
						}

						if (distance < -DISTANCE_THRESHOLD || value >= index + POSITION_THRESHOLD || moveSpeed < -VELOCITY_THRESHOLD) {
							onNavigateForward && onNavigateForward();
						}
					});
				} }, { key: 'onPanResponderTerminate', value: function onPanResponderTerminate() {
					this._isResponding = false;
					this._reset();
				} }, { key: '_reset', value: function _reset() {
					var props = this._props;
					Animated.timing(props.position, {
						toValue: props.navigationState.index,
						duration: ANIMATION_DURATION }).start();
				} }]);return NavigationPagerPanResponder;
		}(NavigationAbstractPanResponder);

		function createPanHandlers(direction, props) {
			var responder = new NavigationPagerPanResponder(direction, props);
			return responder.panHandlers;
		}

		function forHorizontal(props) {
			return createPanHandlers(Directions.HORIZONTAL, props);
		}

		module.exports = {
			forHorizontal: forHorizontal };
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationPagerStyleInterpolator.js
	function (__inner_require__, exports, module) {
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);

		function forInitial(props) {
			var navigationState = props.navigationState,
			    scene = props.scene;

			var focused = navigationState.index === scene.index;
			var opacity = focused ? 1 : 0;

			var dir = scene.index > navigationState.index ? 1 : -1;
			var translate = focused ? 0 : 1000000 * dir;
			return {
				opacity: opacity,
				transform: [{ translateX: translate }, { translateY: translate }] };
		}

		function forHorizontal(props) {
			var layout = props.layout,
			    position = props.position,
			    scene = props.scene;

			if (!layout.isMeasured) {
				return forInitial(props);
			}

			var index = scene.index;
			var inputRange = [index - 1, index, index + 1];
			var width = layout.initWidth;
			var outputRange = I18nManager.isRTL ? [-width, 0, width] : [width, 0, -width];

			var translateX = position.interpolate({
				inputRange: inputRange,
				outputRange: outputRange });

			return {
				opacity: 1,
				shadowColor: 'transparent',
				shadowRadius: 0,
				transform: [{ scale: 1 }, { translateX: translateX }, { translateY: 0 }] };
		}

		module.exports = {
			forHorizontal: forHorizontal };
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationPointerEventsContainer.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var NavigationAnimatedValueSubscription = __inner_require__(241 /*Libraries/CustomComponents/NavigationExperimental/NavigationAnimatedValueSubscription.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var MIN_POSITION_OFFSET = 0.01;

		function create(Component) {
			var Container = function (_React$Component) {
				babelHelpers.inherits(Container, _React$Component);

				function Container(props, context) {
					babelHelpers.classCallCheck(this, Container);var _this = babelHelpers.possibleConstructorReturn(this, (Container.__proto__ || Object.getPrototypeOf(Container)).call(this, props, context));
					_this._pointerEvents = _this._computePointerEvents();return _this;
				}babelHelpers.createClass(Container, [{ key: 'componentWillMount', value: function componentWillMount() {
						this._onPositionChange = this._onPositionChange.bind(this);
						this._onComponentRef = this._onComponentRef.bind(this);
					} }, { key: 'componentDidMount', value: function componentDidMount() {
						this._bindPosition(this.props);
					} }, { key: 'componentWillUnmount', value: function componentWillUnmount() {
						this._positionListener && this._positionListener.remove();
					} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(nextProps) {
						this._bindPosition(nextProps);
					} }, { key: 'render', value: function render() {
						this._pointerEvents = this._computePointerEvents();
						return React.createElement(Component, babelHelpers.extends({}, this.props, {
							pointerEvents: this._pointerEvents,
							onComponentRef: this._onComponentRef }));
					} }, { key: '_onComponentRef', value: function _onComponentRef(component) {
						this._component = component;
						if (component) {
							invariant(typeof component.setNativeProps === 'function', 'component must implement method `setNativeProps`');
						}
					} }, { key: '_bindPosition', value: function _bindPosition(props) {
						this._positionListener && this._positionListener.remove();
						this._positionListener = new NavigationAnimatedValueSubscription(props.position, this._onPositionChange);
					} }, { key: '_onPositionChange', value: function _onPositionChange() {
						if (this._component) {
							var pointerEvents = this._computePointerEvents();
							if (this._pointerEvents !== pointerEvents) {
								this._pointerEvents = pointerEvents;
								this._component.setNativeProps({ pointerEvents: pointerEvents });
							}
						}
					} }, { key: '_computePointerEvents', value: function _computePointerEvents() {
						var _props = this.props,
						    navigationState = _props.navigationState,
						    position = _props.position,
						    scene = _props.scene;

						if (scene.isStale || navigationState.index !== scene.index) {

							return scene.index > navigationState.index ? 'box-only' : 'none';
						}

						var offset = position.__getAnimatedValue() - navigationState.index;
						if (Math.abs(offset) > MIN_POSITION_OFFSET) {

							return 'box-only';
						}

						return 'auto';
					} }]);return Container;
			}(React.Component);

			return Container;
		}

		module.exports = {
			create: create };
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationAnimatedValueSubscription.js
	function (__inner_require__, exports, module) {
		var NavigationAnimatedValueSubscription = function () {

			function NavigationAnimatedValueSubscription(value, callback) {
				babelHelpers.classCallCheck(this, NavigationAnimatedValueSubscription);
				this._value = value;
				this._token = value.addListener(callback);
			}babelHelpers.createClass(NavigationAnimatedValueSubscription, [{ key: 'remove', value: function remove() {
					this._value.removeListener(this._token);
				} }]);return NavigationAnimatedValueSubscription;
		}();

		module.exports = NavigationAnimatedValueSubscription;
	}, // Libraries/NavigationExperimental/NavigationPropTypes.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);var PropTypes = React.PropTypes;

		var action = PropTypes.shape({
			type: PropTypes.string.isRequired });

		var animatedValue = PropTypes.instanceOf(Animated.Value);

		var navigationRoute = PropTypes.shape({
			key: PropTypes.string.isRequired });

		var navigationState = PropTypes.shape({
			index: PropTypes.number.isRequired,
			routes: PropTypes.arrayOf(navigationRoute) });

		var layout = PropTypes.shape({
			height: animatedValue,
			initHeight: PropTypes.number.isRequired,
			initWidth: PropTypes.number.isRequired,
			isMeasured: PropTypes.bool.isRequired,
			width: animatedValue });

		var scene = PropTypes.shape({
			index: PropTypes.number.isRequired,
			isActive: PropTypes.bool.isRequired,
			isStale: PropTypes.bool.isRequired,
			key: PropTypes.string.isRequired,
			route: navigationRoute.isRequired });

		var SceneRendererProps = {
			layout: layout.isRequired,
			navigationState: navigationState.isRequired,
			position: animatedValue.isRequired,
			progress: animatedValue.isRequired,
			scene: scene.isRequired,
			scenes: PropTypes.arrayOf(scene).isRequired };

		var SceneRenderer = PropTypes.shape(SceneRendererProps);

		var panHandlers = PropTypes.shape({
			onMoveShouldSetResponder: PropTypes.func.isRequired,
			onMoveShouldSetResponderCapture: PropTypes.func.isRequired,
			onResponderEnd: PropTypes.func.isRequired,
			onResponderGrant: PropTypes.func.isRequired,
			onResponderMove: PropTypes.func.isRequired,
			onResponderReject: PropTypes.func.isRequired,
			onResponderRelease: PropTypes.func.isRequired,
			onResponderStart: PropTypes.func.isRequired,
			onResponderTerminate: PropTypes.func.isRequired,
			onResponderTerminationRequest: PropTypes.func.isRequired,
			onStartShouldSetResponder: PropTypes.func.isRequired,
			onStartShouldSetResponderCapture: PropTypes.func.isRequired });

		function extractSceneRendererProps(props) {
			return {
				layout: props.layout,
				navigationState: props.navigationState,
				position: props.position,
				progress: props.progress,
				scene: props.scene,
				scenes: props.scenes };
		}

		module.exports = {

			extractSceneRendererProps: extractSceneRendererProps,

			SceneRendererProps: SceneRendererProps,

			SceneRenderer: SceneRenderer,
			action: action,
			navigationState: navigationState,
			navigationRoute: navigationRoute,
			panHandlers: panHandlers };
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationCardStack.js
	function (__inner_require__, exports, module) {
		var NavigationTransitioner = __inner_require__(244 /*Libraries/NavigationExperimental/NavigationTransitioner.js*/);
		var NavigationCard = __inner_require__(234 /*Libraries/CustomComponents/NavigationExperimental/NavigationCard.js*/);
		var NavigationCardStackStyleInterpolator = __inner_require__(237 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStackStyleInterpolator.js*/);
		var NavigationCardStackPanResponder = __inner_require__(235 /*Libraries/CustomComponents/NavigationExperimental/NavigationCardStackPanResponder.js*/);
		var NavigationPropTypes = __inner_require__(242 /*Libraries/NavigationExperimental/NavigationPropTypes.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var PropTypes = React.PropTypes;var Directions = NavigationCardStackPanResponder.Directions;var NavigationCardStack = function (_React$Component) {
			babelHelpers.inherits(NavigationCardStack, _React$Component);

			function NavigationCardStack(props, context) {
				babelHelpers.classCallCheck(this, NavigationCardStack);return babelHelpers.possibleConstructorReturn(this, (NavigationCardStack.__proto__ || Object.getPrototypeOf(NavigationCardStack)).call(this, props, context));
			}babelHelpers.createClass(NavigationCardStack, [{ key: 'componentWillMount', value: function componentWillMount() {
					this._render = this._render.bind(this);
					this._renderScene = this._renderScene.bind(this);
				} }, { key: 'render', value: function render() {
					return React.createElement(NavigationTransitioner, {
						navigationState: this.props.navigationState,
						render: this._render,
						style: this.props.style });
				} }, { key: '_render', value: function _render(props) {
					var _this2 = this;var renderHeader = this.props.renderHeader;

					var header = renderHeader ? React.createElement(View, null, renderHeader(props)) : null;

					var scenes = props.scenes.map(function (scene) {
						return _this2._renderScene(babelHelpers.extends({}, props, {
							scene: scene }));
					});

					return React.createElement(View, { style: styles.container }, React.createElement(View, {
						style: styles.scenes }, scenes), header);
				} }, { key: '_renderScene', value: function _renderScene(props) {
					var isVertical = this.props.direction === 'vertical';

					var style = isVertical ? NavigationCardStackStyleInterpolator.forVertical(props) : NavigationCardStackStyleInterpolator.forHorizontal(props);

					var panHandlersProps = babelHelpers.extends({}, props, {
						onNavigateBack: this.props.onNavigateBack,
						gestureResponseDistance: this.props.gestureResponseDistance });

					var panHandlers = isVertical ? NavigationCardStackPanResponder.forVertical(panHandlersProps) : NavigationCardStackPanResponder.forHorizontal(panHandlersProps);

					return React.createElement(NavigationCard, babelHelpers.extends({}, props, {
						key: 'card_' + props.scene.key,
						panHandlers: panHandlers,
						renderScene: this.props.renderScene,
						style: [style, this.props.cardStyle] }));
				} }]);return NavigationCardStack;
		}(React.Component);NavigationCardStack.propTypes = { cardStyle: View.propTypes.style, direction: PropTypes.oneOf([Directions.HORIZONTAL, Directions.VERTICAL]), gestureResponseDistance: PropTypes.number, navigationState: NavigationPropTypes.navigationState.isRequired, onNavigateBack: PropTypes.func, renderHeader: PropTypes.func, renderScene: PropTypes.func.isRequired, style: View.propTypes.style };NavigationCardStack.defaultProps = { direction: Directions.HORIZONTAL };

		var styles = StyleSheet.create({
			container: {
				flex: 1,

				flexDirection: 'column-reverse' },

			scenes: {
				flex: 1 } });

		module.exports = NavigationCardStack;
	}, // Libraries/NavigationExperimental/NavigationTransitioner.js
	function (__inner_require__, exports, module) {
		var Animated = __inner_require__(159 /*Libraries/Animated/src/Animated.js*/);
		var Easing = __inner_require__(166 /*Libraries/Animated/src/Easing.js*/);
		var NavigationPropTypes = __inner_require__(242 /*Libraries/NavigationExperimental/NavigationPropTypes.js*/);
		var NavigationScenesReducer = __inner_require__(245 /*Libraries/NavigationExperimental/Reducer/NavigationScenesReducer.js*/);
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var StyleSheet = __inner_require__(26 /*Libraries/StyleSheet/StyleSheet.js*/);
		var View = __inner_require__(38 /*Libraries/Components/View/View.js*/);var PropTypes = React.PropTypes;

		var DefaultTransitionSpec = {
			duration: 250,
			easing: Easing.inOut(Easing.ease),
			timing: Animated.timing };var NavigationTransitioner = function (_React$Component) {
			babelHelpers.inherits(NavigationTransitioner, _React$Component);

			function NavigationTransitioner(props, context) {
				babelHelpers.classCallCheck(this, NavigationTransitioner);var _this = babelHelpers.possibleConstructorReturn(this, (NavigationTransitioner.__proto__ || Object.getPrototypeOf(NavigationTransitioner)).call(this, props, context));

				var layout = {
					height: new Animated.Value(0),
					initHeight: 0,
					initWidth: 0,
					isMeasured: false,
					width: new Animated.Value(0) };

				_this.state = {
					layout: layout,
					position: new Animated.Value(_this.props.navigationState.index),
					progress: new Animated.Value(1),
					scenes: NavigationScenesReducer([], _this.props.navigationState) };

				_this._prevTransitionProps = null;
				_this._transitionProps = buildTransitionProps(props, _this.state);return _this;
			}babelHelpers.createClass(NavigationTransitioner, [{ key: 'componentWillMount', value: function componentWillMount() {
					this._onLayout = this._onLayout.bind(this);
					this._onTransitionEnd = this._onTransitionEnd.bind(this);
				} }, { key: 'componentWillReceiveProps', value: function componentWillReceiveProps(nextProps) {
					var _this2 = this;
					var nextScenes = NavigationScenesReducer(this.state.scenes, nextProps.navigationState, this.props.navigationState);

					if (nextScenes === this.state.scenes) {
						return;
					}

					var nextState = babelHelpers.extends({}, this.state, {
						scenes: nextScenes });

					this._prevTransitionProps = this._transitionProps;
					this._transitionProps = buildTransitionProps(nextProps, nextState);var position = nextState.position,
					    progress = nextState.progress;

					var transitionUserSpec = nextProps.configureTransition ? nextProps.configureTransition(this._transitionProps, this._prevTransitionProps) : null;

					var transitionSpec = babelHelpers.extends({}, DefaultTransitionSpec, transitionUserSpec);var timing = transitionSpec.timing;
					delete transitionSpec.timing;

					progress.setValue(0);

					var animations = [timing(progress, babelHelpers.extends({}, transitionSpec, {
						toValue: 1 }))];

					if (nextProps.navigationState.index !== this.props.navigationState.index) {
						animations.push(timing(position, babelHelpers.extends({}, transitionSpec, {
							toValue: nextProps.navigationState.index })));
					}

					this.setState(nextState, function () {
						nextProps.onTransitionStart && nextProps.onTransitionStart(_this2._transitionProps, _this2._prevTransitionProps);

						Animated.parallel(animations).start(_this2._onTransitionEnd);
					});
				} }, { key: 'render', value: function render() {
					return React.createElement(View, {
						onLayout: this._onLayout,
						style: [styles.main, this.props.style] }, this.props.render(this._transitionProps, this._prevTransitionProps));
				} }, { key: '_onLayout', value: function _onLayout(event) {
					var _event$nativeEvent$la = event.nativeEvent.layout,
					    height = _event$nativeEvent$la.height,
					    width = _event$nativeEvent$la.width;

					var layout = babelHelpers.extends({}, this.state.layout, {
						initHeight: height,
						initWidth: width,
						isMeasured: true });

					layout.height.setValue(height);
					layout.width.setValue(width);

					var nextState = babelHelpers.extends({}, this.state, {
						layout: layout });

					this._transitionProps = buildTransitionProps(this.props, nextState);
					this.setState(nextState);
				} }, { key: '_onTransitionEnd', value: function _onTransitionEnd() {
					var _this3 = this;
					var prevTransitionProps = this._prevTransitionProps;
					this._prevTransitionProps = null;

					var nextState = babelHelpers.extends({}, this.state, {
						scenes: this.state.scenes.filter(isSceneNotStale) });

					this._transitionProps = buildTransitionProps(this.props, nextState);

					this.setState(nextState, function () {
						_this3.props.onTransitionEnd && _this3.props.onTransitionEnd(_this3._transitionProps, prevTransitionProps);
					});
				} }]);return NavigationTransitioner;
		}(React.Component);NavigationTransitioner.propTypes = { configureTransition: PropTypes.func, navigationState: NavigationPropTypes.navigationState.isRequired, onTransitionEnd: PropTypes.func, onTransitionStart: PropTypes.func, render: PropTypes.func.isRequired };

		function buildTransitionProps(props, state) {
			var navigationState = props.navigationState;var layout = state.layout,
			    position = state.position,
			    progress = state.progress,
			    scenes = state.scenes;

			return {
				layout: layout,
				navigationState: navigationState,
				position: position,
				progress: progress,
				scenes: scenes,
				scene: scenes.find(isSceneActive) };
		}

		function isSceneNotStale(scene) {
			return !scene.isStale;
		}

		function isSceneActive(scene) {
			return scene.isActive;
		}

		var styles = StyleSheet.create({
			main: {
				flex: 1 } });

		module.exports = NavigationTransitioner;
	}, // Libraries/NavigationExperimental/Reducer/NavigationScenesReducer.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var shallowEqual = require('react-native@0.33/__fbjs__/lib/shallowEqual.js');

		var SCENE_KEY_PREFIX = 'scene_';

		function compareKey(one, two) {
			var delta = one.length - two.length;
			if (delta > 0) {
				return 1;
			}
			if (delta < 0) {
				return -1;
			}
			return one > two ? 1 : -1;
		}

		function compareScenes(one, two) {
			if (one.index > two.index) {
				return 1;
			}
			if (one.index < two.index) {
				return -1;
			}

			return compareKey(one.key, two.key);
		}

		function areScenesShallowEqual(one, two) {
			return one.key === two.key && one.index === two.index && one.isStale === two.isStale && one.isActive === two.isActive && areRoutesShallowEqual(one.route, two.route);
		}

		function areRoutesShallowEqual(one, two) {
			if (!one || !two) {
				return one === two;
			}

			if (one.key !== two.key) {
				return false;
			}

			return shallowEqual(one, two);
		}

		function NavigationScenesReducer(scenes, nextState, prevState) {
			if (prevState === nextState) {
				return scenes;
			}

			var prevScenes = new Map();
			var freshScenes = new Map();
			var staleScenes = new Map();

			scenes.forEach(function (scene) {
				var key = scene.key;
				if (scene.isStale) {
					staleScenes.set(key, scene);
				}
				prevScenes.set(key, scene);
			});

			var nextKeys = new Set();
			nextState.routes.forEach(function (route, index) {
				var key = SCENE_KEY_PREFIX + route.key;
				var scene = {
					index: index,
					isActive: false,
					isStale: false,
					key: key,
					route: route };

				invariant(!nextKeys.has(key), 'navigationState.routes[' + index + '].key "' + key + '" conflicts with ' + 'another route!');

				nextKeys.add(key);

				if (staleScenes.has(key)) {

					staleScenes.delete(key);
				}
				freshScenes.set(key, scene);
			});

			if (prevState) {

				prevState.routes.forEach(function (route, index) {
					var key = SCENE_KEY_PREFIX + route.key;
					if (freshScenes.has(key)) {
						return;
					}
					staleScenes.set(key, {
						index: index,
						isActive: false,
						isStale: true,
						key: key,
						route: route });
				});
			}

			var nextScenes = [];

			var mergeScene = function mergeScene(nextScene) {
				var key = nextScene.key;
				var prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;
				if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {

					nextScenes.push(prevScene);
				} else {
					nextScenes.push(nextScene);
				}
			};

			staleScenes.forEach(mergeScene);
			freshScenes.forEach(mergeScene);

			nextScenes.sort(compareScenes);

			var activeScenesCount = 0;
			nextScenes.forEach(function (scene, ii) {
				var isActive = !scene.isStale && scene.index === nextState.index;
				if (isActive !== scene.isActive) {
					nextScenes[ii] = babelHelpers.extends({}, scene, {
						isActive: isActive });
				}
				if (isActive) {
					activeScenesCount++;
				}
			});

			invariant(activeScenesCount === 1, 'there should always be only one scene active, not %s.', activeScenesCount);

			if (nextScenes.length !== scenes.length) {
				return nextScenes;
			}

			if (nextScenes.some(function (scene, index) {
				return !areScenesShallowEqual(scenes[index], scene);
			})) {
				return nextScenes;
			}

			return scenes;
		}

		module.exports = NavigationScenesReducer;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationHeader.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(12 /*Libraries/react-native/React.js*/);
		var ReactNative = require('react-native@0.33/Libraries/react-native/react-native.js');
		var NavigationHeaderTitle = __inner_require__(247 /*Libraries/CustomComponents/NavigationExperimental/NavigationHeaderTitle.js*/);
		var NavigationHeaderBackButton = __inner_require__(248 /*Libraries/CustomComponents/NavigationExperimental/NavigationHeaderBackButton.js*/);
		var NavigationPropTypes = __inner_require__(242 /*Libraries/NavigationExperimental/NavigationPropTypes.js*/);
		var NavigationHeaderStyleInterpolator = __inner_require__(249 /*Libraries/CustomComponents/NavigationExperimental/NavigationHeaderStyleInterpolator.js*/);
		var ReactComponentWithPureRenderMixin = __inner_require__(250 /*__react__/lib/ReactComponentWithPureRenderMixin.js*/);var Animated = ReactNative.Animated,
		    Platform = ReactNative.Platform,
		    StyleSheet = ReactNative.StyleSheet,
		    View = ReactNative.View;

		var APPBAR_HEIGHT = Platform.OS === 'ios' ? 44 : 56;
		var STATUSBAR_HEIGHT = Platform.OS === 'ios' ? 20 : 0;var PropTypes = React.PropTypes;var NavigationHeader = function (_React$Component) {
			babelHelpers.inherits(NavigationHeader, _React$Component);function NavigationHeader() {
				babelHelpers.classCallCheck(this, NavigationHeader);return babelHelpers.possibleConstructorReturn(this, (NavigationHeader.__proto__ || Object.getPrototypeOf(NavigationHeader)).apply(this, arguments));
			}babelHelpers.createClass(NavigationHeader, [{ key: 'shouldComponentUpdate', value: function shouldComponentUpdate(nextProps, nextState) {
					return ReactComponentWithPureRenderMixin.shouldComponentUpdate.call(this, nextProps, nextState);
				} }, { key: 'render', value: function render() {
					var _this2 = this;var _props = this.props,
					    scenes = _props.scenes,
					    style = _props.style,
					    viewProps = _props.viewProps;

					var scenesProps = scenes.map(function (scene) {
						var props = NavigationPropTypes.extractSceneRendererProps(_this2.props);
						props.scene = scene;
						return props;
					});

					var barHeight = this.props.statusBarHeight instanceof Animated.Value ? Animated.add(this.props.statusBarHeight, new Animated.Value(APPBAR_HEIGHT)) : APPBAR_HEIGHT + this.props.statusBarHeight;

					return React.createElement(Animated.View, babelHelpers.extends({ style: [styles.appbar, { height: barHeight }, style] }, viewProps), scenesProps.map(this._renderLeft, this), scenesProps.map(this._renderTitle, this), scenesProps.map(this._renderRight, this));
				} }, { key: '_renderLeft', value: function _renderLeft(props) {
					return this._renderSubView(props, 'left', this.props.renderLeftComponent, NavigationHeaderStyleInterpolator.forLeft);
				} }, { key: '_renderTitle', value: function _renderTitle(props) {
					return this._renderSubView(props, 'title', this.props.renderTitleComponent, NavigationHeaderStyleInterpolator.forCenter);
				} }, { key: '_renderRight', value: function _renderRight(props) {
					return this._renderSubView(props, 'right', this.props.renderRightComponent, NavigationHeaderStyleInterpolator.forRight);
				} }, { key: '_renderSubView', value: function _renderSubView(props, name, renderer, styleInterpolator) {
					var scene = props.scene,
					    navigationState = props.navigationState;var index = scene.index,
					    isStale = scene.isStale,
					    key = scene.key;

					var offset = navigationState.index - index;

					if (Math.abs(offset) > 2) {

						return null;
					}

					var subViewProps = babelHelpers.extends({}, props, { onNavigateBack: this.props.onNavigateBack });
					var subView = renderer(subViewProps);
					if (subView === null) {
						return null;
					}

					var pointerEvents = offset !== 0 || isStale ? 'none' : 'box-none';
					return React.createElement(Animated.View, {
						pointerEvents: pointerEvents,
						key: name + '_' + key,
						style: [styles[name], { marginTop: this.props.statusBarHeight }, styleInterpolator(props)] }, subView);
				} }]);return NavigationHeader;
		}(React.Component);NavigationHeader.defaultProps = { renderTitleComponent: function renderTitleComponent(props) {
				var title = String(props.scene.route.title || '');return React.createElement(NavigationHeaderTitle, null, title);
			}, renderLeftComponent: function renderLeftComponent(props) {
				if (props.scene.index === 0 || !props.onNavigateBack) {
					return null;
				}return React.createElement(NavigationHeaderBackButton, { onPress: props.onNavigateBack });
			}, renderRightComponent: function renderRightComponent(props) {
				return null;
			}, statusBarHeight: STATUSBAR_HEIGHT };NavigationHeader.propTypes = babelHelpers.extends({}, NavigationPropTypes.SceneRendererProps, { onNavigateBack: PropTypes.func, renderLeftComponent: PropTypes.func, renderRightComponent: PropTypes.func, renderTitleComponent: PropTypes.func, style: View.propTypes.style, statusBarHeight: PropTypes.number, viewProps: PropTypes.shape(View.propTypes) });NavigationHeader.HEIGHT = APPBAR_HEIGHT + STATUSBAR_HEIGHT;NavigationHeader.Title = NavigationHeaderTitle;NavigationHeader.BackButton = NavigationHeaderBackButton;

		var styles = StyleSheet.create({
			appbar: {
				alignItems: 'center',
				backgroundColor: Platform.OS === 'ios' ? '#EFEFF2' : '#FFF',
				borderBottomColor: 'rgba(0, 0, 0, .15)',
				borderBottomWidth: Platform.OS === 'ios' ? StyleSheet.hairlineWidth : 0,
				elevation: 4,
				flexDirection: 'row',
				justifyContent: 'flex-start' },

			title: {
				bottom: 0,
				left: APPBAR_HEIGHT,
				position: 'absolute',
				right: APPBAR_HEIGHT,
				top: 0 },

			left: {
				bottom: 0,
				left: 0,
				position: 'absolute',
				top: 0 },

			right: {
				bottom: 0,
				position: 'absolute',
				right: 0,
				top: 0 } });

		module.exports = NavigationHeader;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationHeaderTitle.js
	function (__inner_require__, exports, module) {
		var React = require('react@15.3/react.js');
		var ReactNative = require('react-native@0.33/Libraries/react-native/react-native.js');var Platform = ReactNative.Platform,
		    StyleSheet = ReactNative.StyleSheet,
		    View = ReactNative.View,
		    Text = ReactNative.Text;

		var NavigationHeaderTitle = function NavigationHeaderTitle(_ref) {
			var children = _ref.children,
			    style = _ref.style,
			    textStyle = _ref.textStyle,
			    viewProps = _ref.viewProps;return React.createElement(View, babelHelpers.extends({ style: [styles.title, style] }, viewProps), React.createElement(Text, { style: [styles.titleText, textStyle] }, children));
		};

		var styles = StyleSheet.create({
			title: {
				flex: 1,
				flexDirection: 'row',
				alignItems: 'center',
				marginHorizontal: 16 },

			titleText: {
				flex: 1,
				fontSize: 18,
				fontWeight: '500',
				color: 'rgba(0, 0, 0, .9)',
				textAlign: Platform.OS === 'ios' ? 'center' : 'left' } });

		NavigationHeaderTitle.propTypes = {
			children: React.PropTypes.node.isRequired,
			style: View.propTypes.style,
			textStyle: Text.propTypes.style };

		module.exports = NavigationHeaderTitle;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationHeaderBackButton.js
	function (__inner_require__, exports, module) {
		var React = require('react@15.3/react.js');
		var ReactNative = require('react-native@0.33/Libraries/react-native/react-native.js');var I18nManager = ReactNative.I18nManager,
		    Image = ReactNative.Image,
		    Platform = ReactNative.Platform,
		    StyleSheet = ReactNative.StyleSheet,
		    TouchableOpacity = ReactNative.TouchableOpacity;

		var NavigationHeaderBackButton = function NavigationHeaderBackButton(props) {
			return React.createElement(TouchableOpacity, { style: styles.buttonContainer, onPress: props.onPress }, React.createElement(Image, { style: styles.button, source: __inner_require__(-1 /*Libraries/CustomComponents/NavigationExperimental/assets/back-icon.png*/) }));
		};

		NavigationHeaderBackButton.propTypes = {
			onPress: React.PropTypes.func.isRequired };

		var styles = StyleSheet.create({
			buttonContainer: {
				flex: 1,
				flexDirection: 'row',
				alignItems: 'center',
				justifyContent: 'center' },

			button: {
				height: 24,
				width: 24,
				margin: Platform.OS === 'ios' ? 10 : 16,
				resizeMode: 'contain',
				transform: [{ scaleX: I18nManager.isRTL ? -1 : 1 }] } });

		module.exports = NavigationHeaderBackButton;
	}, // Libraries/CustomComponents/NavigationExperimental/NavigationHeaderStyleInterpolator.js
	function (__inner_require__, exports, module) {
		var I18nManager = __inner_require__(121 /*Libraries/Utilities/I18nManager.js*/);

		function forLeft(props) {
			var position = props.position,
			    scene = props.scene;var index = scene.index;
			return {
				opacity: position.interpolate({
					inputRange: [index - 1, index, index + 1],
					outputRange: [0, 1, 0] }) };
		}

		function forCenter(props) {
			var position = props.position,
			    scene = props.scene;var index = scene.index;
			return {
				opacity: position.interpolate({
					inputRange: [index - 1, index, index + 1],
					outputRange: [0, 1, 0] }),

				transform: [{
					translateX: position.interpolate({
						inputRange: [index - 1, index + 1],
						outputRange: I18nManager.isRTL ? [-200, 200] : [200, -200] }) }] };
		}

		function forRight(props) {
			var position = props.position,
			    scene = props.scene;var index = scene.index;
			return {
				opacity: position.interpolate({
					inputRange: [index - 1, index, index + 1],
					outputRange: [0, 1, 0] }) };
		}

		module.exports = {
			forCenter: forCenter,
			forLeft: forLeft,
			forRight: forRight };
	}, // __react__/lib/ReactComponentWithPureRenderMixin.js
	function (__inner_require__, exports, module) {
		var shallowCompare = __inner_require__(251 /*__react__/lib/shallowCompare.js*/);

		var ReactComponentWithPureRenderMixin = {
			shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
				return shallowCompare(this, nextProps, nextState);
			} };

		module.exports = ReactComponentWithPureRenderMixin;
	}, // __react__/lib/shallowCompare.js
	function (__inner_require__, exports, module) {
		var shallowEqual = require('react-native@0.33/__fbjs__/lib/shallowEqual.js');

		function shallowCompare(instance, nextProps, nextState) {
			return !shallowEqual(instance.props, nextProps) || !shallowEqual(instance.state, nextState);
		}

		module.exports = shallowCompare;
	}, // Libraries/NavigationExperimental/NavigationStateUtils.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var NavigationStateUtils = {

			get: function get(state, key) {
				return state.routes.find(function (route) {
					return route.key === key;
				}) || null;
			},

			indexOf: function indexOf(state, key) {
				return state.routes.map(function (route) {
					return route.key;
				}).indexOf(key);
			},

			has: function has(state, key) {
				return !!state.routes.some(function (route) {
					return route.key === key;
				});
			},

			push: function push(state, route) {
				invariant(NavigationStateUtils.indexOf(state, route.key) === -1, 'should not push route with duplicated key %s', route.key);

				var routes = state.routes.slice();
				routes.push(route);

				return babelHelpers.extends({}, state, {
					index: routes.length - 1,
					routes: routes });
			},

			pop: function pop(state) {
				if (state.index <= 0) {

					return state;
				}
				var routes = state.routes.slice(0, -1);
				return babelHelpers.extends({}, state, {
					index: routes.length - 1,
					routes: routes });
			},

			jumpToIndex: function jumpToIndex(state, index) {
				if (index === state.index) {
					return state;
				}

				invariant(!!state.routes[index], 'invalid index %s to jump to', index);

				return babelHelpers.extends({}, state, {
					index: index });
			},

			jumpTo: function jumpTo(state, key) {
				var index = NavigationStateUtils.indexOf(state, key);
				return NavigationStateUtils.jumpToIndex(state, index);
			},

			back: function back(state) {
				var index = state.index - 1;
				var route = state.routes[index];
				return route ? NavigationStateUtils.jumpToIndex(state, index) : state;
			},

			forward: function forward(state) {
				var index = state.index + 1;
				var route = state.routes[index];
				return route ? NavigationStateUtils.jumpToIndex(state, index) : state;
			},

			replaceAt: function replaceAt(state, key, route) {
				var index = NavigationStateUtils.indexOf(state, key);
				return NavigationStateUtils.replaceAtIndex(state, index, route);
			},

			replaceAtIndex: function replaceAtIndex(state, index, route) {
				invariant(!!state.routes[index], 'invalid index %s for replacing route %s', index, route.key);

				if (state.routes[index] === route) {
					return state;
				}

				var routes = state.routes.slice();
				routes[index] = route;

				return babelHelpers.extends({}, state, {
					index: index,
					routes: routes });
			},

			reset: function reset(state, routes, index) {
				invariant(routes.length && Array.isArray(routes), 'invalid routes to replace');

				var nextIndex = index === undefined ? routes.length - 1 : index;

				if (state.routes.length === routes.length && state.index === nextIndex) {
					var compare = function compare(route, ii) {
						return routes[ii] === route;
					};
					if (state.routes.every(compare)) {
						return state;
					}
				}

				invariant(!!routes[nextIndex], 'invalid index %s to reset', nextIndex);

				return babelHelpers.extends({}, state, {
					index: nextIndex,
					routes: routes });
			} };

		module.exports = NavigationStateUtils;
	}, // Libraries/Network/NetInfo.js
	function (__inner_require__, exports, module) {
		var Map = require('react-native@0.33/Libraries/vendor/core/Map.js');
		var NativeEventEmitter = require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');
		var NativeModules = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js');
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');
		var RCTNetInfo = NativeModules.NetInfo;
		var deprecatedCallback = __inner_require__(227 /*Libraries/Utilities/deprecatedCallback.js*/);

		var NetInfoEventEmitter = new NativeEventEmitter(RCTNetInfo);

		var DEVICE_CONNECTIVITY_EVENT = 'networkStatusDidChange';

		var _subscriptions = new Map();

		var _isConnected = void 0;
		if (Platform.OS === 'ios') {
			_isConnected = function _isConnected(reachability) {
				return reachability !== 'none' && reachability !== 'unknown';
			};
		} else if (Platform.OS === 'android') {
			_isConnected = function _isConnected(connectionType) {
				return connectionType !== 'NONE' && connectionType !== 'UNKNOWN';
			};
		}

		var _isConnectedSubscriptions = new Map();

		var NetInfo = {

			addEventListener: function addEventListener(eventName, handler) {
				var listener = NetInfoEventEmitter.addListener(DEVICE_CONNECTIVITY_EVENT, function (appStateData) {
					handler(appStateData.network_info);
				});

				_subscriptions.set(handler, listener);
				return {
					remove: function remove() {
						return NetInfo.removeEventListener(eventName, handler);
					} };
			},

			removeEventListener: function removeEventListener(eventName, handler) {
				var listener = _subscriptions.get(handler);
				if (!listener) {
					return;
				}
				listener.remove();
				_subscriptions.delete(handler);
			},

			fetch: function fetch() {
				return RCTNetInfo.getCurrentConnectivity().then(function (resp) {
					return resp.network_info;
				});
			},

			isConnected: {
				addEventListener: function addEventListener(eventName, handler) {
					var listener = function listener(connection) {
						handler(_isConnected(connection));
					};
					_isConnectedSubscriptions.set(handler, listener);
					NetInfo.addEventListener(eventName, listener);

					return {
						remove: function remove() {
							return NetInfo.isConnected.removeEventListener(eventName, handler);
						} };
				},

				removeEventListener: function removeEventListener(eventName, handler) {

					var listener = _isConnectedSubscriptions.get(handler);
					NetInfo.removeEventListener(eventName, listener);

					_isConnectedSubscriptions.delete(handler);
				},

				fetch: function fetch() {
					return NetInfo.fetch().then(function (connection) {
						return _isConnected(connection);
					});
				} },

			isConnectionExpensive: function isConnectionExpensive() {
				return deprecatedCallback(Platform.OS === 'android' ? RCTNetInfo.isConnectionMetered() : Promise.reject(new Error('Currently not supported on iOS')), Array.prototype.slice.call(arguments), 'single-callback-value-first', 'NetInfo.isConnectionMetered(callback) is deprecated. Use the returned Promise instead.');
			} };

		module.exports = NetInfo;
	}, // Libraries/PermissionsAndroid/PermissionsAndroid.js
	function (__inner_require__, exports, module) {
		var DialogManagerAndroid = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').DialogManagerAndroid;
		var Permissions = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').PermissionsAndroid;var PermissionsAndroid = function () {

			function PermissionsAndroid() {
				babelHelpers.classCallCheck(this, PermissionsAndroid);

				this.PERMISSIONS = {
					READ_CALENDAR: 'android.permission.READ_CALENDAR',
					WRITE_CALENDAR: 'android.permission.WRITE_CALENDAR',
					CAMERA: 'android.permission.CAMERA',
					READ_CONTACTS: 'android.permission.READ_CONTACTS',
					WRITE_CONTACTS: 'android.permission.WRITE_CONTACTS',
					GET_ACCOUNTS: 'android.permission.GET_ACCOUNTS',
					ACCESS_FINE_LOCATION: 'android.permission.ACCESS_FINE_LOCATION',
					ACCESS_COARSE_LOCATION: 'android.permission.ACCESS_COARSE_LOCATION',
					RECORD_AUDIO: 'android.permission.RECORD_AUDIO',
					READ_PHONE_STATE: 'android.permission.READ_PHONE_STATE',
					CALL_PHONE: 'android.permission.CALL_PHONE',
					READ_CALL_LOG: 'android.permission.READ_CALL_LOG',
					WRITE_CALL_LOG: 'android.permission.WRITE_CALL_LOG',
					ADD_VOICEMAIL: 'com.android.voicemail.permission.ADD_VOICEMAIL',
					USE_SIP: 'android.permission.USE_SIP',
					PROCESS_OUTGOING_CALLS: 'android.permission.PROCESS_OUTGOING_CALLS',
					BODY_SENSORS: 'android.permission.BODY_SENSORS',
					SEND_SMS: 'android.permission.SEND_SMS',
					RECEIVE_SMS: 'android.permission.RECEIVE_SMS',
					READ_SMS: 'android.permission.READ_SMS',
					RECEIVE_WAP_PUSH: 'android.permission.RECEIVE_WAP_PUSH',
					RECEIVE_MMS: 'android.permission.RECEIVE_MMS',
					READ_EXTERNAL_STORAGE: 'android.permission.READ_EXTERNAL_STORAGE',
					WRITE_EXTERNAL_STORAGE: 'android.permission.WRITE_EXTERNAL_STORAGE' };
			}babelHelpers.createClass(PermissionsAndroid, [{ key: 'checkPermission', value: function checkPermission(permission) {
					return Permissions.checkPermission(permission);
				} }, { key: 'requestPermission', value: function requestPermission(permission, rationale) {
					var shouldShowRationale;return regeneratorRuntime.async(function requestPermission$(_context) {
						while (1) {
							switch (_context.prev = _context.next) {case 0:
									if (!rationale) {
										_context.next = 6;break;
									}_context.next = 3;return regeneratorRuntime.awrap(Permissions.shouldShowRequestPermissionRationale(permission));case 3:
									shouldShowRationale = _context.sent;if (!shouldShowRationale) {
										_context.next = 6;break;
									}return _context.abrupt('return', new Promise(function (resolve, reject) {
										DialogManagerAndroid.showAlert(rationale, function () {
											return reject(new Error('Error showing rationale'));
										}, function () {
											return resolve(Permissions.requestPermission(permission));
										});
									}));case 6:
									return _context.abrupt('return', Permissions.requestPermission(permission));case 7:case 'end':
									return _context.stop();}
						}
					}, null, this);
				} }]);return PermissionsAndroid;
		}();

		PermissionsAndroid = new PermissionsAndroid();

		module.exports = PermissionsAndroid;
	}, // Libraries/PushNotificationIOS/PushNotificationIOS.js
	function (__inner_require__, exports, module) {
		var NativeEventEmitter = require('react-native@0.33/Libraries/EventEmitter/NativeEventEmitter.js');
		var RCTPushNotificationManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').PushNotificationManager;
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var PushNotificationEmitter = new NativeEventEmitter(RCTPushNotificationManager);

		var _notifHandlers = new Map();

		var DEVICE_NOTIF_EVENT = 'remoteNotificationReceived';
		var NOTIF_REGISTER_EVENT = 'remoteNotificationsRegistered';
		var DEVICE_LOCAL_NOTIF_EVENT = 'localNotificationReceived';var PushNotificationIOS = function () {
			babelHelpers.createClass(PushNotificationIOS, null, [{ key: 'presentLocalNotification', value: function presentLocalNotification(details) {
					RCTPushNotificationManager.presentLocalNotification(details);
				} }, { key: 'scheduleLocalNotification', value: function scheduleLocalNotification(details) {
					RCTPushNotificationManager.scheduleLocalNotification(details);
				} }, { key: 'cancelAllLocalNotifications', value: function cancelAllLocalNotifications() {
					RCTPushNotificationManager.cancelAllLocalNotifications();
				} }, { key: 'setApplicationIconBadgeNumber', value: function setApplicationIconBadgeNumber(number) {
					RCTPushNotificationManager.setApplicationIconBadgeNumber(number);
				} }, { key: 'getApplicationIconBadgeNumber', value: function getApplicationIconBadgeNumber(callback) {
					RCTPushNotificationManager.getApplicationIconBadgeNumber(callback);
				} }, { key: 'cancelLocalNotifications', value: function cancelLocalNotifications(userInfo) {
					RCTPushNotificationManager.cancelLocalNotifications(userInfo);
				} }, { key: 'getScheduledLocalNotifications', value: function getScheduledLocalNotifications(callback) {
					RCTPushNotificationManager.getScheduledLocalNotifications(callback);
				} }, { key: 'addEventListener', value: function addEventListener(type, handler) {
					invariant(type === 'notification' || type === 'register' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register` and `localNotification` events');

					var listener;
					if (type === 'notification') {
						listener = PushNotificationEmitter.addListener(DEVICE_NOTIF_EVENT, function (notifData) {
							handler(new PushNotificationIOS(notifData));
						});
					} else if (type === 'localNotification') {
						listener = PushNotificationEmitter.addListener(DEVICE_LOCAL_NOTIF_EVENT, function (notifData) {
							handler(new PushNotificationIOS(notifData));
						});
					} else if (type === 'register') {
						listener = PushNotificationEmitter.addListener(NOTIF_REGISTER_EVENT, function (registrationInfo) {
							handler(registrationInfo.deviceToken);
						});
					}
					_notifHandlers.set(handler, listener);
				} }, { key: 'removeEventListener', value: function removeEventListener(type, handler) {
					invariant(type === 'notification' || type === 'register' || type === 'localNotification', 'PushNotificationIOS only supports `notification`, `register` and `localNotification` events');

					var listener = _notifHandlers.get(handler);
					if (!listener) {
						return;
					}
					listener.remove();
					_notifHandlers.delete(handler);
				} }, { key: 'requestPermissions', value: function requestPermissions(permissions) {
					var requestedPermissions = {};
					if (permissions) {
						requestedPermissions = {
							alert: !!permissions.alert,
							badge: !!permissions.badge,
							sound: !!permissions.sound };
					} else {
						requestedPermissions = {
							alert: true,
							badge: true,
							sound: true };
					}
					return RCTPushNotificationManager.requestPermissions(requestedPermissions);
				} }, { key: 'abandonPermissions', value: function abandonPermissions() {
					RCTPushNotificationManager.abandonPermissions();
				} }, { key: 'checkPermissions', value: function checkPermissions(callback) {
					invariant(typeof callback === 'function', 'Must provide a valid callback');

					RCTPushNotificationManager.checkPermissions(callback);
				} }, { key: 'getInitialNotification', value: function getInitialNotification() {
					return RCTPushNotificationManager.getInitialNotification().then(function (notification) {
						return notification && new PushNotificationIOS(notification);
					});
				} }]);

			function PushNotificationIOS(nativeNotif) {
				var _this = this;babelHelpers.classCallCheck(this, PushNotificationIOS);
				this._data = {};

				if (nativeNotif.remote) {

					Object.keys(nativeNotif).forEach(function (notifKey) {
						var notifVal = nativeNotif[notifKey];
						if (notifKey === 'aps') {
							_this._alert = notifVal.alert;
							_this._sound = notifVal.sound;
							_this._badgeCount = notifVal.badge;
						} else {
							_this._data[notifKey] = notifVal;
						}
					});
				} else {

					this._badgeCount = nativeNotif.applicationIconBadgeNumber;
					this._sound = nativeNotif.soundName;
					this._alert = nativeNotif.alertBody;
					this._data = nativeNotif.userInfo;
				}
			}babelHelpers.createClass(PushNotificationIOS, [{ key: 'getMessage', value: function getMessage() {

					return this._alert;
				} }, { key: 'getSound', value: function getSound() {
					return this._sound;
				} }, { key: 'getAlert', value: function getAlert() {
					return this._alert;
				} }, { key: 'getBadgeCount', value: function getBadgeCount() {
					return this._badgeCount;
				} }, { key: 'getData', value: function getData() {
					return this._data;
				} }]);return PushNotificationIOS;
		}();

		module.exports = PushNotificationIOS;
	}, // Libraries/Settings/Settings.ios.js
	function (__inner_require__, exports, module) {
		var RCTDeviceEventEmitter = require('react-native@0.33/Libraries/EventEmitter/RCTDeviceEventEmitter.js');
		var RCTSettingsManager = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').SettingsManager;

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var subscriptions = [];

		var Settings = {
			_settings: RCTSettingsManager && RCTSettingsManager.settings,

			get: function get(key) {
				return this._settings[key];
			},

			set: function set(settings) {
				this._settings = babelHelpers.extends(this._settings, settings);
				RCTSettingsManager.setValues(settings);
			},

			watchKeys: function watchKeys(keys, callback) {
				if (typeof keys === 'string') {
					keys = [keys];
				}

				invariant(Array.isArray(keys), 'keys should be a string or array of strings');

				var sid = subscriptions.length;
				subscriptions.push({ keys: keys, callback: callback });
				return sid;
			},

			clearWatch: function clearWatch(watchId) {
				if (watchId < subscriptions.length) {
					subscriptions[watchId] = { keys: [], callback: null };
				}
			},

			_sendObservations: function _sendObservations(body) {
				var _this = this;
				Object.keys(body).forEach(function (key) {
					var newValue = body[key];
					var didChange = _this._settings[key] !== newValue;
					_this._settings[key] = newValue;

					if (didChange) {
						subscriptions.forEach(function (sub) {
							if (sub.keys.indexOf(key) !== -1 && sub.callback) {
								sub.callback();
							}
						});
					}
				});
			} };

		RCTDeviceEventEmitter.addListener('settingsUpdated', Settings._sendObservations.bind(Settings));

		module.exports = Settings;
	}, // Libraries/Share/Share.js
	function (__inner_require__, exports, module) {
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');var _require = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js'),
		    ActionSheetManager = _require.ActionSheetManager,
		    ShareModule = _require.ShareModule;
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var processColor = require('react-native@0.33/Libraries/StyleSheet/processColor.js');var Share = function () {
			function Share() {
				babelHelpers.classCallCheck(this, Share);
			}babelHelpers.createClass(Share, null, [{ key: 'share', value: function share(content) {
					var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
					invariant(typeof content === 'object' && content !== null, 'Content must a valid object');

					invariant(typeof content.url === 'string' || typeof content.message === 'string', 'At least one of URL and message is required');

					invariant(typeof options === 'object' && options !== null, 'Options must be a valid object');

					if (Platform.OS === 'android') {
						invariant(!content.title || typeof content.title === 'string', 'Invalid title: title should be a string.');

						return ShareModule.share(content, options.dialogTitle);
					} else if (Platform.OS === 'ios') {
						return new Promise(function (resolve, reject) {
							ActionSheetManager.showShareActionSheetWithOptions(babelHelpers.extends({}, content, options, { tintColor: processColor(options.tintColor) }), function (error) {
								return reject(error);
							}, function (success, activityType) {
								if (success) {
									resolve({
										'action': 'sharedAction',
										'activityType': activityType });
								} else {
									resolve({
										'action': 'dismissedAction' });
								}
							});
						});
					} else {
						return Promise.reject(new Error('Unsupported platform'));
					}
				} }, { key: 'sharedAction', get: function get() {
					return 'sharedAction';
				} }, { key: 'dismissedAction', get: function get() {
					return 'dismissedAction';
				} }]);return Share;
		}();

		module.exports = Share;
	}, // Libraries/Components/TimePickerAndroid/TimePickerAndroid.ios.js
	function (__inner_require__, exports, module) {
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var TimePickerAndroid = {
			open: function open(options) {
				return regeneratorRuntime.async(function open$(_context) {
					while (1) {
						switch (_context.prev = _context.next) {case 0:
								return _context.abrupt('return', Promise.reject({
									message: 'TimePickerAndroid is not supported on this platform.' }));case 1:case 'end':
								return _context.stop();}
					}
				}, null, this);
			} };

		module.exports = TimePickerAndroid;
	}, // Libraries/Vibration/Vibration.js
	function (__inner_require__, exports, module) {
		var RCTVibration = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').Vibration;
		var Platform = require('react-native@0.33/Libraries/Utilities/Platform.ios.js');

		var Vibration = {
			vibrate: function vibrate() {
				var pattern = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 400;var repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
				if (Platform.OS === 'android') {
					if (typeof pattern === 'number') {
						RCTVibration.vibrate(pattern);
					} else if (Array.isArray(pattern)) {
						RCTVibration.vibrateByPattern(pattern, repeat ? 0 : -1);
					} else {
						throw new Error('Vibration pattern should be a number or array');
					}
				} else {
					if (typeof pattern === 'number') {
						RCTVibration.vibrate();
					} else if (Array.isArray(pattern)) {
						console.warn('Vibration patterns are not supported on iOS');
					} else {
						throw new Error('Vibration pattern should be a number or array');
					}
				}
			},

			cancel: function cancel() {
				if (Platform.OS === 'ios') {
					console.warn('Vibration.cancel is not supported on iOS');
				} else {
					RCTVibration.cancel();
				}
			} };

		module.exports = Vibration;
	}, // Libraries/Vibration/VibrationIOS.ios.js
	function (__inner_require__, exports, module) {
		var RCTVibration = require('react-native@0.33/Libraries/BatchedBridge/BatchedBridgedModules/NativeModules.js').Vibration;

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var VibrationIOS = {

			vibrate: function vibrate() {
				invariant(arguments[0] === undefined, 'Vibration patterns not supported.');

				RCTVibration.vibrate();
			} };

		module.exports = VibrationIOS;
	}, // __react__/lib/LinkedStateMixin.js
	function (__inner_require__, exports, module) {
		var ReactLink = __inner_require__(262 /*__react__/lib/ReactLink.js*/);
		var ReactStateSetters = __inner_require__(263 /*__react__/lib/ReactStateSetters.js*/);

		var LinkedStateMixin = {

			linkState: function linkState(key) {
				return new ReactLink(this.state[key], ReactStateSetters.createStateKeySetter(this, key));
			} };

		module.exports = LinkedStateMixin;
	}, // __react__/lib/ReactLink.js
	function (__inner_require__, exports, module) {
		var React = __inner_require__(13 /*__react__/lib/React.js*/);

		function ReactLink(value, requestChange) {
			this.value = value;
			this.requestChange = requestChange;
		}

		function createLinkTypeChecker(linkType) {
			var shapes = {
				value: linkType === undefined ? React.PropTypes.any.isRequired : linkType.isRequired,
				requestChange: React.PropTypes.func.isRequired };

			return React.PropTypes.shape(shapes);
		}

		ReactLink.PropTypes = {
			link: createLinkTypeChecker };

		module.exports = ReactLink;
	}, // __react__/lib/ReactStateSetters.js
	function (__inner_require__, exports, module) {
		var ReactStateSetters = {

			createStateSetter: function createStateSetter(component, funcReturningState) {
				return function (a, b, c, d, e, f) {
					var partialState = funcReturningState.call(component, a, b, c, d, e, f);
					if (partialState) {
						component.setState(partialState);
					}
				};
			},

			createStateKeySetter: function createStateKeySetter(component, key) {

				var cache = component.__keySetters || (component.__keySetters = {});
				return cache[key] || (cache[key] = _createStateKeySetter(component, key));
			} };

		function _createStateKeySetter(component, key) {

			var partialState = {};
			return function stateKeySetter(value) {
				partialState[key] = value;
				component.setState(partialState);
			};
		}

		ReactStateSetters.Mixin = {

			createStateSetter: function createStateSetter(funcReturningState) {
				return ReactStateSetters.createStateSetter(this, funcReturningState);
			},

			createStateKeySetter: function createStateKeySetter(key) {
				return ReactStateSetters.createStateKeySetter(this, key);
			} };

		module.exports = ReactStateSetters;
	}, // __react__/lib/ReactFragment.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactChildren = __inner_require__(14 /*__react__/lib/ReactChildren.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var numericPropertyRegex = /^\d+$/;

		var warnedAboutNumeric = false;

		var ReactFragment = {

			create: function create(object) {
				if (typeof object !== 'object' || !object || Array.isArray(object)) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment only accepts a single object. Got: %s', object) : void 0;
					return object;
				}
				if (ReactElement.isValidElement(object)) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment does not accept a ReactElement ' + 'without a wrapper object.') : void 0;
					return object;
				}

				!(object.nodeType !== 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.addons.createFragment(...): Encountered an invalid child; DOM elements are not valid children of React components.') : _prodInvariant('0') : void 0;

				var result = [];

				for (var key in object) {
					if (process.env.NODE_ENV !== 'production') {
						if (!warnedAboutNumeric && numericPropertyRegex.test(key)) {
							process.env.NODE_ENV !== 'production' ? warning(false, 'React.addons.createFragment(...): Child objects should have ' + 'non-numeric keys so ordering is preserved.') : void 0;
							warnedAboutNumeric = true;
						}
					}
					ReactChildren.mapIntoWithKeyPrefixInternal(object[key], result, key, emptyFunction.thatReturnsArgument);
				}

				return result;
			} };

		module.exports = ReactFragment;
	}, // __react__/lib/update.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var hasOwnProperty = {}.hasOwnProperty;

		function shallowCopy(x) {
			if (Array.isArray(x)) {
				return x.concat();
			} else if (x && typeof x === 'object') {
				return _assign(new x.constructor(), x);
			} else {
				return x;
			}
		}

		var COMMAND_PUSH = keyOf({ $push: null });
		var COMMAND_UNSHIFT = keyOf({ $unshift: null });
		var COMMAND_SPLICE = keyOf({ $splice: null });
		var COMMAND_SET = keyOf({ $set: null });
		var COMMAND_MERGE = keyOf({ $merge: null });
		var COMMAND_APPLY = keyOf({ $apply: null });

		var ALL_COMMANDS_LIST = [COMMAND_PUSH, COMMAND_UNSHIFT, COMMAND_SPLICE, COMMAND_SET, COMMAND_MERGE, COMMAND_APPLY];

		var ALL_COMMANDS_SET = {};

		ALL_COMMANDS_LIST.forEach(function (command) {
			ALL_COMMANDS_SET[command] = true;
		});

		function invariantArrayCase(value, spec, command) {
			!Array.isArray(value) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected target of %s to be an array; got %s.', command, value) : _prodInvariant('1', command, value) : void 0;
			var specValue = spec[command];
			!Array.isArray(specValue) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array; got %s. Did you forget to wrap your parameter in an array?', command, specValue) : _prodInvariant('2', command, specValue) : void 0;
		}

		function update(value, spec) {
			!(typeof spec === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): You provided a key path to update() that did not contain one of %s. Did you forget to include {%s: ...}?', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : _prodInvariant('3', ALL_COMMANDS_LIST.join(', '), COMMAND_SET) : void 0;

			if (hasOwnProperty.call(spec, COMMAND_SET)) {
				!(Object.keys(spec).length === 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot have more than one key in an object with %s', COMMAND_SET) : _prodInvariant('4', COMMAND_SET) : void 0;

				return spec[COMMAND_SET];
			}

			var nextValue = shallowCopy(value);

			if (hasOwnProperty.call(spec, COMMAND_MERGE)) {
				var mergeObj = spec[COMMAND_MERGE];
				!(mergeObj && typeof mergeObj === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): %s expects a spec of type \'object\'; got %s', COMMAND_MERGE, mergeObj) : _prodInvariant('5', COMMAND_MERGE, mergeObj) : void 0;
				!(nextValue && typeof nextValue === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): %s expects a target of type \'object\'; got %s', COMMAND_MERGE, nextValue) : _prodInvariant('6', COMMAND_MERGE, nextValue) : void 0;
				_assign(nextValue, spec[COMMAND_MERGE]);
			}

			if (hasOwnProperty.call(spec, COMMAND_PUSH)) {
				invariantArrayCase(value, spec, COMMAND_PUSH);
				spec[COMMAND_PUSH].forEach(function (item) {
					nextValue.push(item);
				});
			}

			if (hasOwnProperty.call(spec, COMMAND_UNSHIFT)) {
				invariantArrayCase(value, spec, COMMAND_UNSHIFT);
				spec[COMMAND_UNSHIFT].forEach(function (item) {
					nextValue.unshift(item);
				});
			}

			if (hasOwnProperty.call(spec, COMMAND_SPLICE)) {
				!Array.isArray(value) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s target to be an array; got %s', COMMAND_SPLICE, value) : _prodInvariant('7', COMMAND_SPLICE, value) : void 0;
				!Array.isArray(spec[COMMAND_SPLICE]) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : _prodInvariant('8', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : void 0;
				spec[COMMAND_SPLICE].forEach(function (args) {
					!Array.isArray(args) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be an array of arrays; got %s. Did you forget to wrap your parameters in an array?', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : _prodInvariant('8', COMMAND_SPLICE, spec[COMMAND_SPLICE]) : void 0;
					nextValue.splice.apply(nextValue, args);
				});
			}

			if (hasOwnProperty.call(spec, COMMAND_APPLY)) {
				!(typeof spec[COMMAND_APPLY] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'update(): expected spec of %s to be a function; got %s.', COMMAND_APPLY, spec[COMMAND_APPLY]) : _prodInvariant('9', COMMAND_APPLY, spec[COMMAND_APPLY]) : void 0;
				nextValue = spec[COMMAND_APPLY](nextValue);
			}

			for (var k in spec) {
				if (!(ALL_COMMANDS_SET.hasOwnProperty(k) && ALL_COMMANDS_SET[k])) {
					nextValue[k] = update(value[k], spec[k]);
				}
			}

			return nextValue;
		}

		module.exports = update;
	}, // Libraries/Utilities/throwOnWrongReactAPI.js
	function (__inner_require__, exports, module) {
		function throwOnWrongReactAPI(key) {
			throw new Error('Seems you\'re trying to access \'ReactNative.' + key + '\' from the \'react-native\' package. Perhaps you meant to access \'React.' + key + '\' from the \'react\' package instead?\n\nFor example, instead of:\n\n  import React, { Component, View } from \'react-native\';\n\nYou should now do:\n\n  import React, { Component } from \'react\';\n  import { View } from \'react-native\';\n\nCheck the release notes on how to upgrade your code - https://github.com/facebook/react-native/releases/tag/v0.25.1\n');
		}

		module.exports = throwOnWrongReactAPI;
	}, // __react__/lib/ReactTestUtils.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var React = __inner_require__(13 /*__react__/lib/React.js*/);
		var ReactDefaultInjection = __inner_require__(268 /*__react__/lib/ReactDefaultInjection.js*/);
		var ReactDOM = __inner_require__(353 /*__react__/lib/ReactDOM.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactBrowserEventEmitter = __inner_require__(314 /*__react__/lib/ReactBrowserEventEmitter.js*/);
		var ReactCompositeComponent = require('react-native@0.33/__react__/lib/ReactCompositeComponent.js');
		var ReactInstanceMap = require('react-native@0.33/__react__/lib/ReactInstanceMap.js');
		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var emptyObject = require('react-native@0.33/__fbjs__/lib/emptyObject.js');
		var findDOMNode = __inner_require__(359 /*__react__/lib/findDOMNode.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var topLevelTypes = EventConstants.topLevelTypes;

		function Event(suffix) {}

		function findAllInRenderedTreeInternal(inst, test) {
			if (!inst || !inst.getPublicInstance) {
				return [];
			}
			var publicInst = inst.getPublicInstance();
			var ret = test(publicInst) ? [publicInst] : [];
			var currentElement = inst._currentElement;
			if (ReactTestUtils.isDOMComponent(publicInst)) {
				var renderedChildren = inst._renderedChildren;
				var key;
				for (key in renderedChildren) {
					if (!renderedChildren.hasOwnProperty(key)) {
						continue;
					}
					ret = ret.concat(findAllInRenderedTreeInternal(renderedChildren[key], test));
				}
			} else if (ReactElement.isValidElement(currentElement) && typeof currentElement.type === 'function') {
				ret = ret.concat(findAllInRenderedTreeInternal(inst._renderedComponent, test));
			}
			return ret;
		}

		var ReactTestUtils = {
			renderIntoDocument: function renderIntoDocument(instance) {
				var div = document.createElement('div');

				return ReactDOM.render(instance, div);
			},

			isElement: function isElement(element) {
				return ReactElement.isValidElement(element);
			},

			isElementOfType: function isElementOfType(inst, convenienceConstructor) {
				return ReactElement.isValidElement(inst) && inst.type === convenienceConstructor;
			},

			isDOMComponent: function isDOMComponent(inst) {
				return !!(inst && inst.nodeType === 1 && inst.tagName);
			},

			isDOMComponentElement: function isDOMComponentElement(inst) {
				return !!(inst && ReactElement.isValidElement(inst) && !!inst.tagName);
			},

			isCompositeComponent: function isCompositeComponent(inst) {
				if (ReactTestUtils.isDOMComponent(inst)) {

					return false;
				}
				return inst != null && typeof inst.render === 'function' && typeof inst.setState === 'function';
			},

			isCompositeComponentWithType: function isCompositeComponentWithType(inst, type) {
				if (!ReactTestUtils.isCompositeComponent(inst)) {
					return false;
				}
				var internalInstance = ReactInstanceMap.get(inst);
				var constructor = internalInstance._currentElement.type;

				return constructor === type;
			},

			isCompositeComponentElement: function isCompositeComponentElement(inst) {
				if (!ReactElement.isValidElement(inst)) {
					return false;
				}

				var prototype = inst.type.prototype;
				return typeof prototype.render === 'function' && typeof prototype.setState === 'function';
			},

			isCompositeComponentElementWithType: function isCompositeComponentElementWithType(inst, type) {
				var internalInstance = ReactInstanceMap.get(inst);
				var constructor = internalInstance._currentElement.type;

				return !!(ReactTestUtils.isCompositeComponentElement(inst) && constructor === type);
			},

			getRenderedChildOfCompositeComponent: function getRenderedChildOfCompositeComponent(inst) {
				if (!ReactTestUtils.isCompositeComponent(inst)) {
					return null;
				}
				var internalInstance = ReactInstanceMap.get(inst);
				return internalInstance._renderedComponent.getPublicInstance();
			},

			findAllInRenderedTree: function findAllInRenderedTree(inst, test) {
				if (!inst) {
					return [];
				}
				!ReactTestUtils.isCompositeComponent(inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findAllInRenderedTree(...): instance must be a composite component') : _prodInvariant('10') : void 0;
				return findAllInRenderedTreeInternal(ReactInstanceMap.get(inst), test);
			},

			scryRenderedDOMComponentsWithClass: function scryRenderedDOMComponentsWithClass(root, classNames) {
				return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
					if (ReactTestUtils.isDOMComponent(inst)) {
						var className = inst.className;
						if (typeof className !== 'string') {

							className = inst.getAttribute('class') || '';
						}
						var classList = className.split(/\s+/);

						if (!Array.isArray(classNames)) {
							!(classNames !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'TestUtils.scryRenderedDOMComponentsWithClass expects a className as a second argument.') : _prodInvariant('11') : void 0;
							classNames = classNames.split(/\s+/);
						}
						return classNames.every(function (name) {
							return classList.indexOf(name) !== -1;
						});
					}
					return false;
				});
			},

			findRenderedDOMComponentWithClass: function findRenderedDOMComponentWithClass(root, className) {
				var all = ReactTestUtils.scryRenderedDOMComponentsWithClass(root, className);
				if (all.length !== 1) {
					throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for class:' + className);
				}
				return all[0];
			},

			scryRenderedDOMComponentsWithTag: function scryRenderedDOMComponentsWithTag(root, tagName) {
				return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
					return ReactTestUtils.isDOMComponent(inst) && inst.tagName.toUpperCase() === tagName.toUpperCase();
				});
			},

			findRenderedDOMComponentWithTag: function findRenderedDOMComponentWithTag(root, tagName) {
				var all = ReactTestUtils.scryRenderedDOMComponentsWithTag(root, tagName);
				if (all.length !== 1) {
					throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for tag:' + tagName);
				}
				return all[0];
			},

			scryRenderedComponentsWithType: function scryRenderedComponentsWithType(root, componentType) {
				return ReactTestUtils.findAllInRenderedTree(root, function (inst) {
					return ReactTestUtils.isCompositeComponentWithType(inst, componentType);
				});
			},

			findRenderedComponentWithType: function findRenderedComponentWithType(root, componentType) {
				var all = ReactTestUtils.scryRenderedComponentsWithType(root, componentType);
				if (all.length !== 1) {
					throw new Error('Did not find exactly one match (found: ' + all.length + ') ' + 'for componentType:' + componentType);
				}
				return all[0];
			},

			mockComponent: function mockComponent(module, mockTagName) {
				mockTagName = mockTagName || module.mockTagName || 'div';

				module.prototype.render.mockImplementation(function () {
					return React.createElement(mockTagName, null, this.props.children);
				});

				return this;
			},

			simulateNativeEventOnNode: function simulateNativeEventOnNode(topLevelType, node, fakeNativeEvent) {
				fakeNativeEvent.target = node;
				ReactBrowserEventEmitter.ReactEventListener.dispatchEvent(topLevelType, fakeNativeEvent);
			},

			simulateNativeEventOnDOMComponent: function simulateNativeEventOnDOMComponent(topLevelType, comp, fakeNativeEvent) {
				ReactTestUtils.simulateNativeEventOnNode(topLevelType, findDOMNode(comp), fakeNativeEvent);
			},

			nativeTouchData: function nativeTouchData(x, y) {
				return {
					touches: [{ pageX: x, pageY: y }] };
			},

			createRenderer: function createRenderer() {
				return new ReactShallowRenderer();
			},

			Simulate: null,
			SimulateNative: {} };

		var ReactShallowRenderer = function ReactShallowRenderer() {
			this._instance = null;
		};

		ReactShallowRenderer.prototype.getMountedInstance = function () {
			return this._instance ? this._instance._instance : null;
		};

		var nextDebugID = 1;

		var NoopInternalComponent = function NoopInternalComponent(element) {
			this._renderedOutput = element;
			this._currentElement = element;

			if (process.env.NODE_ENV !== 'production') {
				this._debugID = nextDebugID++;
			}
		};

		NoopInternalComponent.prototype = {

			mountComponent: function mountComponent() {},

			receiveComponent: function receiveComponent(element) {
				this._renderedOutput = element;
				this._currentElement = element;
			},

			getHostNode: function getHostNode() {
				return undefined;
			},

			unmountComponent: function unmountComponent() {},

			getPublicInstance: function getPublicInstance() {
				return null;
			} };

		var ShallowComponentWrapper = function ShallowComponentWrapper(element) {

			if (process.env.NODE_ENV !== 'production') {
				this._debugID = nextDebugID++;
			}

			this.construct(element);
		};
		_assign(ShallowComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
			_constructComponent: ReactCompositeComponent.Mixin._constructComponentWithoutOwner,
			_instantiateReactComponent: function _instantiateReactComponent(element) {
				return new NoopInternalComponent(element);
			},
			_replaceNodeWithMarkup: function _replaceNodeWithMarkup() {},
			_renderValidatedComponent: ReactCompositeComponent.Mixin._renderValidatedComponentWithoutOwnerOrContext });

		ReactShallowRenderer.prototype.render = function (element, context) {

			ReactDefaultInjection.inject();

			!ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Invalid component element.%s', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : _prodInvariant('12', typeof element === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' : '') : void 0;
			!(typeof element.type !== 'string') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactShallowRenderer render(): Shallow rendering works only with custom components, not primitives (%s). Instead of calling `.render(el)` and inspecting the rendered output, look at `el.props` directly instead.', element.type) : _prodInvariant('13', element.type) : void 0;

			if (!context) {
				context = emptyObject;
			}
			ReactUpdates.batchedUpdates(_batchedRender, this, element, context);

			return this.getRenderOutput();
		};

		function _batchedRender(renderer, element, context) {
			var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(true);
			renderer._render(element, transaction, context);
			ReactUpdates.ReactReconcileTransaction.release(transaction);
		}

		ReactShallowRenderer.prototype.getRenderOutput = function () {
			return this._instance && this._instance._renderedComponent && this._instance._renderedComponent._renderedOutput || null;
		};

		ReactShallowRenderer.prototype.unmount = function () {
			if (this._instance) {
				ReactReconciler.unmountComponent(this._instance, false);
			}
		};

		ReactShallowRenderer.prototype._render = function (element, transaction, context) {
			if (this._instance) {
				ReactReconciler.receiveComponent(this._instance, element, transaction, context);
			} else {
				var instance = new ShallowComponentWrapper(element);
				ReactReconciler.mountComponent(instance, transaction, null, null, context, 0);
				this._instance = instance;
			}
		};

		function makeSimulator(eventType) {
			return function (domComponentOrNode, eventData) {
				var node;
				!!React.isValidElement(domComponentOrNode) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'TestUtils.Simulate expects a component instance and not a ReactElement.TestUtils.Simulate will not work if you are using shallow rendering.') : _prodInvariant('14') : void 0;
				if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
					node = findDOMNode(domComponentOrNode);
				} else if (domComponentOrNode.tagName) {
					node = domComponentOrNode;
				}

				var dispatchConfig = EventPluginRegistry.eventNameDispatchConfigs[eventType];

				var fakeNativeEvent = new Event();
				fakeNativeEvent.target = node;
				fakeNativeEvent.type = eventType.toLowerCase();

				var event = new SyntheticEvent(dispatchConfig, ReactDOMComponentTree.getInstanceFromNode(node), fakeNativeEvent, node);

				event.persist();
				_assign(event, eventData);

				if (dispatchConfig.phasedRegistrationNames) {
					EventPropagators.accumulateTwoPhaseDispatches(event);
				} else {
					EventPropagators.accumulateDirectDispatches(event);
				}

				ReactUpdates.batchedUpdates(function () {
					EventPluginHub.enqueueEvents(event);
					EventPluginHub.processEventQueue(true);
				});
			};
		}

		function buildSimulators() {
			ReactTestUtils.Simulate = {};

			var eventType;
			for (eventType in EventPluginRegistry.eventNameDispatchConfigs) {

				ReactTestUtils.Simulate[eventType] = makeSimulator(eventType);
			}
		}

		var oldInjectEventPluginOrder = EventPluginHub.injection.injectEventPluginOrder;
		EventPluginHub.injection.injectEventPluginOrder = function () {
			oldInjectEventPluginOrder.apply(this, arguments);
			buildSimulators();
		};
		var oldInjectEventPlugins = EventPluginHub.injection.injectEventPluginsByName;
		EventPluginHub.injection.injectEventPluginsByName = function () {
			oldInjectEventPlugins.apply(this, arguments);
			buildSimulators();
		};

		buildSimulators();

		function makeNativeSimulator(eventType) {
			return function (domComponentOrNode, nativeEventData) {
				var fakeNativeEvent = new Event(eventType);
				_assign(fakeNativeEvent, nativeEventData);
				if (ReactTestUtils.isDOMComponent(domComponentOrNode)) {
					ReactTestUtils.simulateNativeEventOnDOMComponent(eventType, domComponentOrNode, fakeNativeEvent);
				} else if (domComponentOrNode.tagName) {

					ReactTestUtils.simulateNativeEventOnNode(eventType, domComponentOrNode, fakeNativeEvent);
				}
			};
		}

		Object.keys(topLevelTypes).forEach(function (eventType) {

			var convenienceName = eventType.indexOf('top') === 0 ? eventType.charAt(3).toLowerCase() + eventType.substr(4) : eventType;

			ReactTestUtils.SimulateNative[convenienceName] = makeNativeSimulator(eventType);
		});

		module.exports = ReactTestUtils;
	}, // __react__/lib/ReactDefaultInjection.js
	function (__inner_require__, exports, module) {
		var BeforeInputEventPlugin = __inner_require__(269 /*__react__/lib/BeforeInputEventPlugin.js*/);
		var ChangeEventPlugin = __inner_require__(274 /*__react__/lib/ChangeEventPlugin.js*/);
		var DefaultEventPluginOrder = __inner_require__(281 /*__react__/lib/DefaultEventPluginOrder.js*/);
		var EnterLeaveEventPlugin = __inner_require__(282 /*__react__/lib/EnterLeaveEventPlugin.js*/);
		var HTMLDOMPropertyConfig = __inner_require__(287 /*__react__/lib/HTMLDOMPropertyConfig.js*/);
		var ReactComponentBrowserEnvironment = __inner_require__(288 /*__react__/lib/ReactComponentBrowserEnvironment.js*/);
		var ReactDOMComponent = __inner_require__(301 /*__react__/lib/ReactDOMComponent.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactDOMEmptyComponent = __inner_require__(326 /*__react__/lib/ReactDOMEmptyComponent.js*/);
		var ReactDOMTreeTraversal = __inner_require__(327 /*__react__/lib/ReactDOMTreeTraversal.js*/);
		var ReactDOMTextComponent = __inner_require__(328 /*__react__/lib/ReactDOMTextComponent.js*/);
		var ReactDefaultBatchingStrategy = __inner_require__(95 /*__react__/lib/ReactDefaultBatchingStrategy.js*/);
		var ReactEventListener = __inner_require__(329 /*__react__/lib/ReactEventListener.js*/);
		var ReactInjection = __inner_require__(332 /*__react__/lib/ReactInjection.js*/);
		var ReactReconcileTransaction = __inner_require__(333 /*__react__/lib/ReactReconcileTransaction.js*/);
		var SVGDOMPropertyConfig = __inner_require__(340 /*__react__/lib/SVGDOMPropertyConfig.js*/);
		var SelectEventPlugin = __inner_require__(341 /*__react__/lib/SelectEventPlugin.js*/);
		var SimpleEventPlugin = __inner_require__(342 /*__react__/lib/SimpleEventPlugin.js*/);

		var alreadyInjected = false;

		function inject() {
			if (alreadyInjected) {

				return;
			}
			alreadyInjected = true;

			ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

			ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
			ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
			ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

			ReactInjection.EventPluginHub.injectEventPluginsByName({
				SimpleEventPlugin: SimpleEventPlugin,
				EnterLeaveEventPlugin: EnterLeaveEventPlugin,
				ChangeEventPlugin: ChangeEventPlugin,
				SelectEventPlugin: SelectEventPlugin,
				BeforeInputEventPlugin: BeforeInputEventPlugin });

			ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

			ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

			ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
			ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

			ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
				return new ReactDOMEmptyComponent(instantiate);
			});

			ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
			ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

			ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
		}

		module.exports = {
			inject: inject };
	}, // __react__/lib/BeforeInputEventPlugin.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var FallbackCompositionState = __inner_require__(270 /*__react__/lib/FallbackCompositionState.js*/);
		var SyntheticCompositionEvent = __inner_require__(272 /*__react__/lib/SyntheticCompositionEvent.js*/);
		var SyntheticInputEvent = __inner_require__(273 /*__react__/lib/SyntheticInputEvent.js*/);

		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var END_KEYCODES = [9, 13, 27, 32];
		var START_KEYCODE = 229;

		var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

		var documentMode = null;
		if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
			documentMode = document.documentMode;
		}

		var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

		var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

		function isPresto() {
			var opera = window.opera;
			return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
		}

		var SPACEBAR_CODE = 32;
		var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

		var topLevelTypes = EventConstants.topLevelTypes;

		var eventTypes = {
			beforeInput: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onBeforeInput: null }),
					captured: keyOf({ onBeforeInputCapture: null }) },

				dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste] },

			compositionEnd: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCompositionEnd: null }),
					captured: keyOf({ onCompositionEndCapture: null }) },

				dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown] },

			compositionStart: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCompositionStart: null }),
					captured: keyOf({ onCompositionStartCapture: null }) },

				dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown] },

			compositionUpdate: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCompositionUpdate: null }),
					captured: keyOf({ onCompositionUpdateCapture: null }) },

				dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown] } };

		var hasSpaceKeypress = false;

		function isKeypressCommand(nativeEvent) {
			return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
		}

		function getCompositionEventType(topLevelType) {
			switch (topLevelType) {
				case topLevelTypes.topCompositionStart:
					return eventTypes.compositionStart;
				case topLevelTypes.topCompositionEnd:
					return eventTypes.compositionEnd;
				case topLevelTypes.topCompositionUpdate:
					return eventTypes.compositionUpdate;}
		}

		function isFallbackCompositionStart(topLevelType, nativeEvent) {
			return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
		}

		function isFallbackCompositionEnd(topLevelType, nativeEvent) {
			switch (topLevelType) {
				case topLevelTypes.topKeyUp:

					return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
				case topLevelTypes.topKeyDown:

					return nativeEvent.keyCode !== START_KEYCODE;
				case topLevelTypes.topKeyPress:
				case topLevelTypes.topMouseDown:
				case topLevelTypes.topBlur:

					return true;
				default:
					return false;}
		}

		function getDataFromCustomEvent(nativeEvent) {
			var detail = nativeEvent.detail;
			if (typeof detail === 'object' && 'data' in detail) {
				return detail.data;
			}
			return null;
		}

		var currentComposition = null;

		function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
			var eventType;
			var fallbackData;

			if (canUseCompositionEvent) {
				eventType = getCompositionEventType(topLevelType);
			} else if (!currentComposition) {
				if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
					eventType = eventTypes.compositionStart;
				}
			} else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
				eventType = eventTypes.compositionEnd;
			}

			if (!eventType) {
				return null;
			}

			if (useFallbackCompositionData) {

				if (!currentComposition && eventType === eventTypes.compositionStart) {
					currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
				} else if (eventType === eventTypes.compositionEnd) {
					if (currentComposition) {
						fallbackData = currentComposition.getData();
					}
				}
			}

			var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

			if (fallbackData) {

				event.data = fallbackData;
			} else {
				var customData = getDataFromCustomEvent(nativeEvent);
				if (customData !== null) {
					event.data = customData;
				}
			}

			EventPropagators.accumulateTwoPhaseDispatches(event);
			return event;
		}

		function getNativeBeforeInputChars(topLevelType, nativeEvent) {
			switch (topLevelType) {
				case topLevelTypes.topCompositionEnd:
					return getDataFromCustomEvent(nativeEvent);
				case topLevelTypes.topKeyPress:

					var which = nativeEvent.which;
					if (which !== SPACEBAR_CODE) {
						return null;
					}

					hasSpaceKeypress = true;
					return SPACEBAR_CHAR;

				case topLevelTypes.topTextInput:

					var chars = nativeEvent.data;

					if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
						return null;
					}

					return chars;

				default:

					return null;}
		}

		function getFallbackBeforeInputChars(topLevelType, nativeEvent) {

			if (currentComposition) {
				if (topLevelType === topLevelTypes.topCompositionEnd || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
					var chars = currentComposition.getData();
					FallbackCompositionState.release(currentComposition);
					currentComposition = null;
					return chars;
				}
				return null;
			}

			switch (topLevelType) {
				case topLevelTypes.topPaste:

					return null;
				case topLevelTypes.topKeyPress:

					if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
						return String.fromCharCode(nativeEvent.which);
					}
					return null;
				case topLevelTypes.topCompositionEnd:
					return useFallbackCompositionData ? null : nativeEvent.data;
				default:
					return null;}
		}

		function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
			var chars;

			if (canUseTextInputEvent) {
				chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
			} else {
				chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
			}

			if (!chars) {
				return null;
			}

			var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

			event.data = chars;
			EventPropagators.accumulateTwoPhaseDispatches(event);
			return event;
		}

		var BeforeInputEventPlugin = {

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
			} };

		module.exports = BeforeInputEventPlugin;
	}, // __react__/lib/FallbackCompositionState.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');

		var getTextContentAccessor = __inner_require__(271 /*__react__/lib/getTextContentAccessor.js*/);

		function FallbackCompositionState(root) {
			this._root = root;
			this._startText = this.getText();
			this._fallbackText = null;
		}

		_assign(FallbackCompositionState.prototype, {
			destructor: function destructor() {
				this._root = null;
				this._startText = null;
				this._fallbackText = null;
			},

			getText: function getText() {
				if ('value' in this._root) {
					return this._root.value;
				}
				return this._root[getTextContentAccessor()];
			},

			getData: function getData() {
				if (this._fallbackText) {
					return this._fallbackText;
				}

				var start;
				var startValue = this._startText;
				var startLength = startValue.length;
				var end;
				var endValue = this.getText();
				var endLength = endValue.length;

				for (start = 0; start < startLength; start++) {
					if (startValue[start] !== endValue[start]) {
						break;
					}
				}

				var minEnd = startLength - start;
				for (end = 1; end <= minEnd; end++) {
					if (startValue[startLength - end] !== endValue[endLength - end]) {
						break;
					}
				}

				var sliceTail = end > 1 ? 1 - end : undefined;
				this._fallbackText = endValue.slice(start, sliceTail);
				return this._fallbackText;
			} });

		PooledClass.addPoolingTo(FallbackCompositionState);

		module.exports = FallbackCompositionState;
	}, // __react__/lib/getTextContentAccessor.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var contentKey = null;

		function getTextContentAccessor() {
			if (!contentKey && ExecutionEnvironment.canUseDOM) {

				contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
			}
			return contentKey;
		}

		module.exports = getTextContentAccessor;
	}, // __react__/lib/SyntheticCompositionEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var CompositionEventInterface = {
			data: null };

		function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

		module.exports = SyntheticCompositionEvent;
	}, // __react__/lib/SyntheticInputEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var InputEventInterface = {
			data: null };

		function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

		module.exports = SyntheticInputEvent;
	}, // __react__/lib/ChangeEventPlugin.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var getEventTarget = __inner_require__(278 /*__react__/lib/getEventTarget.js*/);
		var isEventSupported = __inner_require__(279 /*__react__/lib/isEventSupported.js*/);
		var isTextInputElement = __inner_require__(280 /*__react__/lib/isTextInputElement.js*/);
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var topLevelTypes = EventConstants.topLevelTypes;

		var eventTypes = {
			change: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onChange: null }),
					captured: keyOf({ onChangeCapture: null }) },

				dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange] } };

		var activeElement = null;
		var activeElementInst = null;
		var activeElementValue = null;
		var activeElementValueProp = null;

		function shouldUseChangeEvent(elem) {
			var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
			return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
		}

		var doesChangeEventBubble = false;
		if (ExecutionEnvironment.canUseDOM) {

			doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
		}

		function manualDispatchChangeEvent(nativeEvent) {
			var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
			EventPropagators.accumulateTwoPhaseDispatches(event);

			ReactUpdates.batchedUpdates(runEventInBatch, event);
		}

		function runEventInBatch(event) {
			EventPluginHub.enqueueEvents(event);
			EventPluginHub.processEventQueue(false);
		}

		function startWatchingForChangeEventIE8(target, targetInst) {
			activeElement = target;
			activeElementInst = targetInst;
			activeElement.attachEvent('onchange', manualDispatchChangeEvent);
		}

		function stopWatchingForChangeEventIE8() {
			if (!activeElement) {
				return;
			}
			activeElement.detachEvent('onchange', manualDispatchChangeEvent);
			activeElement = null;
			activeElementInst = null;
		}

		function getTargetInstForChangeEvent(topLevelType, targetInst) {
			if (topLevelType === topLevelTypes.topChange) {
				return targetInst;
			}
		}
		function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
			if (topLevelType === topLevelTypes.topFocus) {

				stopWatchingForChangeEventIE8();
				startWatchingForChangeEventIE8(target, targetInst);
			} else if (topLevelType === topLevelTypes.topBlur) {
				stopWatchingForChangeEventIE8();
			}
		}

		var isInputEventSupported = false;
		if (ExecutionEnvironment.canUseDOM) {

			isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
		}

		var newValueProp = {
			get: function get() {
				return activeElementValueProp.get.call(this);
			},
			set: function set(val) {

				activeElementValue = '' + val;
				activeElementValueProp.set.call(this, val);
			} };

		function startWatchingForValueChange(target, targetInst) {
			activeElement = target;
			activeElementInst = targetInst;
			activeElementValue = target.value;
			activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

			Object.defineProperty(activeElement, 'value', newValueProp);
			if (activeElement.attachEvent) {
				activeElement.attachEvent('onpropertychange', handlePropertyChange);
			} else {
				activeElement.addEventListener('propertychange', handlePropertyChange, false);
			}
		}

		function stopWatchingForValueChange() {
			if (!activeElement) {
				return;
			}

			delete activeElement.value;

			if (activeElement.detachEvent) {
				activeElement.detachEvent('onpropertychange', handlePropertyChange);
			} else {
				activeElement.removeEventListener('propertychange', handlePropertyChange, false);
			}

			activeElement = null;
			activeElementInst = null;
			activeElementValue = null;
			activeElementValueProp = null;
		}

		function handlePropertyChange(nativeEvent) {
			if (nativeEvent.propertyName !== 'value') {
				return;
			}
			var value = nativeEvent.srcElement.value;
			if (value === activeElementValue) {
				return;
			}
			activeElementValue = value;

			manualDispatchChangeEvent(nativeEvent);
		}

		function getTargetInstForInputEvent(topLevelType, targetInst) {
			if (topLevelType === topLevelTypes.topInput) {

				return targetInst;
			}
		}

		function handleEventsForInputEventIE(topLevelType, target, targetInst) {
			if (topLevelType === topLevelTypes.topFocus) {

				stopWatchingForValueChange();
				startWatchingForValueChange(target, targetInst);
			} else if (topLevelType === topLevelTypes.topBlur) {
				stopWatchingForValueChange();
			}
		}

		function getTargetInstForInputEventIE(topLevelType, targetInst) {
			if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {

				if (activeElement && activeElement.value !== activeElementValue) {
					activeElementValue = activeElement.value;
					return activeElementInst;
				}
			}
		}

		function shouldUseClickEvent(elem) {

			return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
		}

		function getTargetInstForClickEvent(topLevelType, targetInst) {
			if (topLevelType === topLevelTypes.topClick) {
				return targetInst;
			}
		}

		var ChangeEventPlugin = {

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

				var getTargetInstFunc, handleEventFunc;
				if (shouldUseChangeEvent(targetNode)) {
					if (doesChangeEventBubble) {
						getTargetInstFunc = getTargetInstForChangeEvent;
					} else {
						handleEventFunc = handleEventsForChangeEventIE8;
					}
				} else if (isTextInputElement(targetNode)) {
					if (isInputEventSupported) {
						getTargetInstFunc = getTargetInstForInputEvent;
					} else {
						getTargetInstFunc = getTargetInstForInputEventIE;
						handleEventFunc = handleEventsForInputEventIE;
					}
				} else if (shouldUseClickEvent(targetNode)) {
					getTargetInstFunc = getTargetInstForClickEvent;
				}

				if (getTargetInstFunc) {
					var inst = getTargetInstFunc(topLevelType, targetInst);
					if (inst) {
						var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
						event.type = 'change';
						EventPropagators.accumulateTwoPhaseDispatches(event);
						return event;
					}
				}

				if (handleEventFunc) {
					handleEventFunc(topLevelType, targetNode, targetInst);
				}
			} };

		module.exports = ChangeEventPlugin;
	}, // __react__/lib/ReactDOMComponentTree.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var ReactDOMComponentFlags = __inner_require__(277 /*__react__/lib/ReactDOMComponentFlags.js*/);

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
		var Flags = ReactDOMComponentFlags;

		var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

		function getRenderedHostOrTextFromComponent(component) {
			var rendered;
			while (rendered = component._renderedComponent) {
				component = rendered;
			}
			return component;
		}

		function precacheNode(inst, node) {
			var hostInst = getRenderedHostOrTextFromComponent(inst);
			hostInst._hostNode = node;
			node[internalInstanceKey] = hostInst;
		}

		function uncacheNode(inst) {
			var node = inst._hostNode;
			if (node) {
				delete node[internalInstanceKey];
				inst._hostNode = null;
			}
		}

		function precacheChildNodes(inst, node) {
			if (inst._flags & Flags.hasCachedChildNodes) {
				return;
			}
			var children = inst._renderedChildren;
			var childNode = node.firstChild;
			outer: for (var name in children) {
				if (!children.hasOwnProperty(name)) {
					continue;
				}
				var childInst = children[name];
				var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
				if (childID === 0) {

					continue;
				}

				for (; childNode !== null; childNode = childNode.nextSibling) {
					if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
						precacheNode(childInst, childNode);
						continue outer;
					}
				}

				!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
			}
			inst._flags |= Flags.hasCachedChildNodes;
		}

		function getClosestInstanceFromNode(node) {
			if (node[internalInstanceKey]) {
				return node[internalInstanceKey];
			}

			var parents = [];
			while (!node[internalInstanceKey]) {
				parents.push(node);
				if (node.parentNode) {
					node = node.parentNode;
				} else {

					return null;
				}
			}

			var closest;
			var inst;
			for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
				closest = inst;
				if (parents.length) {
					precacheChildNodes(inst, node);
				}
			}

			return closest;
		}

		function getInstanceFromNode(node) {
			var inst = getClosestInstanceFromNode(node);
			if (inst != null && inst._hostNode === node) {
				return inst;
			} else {
				return null;
			}
		}

		function getNodeFromInstance(inst) {

			!(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

			if (inst._hostNode) {
				return inst._hostNode;
			}

			var parents = [];
			while (!inst._hostNode) {
				parents.push(inst);
				!inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
				inst = inst._hostParent;
			}

			for (; parents.length; inst = parents.pop()) {
				precacheChildNodes(inst, inst._hostNode);
			}

			return inst._hostNode;
		}

		var ReactDOMComponentTree = {
			getClosestInstanceFromNode: getClosestInstanceFromNode,
			getInstanceFromNode: getInstanceFromNode,
			getNodeFromInstance: getNodeFromInstance,
			precacheChildNodes: precacheChildNodes,
			precacheNode: precacheNode,
			uncacheNode: uncacheNode };

		module.exports = ReactDOMComponentTree;
	}, // __react__/lib/DOMProperty.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function checkMask(value, bitmask) {
			return (value & bitmask) === bitmask;
		}

		var DOMPropertyInjection = {

			MUST_USE_PROPERTY: 0x1,
			HAS_BOOLEAN_VALUE: 0x4,
			HAS_NUMERIC_VALUE: 0x8,
			HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
			HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

			injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
				var Injection = DOMPropertyInjection;
				var Properties = domPropertyConfig.Properties || {};
				var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
				var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
				var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
				var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

				if (domPropertyConfig.isCustomAttribute) {
					DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
				}

				for (var propName in Properties) {
					!!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

					var lowerCased = propName.toLowerCase();
					var propConfig = Properties[propName];

					var propertyInfo = {
						attributeName: lowerCased,
						attributeNamespace: null,
						propertyName: propName,
						mutationMethod: null,

						mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
						hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
						hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
						hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
						hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE) };

					!(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

					if (process.env.NODE_ENV !== 'production') {
						DOMProperty.getPossibleStandardName[lowerCased] = propName;
					}

					if (DOMAttributeNames.hasOwnProperty(propName)) {
						var attributeName = DOMAttributeNames[propName];
						propertyInfo.attributeName = attributeName;
						if (process.env.NODE_ENV !== 'production') {
							DOMProperty.getPossibleStandardName[attributeName] = propName;
						}
					}

					if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
						propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
					}

					if (DOMPropertyNames.hasOwnProperty(propName)) {
						propertyInfo.propertyName = DOMPropertyNames[propName];
					}

					if (DOMMutationMethods.hasOwnProperty(propName)) {
						propertyInfo.mutationMethod = DOMMutationMethods[propName];
					}

					DOMProperty.properties[propName] = propertyInfo;
				}
			} };

		var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';

		var DOMProperty = {

			ID_ATTRIBUTE_NAME: 'data-reactid',
			ROOT_ATTRIBUTE_NAME: 'data-reactroot',

			ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
			ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

			properties: {},

			getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,

			_isCustomAttributeFunctions: [],

			isCustomAttribute: function isCustomAttribute(attributeName) {
				for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
					var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
					if (isCustomAttributeFn(attributeName)) {
						return true;
					}
				}
				return false;
			},

			injection: DOMPropertyInjection };

		module.exports = DOMProperty;
	}, // __react__/lib/ReactDOMComponentFlags.js
	function (__inner_require__, exports, module) {
		var ReactDOMComponentFlags = {
			hasCachedChildNodes: 1 << 0 };

		module.exports = ReactDOMComponentFlags;
	}, // __react__/lib/getEventTarget.js
	function (__inner_require__, exports, module) {
		function getEventTarget(nativeEvent) {
			var target = nativeEvent.target || nativeEvent.srcElement || window;

			if (target.correspondingUseElement) {
				target = target.correspondingUseElement;
			}

			return target.nodeType === 3 ? target.parentNode : target;
		}

		module.exports = getEventTarget;
	}, // __react__/lib/isEventSupported.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var useHasFeature;
		if (ExecutionEnvironment.canUseDOM) {
			useHasFeature = document.implementation && document.implementation.hasFeature && document.implementation.hasFeature('', '') !== true;
		}

		/**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @param {?boolean} capture Check if the capture phase is supported.
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
		function isEventSupported(eventNameSuffix, capture) {
			if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
				return false;
			}

			var eventName = 'on' + eventNameSuffix;
			var isSupported = eventName in document;

			if (!isSupported) {
				var element = document.createElement('div');
				element.setAttribute(eventName, 'return;');
				isSupported = typeof element[eventName] === 'function';
			}

			if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {

				isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
			}

			return isSupported;
		}

		module.exports = isEventSupported;
	}, // __react__/lib/isTextInputElement.js
	function (__inner_require__, exports, module) {
		var supportedInputTypes = {
			'color': true,
			'date': true,
			'datetime': true,
			'datetime-local': true,
			'email': true,
			'month': true,
			'number': true,
			'password': true,
			'range': true,
			'search': true,
			'tel': true,
			'text': true,
			'time': true,
			'url': true,
			'week': true };

		function isTextInputElement(elem) {
			var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

			if (nodeName === 'input') {
				return !!supportedInputTypes[elem.type];
			}

			if (nodeName === 'textarea') {
				return true;
			}

			return false;
		}

		module.exports = isTextInputElement;
	}, // __react__/lib/DefaultEventPluginOrder.js
	function (__inner_require__, exports, module) {
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];

		module.exports = DefaultEventPluginOrder;
	}, // __react__/lib/EnterLeaveEventPlugin.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var SyntheticMouseEvent = __inner_require__(283 /*__react__/lib/SyntheticMouseEvent.js*/);

		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var topLevelTypes = EventConstants.topLevelTypes;

		var eventTypes = {
			mouseEnter: {
				registrationName: keyOf({ onMouseEnter: null }),
				dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver] },

			mouseLeave: {
				registrationName: keyOf({ onMouseLeave: null }),
				dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver] } };

		var EnterLeaveEventPlugin = {

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
					return null;
				}
				if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {

					return null;
				}

				var win;
				if (nativeEventTarget.window === nativeEventTarget) {

					win = nativeEventTarget;
				} else {

					var doc = nativeEventTarget.ownerDocument;
					if (doc) {
						win = doc.defaultView || doc.parentWindow;
					} else {
						win = window;
					}
				}

				var from;
				var to;
				if (topLevelType === topLevelTypes.topMouseOut) {
					from = targetInst;
					var related = nativeEvent.relatedTarget || nativeEvent.toElement;
					to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
				} else {

					from = null;
					to = targetInst;
				}

				if (from === to) {

					return null;
				}

				var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
				var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

				var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
				leave.type = 'mouseleave';
				leave.target = fromNode;
				leave.relatedTarget = toNode;

				var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
				enter.type = 'mouseenter';
				enter.target = toNode;
				enter.relatedTarget = fromNode;

				EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

				return [leave, enter];
			} };

		module.exports = EnterLeaveEventPlugin;
	}, // __react__/lib/SyntheticMouseEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticUIEvent = __inner_require__(284 /*__react__/lib/SyntheticUIEvent.js*/);
		var ViewportMetrics = __inner_require__(285 /*__react__/lib/ViewportMetrics.js*/);

		var getEventModifierState = __inner_require__(286 /*__react__/lib/getEventModifierState.js*/);

		var MouseEventInterface = {
			screenX: null,
			screenY: null,
			clientX: null,
			clientY: null,
			ctrlKey: null,
			shiftKey: null,
			altKey: null,
			metaKey: null,
			getModifierState: getEventModifierState,
			button: function button(event) {

				var button = event.button;
				if ('which' in event) {
					return button;
				}

				return button === 2 ? 2 : button === 4 ? 1 : 0;
			},
			buttons: null,
			relatedTarget: function relatedTarget(event) {
				return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
			},

			pageX: function pageX(event) {
				return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
			},
			pageY: function pageY(event) {
				return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
			} };

		function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

		module.exports = SyntheticMouseEvent;
	}, // __react__/lib/SyntheticUIEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var getEventTarget = __inner_require__(278 /*__react__/lib/getEventTarget.js*/);

		var UIEventInterface = {
			view: function view(event) {
				if (event.view) {
					return event.view;
				}

				var target = getEventTarget(event);
				if (target.window === target) {

					return target;
				}

				var doc = target.ownerDocument;

				if (doc) {
					return doc.defaultView || doc.parentWindow;
				} else {
					return window;
				}
			},
			detail: function detail(event) {
				return event.detail || 0;
			} };

		function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

		module.exports = SyntheticUIEvent;
	}, // __react__/lib/ViewportMetrics.js
	function (__inner_require__, exports, module) {
		var ViewportMetrics = {

			currentScrollLeft: 0,

			currentScrollTop: 0,

			refreshScrollValues: function refreshScrollValues(scrollPosition) {
				ViewportMetrics.currentScrollLeft = scrollPosition.x;
				ViewportMetrics.currentScrollTop = scrollPosition.y;
			} };

		module.exports = ViewportMetrics;
	}, // __react__/lib/getEventModifierState.js
	function (__inner_require__, exports, module) {
		var modifierKeyToProp = {
			'Alt': 'altKey',
			'Control': 'ctrlKey',
			'Meta': 'metaKey',
			'Shift': 'shiftKey' };

		function modifierStateGetter(keyArg) {
			var syntheticEvent = this;
			var nativeEvent = syntheticEvent.nativeEvent;
			if (nativeEvent.getModifierState) {
				return nativeEvent.getModifierState(keyArg);
			}
			var keyProp = modifierKeyToProp[keyArg];
			return keyProp ? !!nativeEvent[keyProp] : false;
		}

		function getEventModifierState(nativeEvent) {
			return modifierStateGetter;
		}

		module.exports = getEventModifierState;
	}, // __react__/lib/HTMLDOMPropertyConfig.js
	function (__inner_require__, exports, module) {
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);

		var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
		var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
		var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
		var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
		var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

		var HTMLDOMPropertyConfig = {
			isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
			Properties: {

				accept: 0,
				acceptCharset: 0,
				accessKey: 0,
				action: 0,
				allowFullScreen: HAS_BOOLEAN_VALUE,
				allowTransparency: 0,
				alt: 0,

				as: 0,
				async: HAS_BOOLEAN_VALUE,
				autoComplete: 0,

				autoPlay: HAS_BOOLEAN_VALUE,
				capture: HAS_BOOLEAN_VALUE,
				cellPadding: 0,
				cellSpacing: 0,
				charSet: 0,
				challenge: 0,
				checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
				cite: 0,
				classID: 0,
				className: 0,
				cols: HAS_POSITIVE_NUMERIC_VALUE,
				colSpan: 0,
				content: 0,
				contentEditable: 0,
				contextMenu: 0,
				controls: HAS_BOOLEAN_VALUE,
				coords: 0,
				crossOrigin: 0,
				data: 0,
				dateTime: 0,
				'default': HAS_BOOLEAN_VALUE,
				defer: HAS_BOOLEAN_VALUE,
				dir: 0,
				disabled: HAS_BOOLEAN_VALUE,
				download: HAS_OVERLOADED_BOOLEAN_VALUE,
				draggable: 0,
				encType: 0,
				form: 0,
				formAction: 0,
				formEncType: 0,
				formMethod: 0,
				formNoValidate: HAS_BOOLEAN_VALUE,
				formTarget: 0,
				frameBorder: 0,
				headers: 0,
				height: 0,
				hidden: HAS_BOOLEAN_VALUE,
				high: 0,
				href: 0,
				hrefLang: 0,
				htmlFor: 0,
				httpEquiv: 0,
				icon: 0,
				id: 0,
				inputMode: 0,
				integrity: 0,
				is: 0,
				keyParams: 0,
				keyType: 0,
				kind: 0,
				label: 0,
				lang: 0,
				list: 0,
				loop: HAS_BOOLEAN_VALUE,
				low: 0,
				manifest: 0,
				marginHeight: 0,
				marginWidth: 0,
				max: 0,
				maxLength: 0,
				media: 0,
				mediaGroup: 0,
				method: 0,
				min: 0,
				minLength: 0,

				multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
				muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
				name: 0,
				nonce: 0,
				noValidate: HAS_BOOLEAN_VALUE,
				open: HAS_BOOLEAN_VALUE,
				optimum: 0,
				pattern: 0,
				placeholder: 0,
				playsInline: HAS_BOOLEAN_VALUE,
				poster: 0,
				preload: 0,
				profile: 0,
				radioGroup: 0,
				readOnly: HAS_BOOLEAN_VALUE,
				referrerPolicy: 0,
				rel: 0,
				required: HAS_BOOLEAN_VALUE,
				reversed: HAS_BOOLEAN_VALUE,
				role: 0,
				rows: HAS_POSITIVE_NUMERIC_VALUE,
				rowSpan: HAS_NUMERIC_VALUE,
				sandbox: 0,
				scope: 0,
				scoped: HAS_BOOLEAN_VALUE,
				scrolling: 0,
				seamless: HAS_BOOLEAN_VALUE,
				selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
				shape: 0,
				size: HAS_POSITIVE_NUMERIC_VALUE,
				sizes: 0,
				span: HAS_POSITIVE_NUMERIC_VALUE,
				spellCheck: 0,
				src: 0,
				srcDoc: 0,
				srcLang: 0,
				srcSet: 0,
				start: HAS_NUMERIC_VALUE,
				step: 0,
				style: 0,
				summary: 0,
				tabIndex: 0,
				target: 0,
				title: 0,

				type: 0,
				useMap: 0,
				value: 0,
				width: 0,
				wmode: 0,
				wrap: 0,

				about: 0,
				datatype: 0,
				inlist: 0,
				prefix: 0,

				property: 0,
				resource: 0,
				'typeof': 0,
				vocab: 0,

				autoCapitalize: 0,
				autoCorrect: 0,

				autoSave: 0,

				color: 0,

				itemProp: 0,
				itemScope: HAS_BOOLEAN_VALUE,
				itemType: 0,

				itemID: 0,
				itemRef: 0,

				results: 0,

				security: 0,

				unselectable: 0 },

			DOMAttributeNames: {
				acceptCharset: 'accept-charset',
				className: 'class',
				htmlFor: 'for',
				httpEquiv: 'http-equiv' },

			DOMPropertyNames: {} };

		module.exports = HTMLDOMPropertyConfig;
	}, // __react__/lib/ReactComponentBrowserEnvironment.js
	function (__inner_require__, exports, module) {
		var DOMChildrenOperations = __inner_require__(289 /*__react__/lib/DOMChildrenOperations.js*/);
		var ReactDOMIDOperations = __inner_require__(300 /*__react__/lib/ReactDOMIDOperations.js*/);

		var ReactComponentBrowserEnvironment = {

			processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

			replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup };

		module.exports = ReactComponentBrowserEnvironment;
	}, // __react__/lib/DOMChildrenOperations.js
	function (__inner_require__, exports, module) {
		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var Danger = __inner_require__(296 /*__react__/lib/Danger.js*/);
		var ReactMultiChildUpdateTypes = __inner_require__(64 /*__react__/lib/ReactMultiChildUpdateTypes.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');

		var createMicrosoftUnsafeLocalFunction = __inner_require__(293 /*__react__/lib/createMicrosoftUnsafeLocalFunction.js*/);
		var setInnerHTML = __inner_require__(292 /*__react__/lib/setInnerHTML.js*/);
		var setTextContent = __inner_require__(294 /*__react__/lib/setTextContent.js*/);

		function getNodeAfter(parentNode, node) {

			if (Array.isArray(node)) {
				node = node[1];
			}
			return node ? node.nextSibling : parentNode.firstChild;
		}

		var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {

			parentNode.insertBefore(childNode, referenceNode);
		});

		function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
			DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
		}

		function moveChild(parentNode, childNode, referenceNode) {
			if (Array.isArray(childNode)) {
				moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
			} else {
				insertChildAt(parentNode, childNode, referenceNode);
			}
		}

		function removeChild(parentNode, childNode) {
			if (Array.isArray(childNode)) {
				var closingComment = childNode[1];
				childNode = childNode[0];
				removeDelimitedText(parentNode, childNode, closingComment);
				parentNode.removeChild(closingComment);
			}
			parentNode.removeChild(childNode);
		}

		function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
			var node = openingComment;
			while (true) {
				var nextNode = node.nextSibling;
				insertChildAt(parentNode, node, referenceNode);
				if (node === closingComment) {
					break;
				}
				node = nextNode;
			}
		}

		function removeDelimitedText(parentNode, startNode, closingComment) {
			while (true) {
				var node = startNode.nextSibling;
				if (node === closingComment) {

					break;
				} else {
					parentNode.removeChild(node);
				}
			}
		}

		function replaceDelimitedText(openingComment, closingComment, stringText) {
			var parentNode = openingComment.parentNode;
			var nodeAfterComment = openingComment.nextSibling;
			if (nodeAfterComment === closingComment) {

				if (stringText) {
					insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
				}
			} else {
				if (stringText) {

					setTextContent(nodeAfterComment, stringText);
					removeDelimitedText(parentNode, nodeAfterComment, closingComment);
				} else {
					removeDelimitedText(parentNode, openingComment, closingComment);
				}
			}

			if (process.env.NODE_ENV !== 'production') {
				ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID, 'replace text', stringText);
			}
		}

		var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
		if (process.env.NODE_ENV !== 'production') {
			dangerouslyReplaceNodeWithMarkup = function dangerouslyReplaceNodeWithMarkup(oldChild, markup, prevInstance) {
				Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
				if (prevInstance._debugID !== 0) {
					ReactInstrumentation.debugTool.onHostOperation(prevInstance._debugID, 'replace with', markup.toString());
				} else {
					var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
					if (nextInstance._debugID !== 0) {
						ReactInstrumentation.debugTool.onHostOperation(nextInstance._debugID, 'mount', markup.toString());
					}
				}
			};
		}

		var DOMChildrenOperations = {

			dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

			replaceDelimitedText: replaceDelimitedText,

			processUpdates: function processUpdates(parentNode, updates) {
				if (process.env.NODE_ENV !== 'production') {
					var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
				}

				for (var k = 0; k < updates.length; k++) {
					var update = updates[k];
					switch (update.type) {
						case ReactMultiChildUpdateTypes.INSERT_MARKUP:
							insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
							if (process.env.NODE_ENV !== 'production') {
								ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'insert child', { toIndex: update.toIndex, content: update.content.toString() });
							}
							break;
						case ReactMultiChildUpdateTypes.MOVE_EXISTING:
							moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
							if (process.env.NODE_ENV !== 'production') {
								ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'move child', { fromIndex: update.fromIndex, toIndex: update.toIndex });
							}
							break;
						case ReactMultiChildUpdateTypes.SET_MARKUP:
							setInnerHTML(parentNode, update.content);
							if (process.env.NODE_ENV !== 'production') {
								ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace children', update.content.toString());
							}
							break;
						case ReactMultiChildUpdateTypes.TEXT_CONTENT:
							setTextContent(parentNode, update.content);
							if (process.env.NODE_ENV !== 'production') {
								ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'replace text', update.content.toString());
							}
							break;
						case ReactMultiChildUpdateTypes.REMOVE_NODE:
							removeChild(parentNode, update.fromNode);
							if (process.env.NODE_ENV !== 'production') {
								ReactInstrumentation.debugTool.onHostOperation(parentNodeDebugID, 'remove child', { fromIndex: update.fromIndex });
							}
							break;}
				}
			} };

		module.exports = DOMChildrenOperations;
	}, // __react__/lib/DOMLazyTree.js
	function (__inner_require__, exports, module) {
		var DOMNamespaces = __inner_require__(291 /*__react__/lib/DOMNamespaces.js*/);
		var setInnerHTML = __inner_require__(292 /*__react__/lib/setInnerHTML.js*/);

		var createMicrosoftUnsafeLocalFunction = __inner_require__(293 /*__react__/lib/createMicrosoftUnsafeLocalFunction.js*/);
		var setTextContent = __inner_require__(294 /*__react__/lib/setTextContent.js*/);

		var ELEMENT_NODE_TYPE = 1;
		var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

		var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

		function insertTreeChildren(tree) {
			if (!enableLazy) {
				return;
			}
			var node = tree.node;
			var children = tree.children;
			if (children.length) {
				for (var i = 0; i < children.length; i++) {
					insertTreeBefore(node, children[i], null);
				}
			} else if (tree.html != null) {
				setInnerHTML(node, tree.html);
			} else if (tree.text != null) {
				setTextContent(node, tree.text);
			}
		}

		var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {

			if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
				insertTreeChildren(tree);
				parentNode.insertBefore(tree.node, referenceNode);
			} else {
				parentNode.insertBefore(tree.node, referenceNode);
				insertTreeChildren(tree);
			}
		});

		function replaceChildWithTree(oldNode, newTree) {
			oldNode.parentNode.replaceChild(newTree.node, oldNode);
			insertTreeChildren(newTree);
		}

		function queueChild(parentTree, childTree) {
			if (enableLazy) {
				parentTree.children.push(childTree);
			} else {
				parentTree.node.appendChild(childTree.node);
			}
		}

		function queueHTML(tree, html) {
			if (enableLazy) {
				tree.html = html;
			} else {
				setInnerHTML(tree.node, html);
			}
		}

		function queueText(tree, text) {
			if (enableLazy) {
				tree.text = text;
			} else {
				setTextContent(tree.node, text);
			}
		}

		function toString() {
			return this.node.nodeName;
		}

		function DOMLazyTree(node) {
			return {
				node: node,
				children: [],
				html: null,
				text: null,
				toString: toString };
		}

		DOMLazyTree.insertTreeBefore = insertTreeBefore;
		DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
		DOMLazyTree.queueChild = queueChild;
		DOMLazyTree.queueHTML = queueHTML;
		DOMLazyTree.queueText = queueText;

		module.exports = DOMLazyTree;
	}, // __react__/lib/DOMNamespaces.js
	function (__inner_require__, exports, module) {
		var DOMNamespaces = {
			html: 'http://www.w3.org/1999/xhtml',
			mathml: 'http://www.w3.org/1998/Math/MathML',
			svg: 'http://www.w3.org/2000/svg' };

		module.exports = DOMNamespaces;
	}, // __react__/lib/setInnerHTML.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var DOMNamespaces = __inner_require__(291 /*__react__/lib/DOMNamespaces.js*/);

		var WHITESPACE_TEST = /^[ \r\n\t\f]/;
		var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

		var createMicrosoftUnsafeLocalFunction = __inner_require__(293 /*__react__/lib/createMicrosoftUnsafeLocalFunction.js*/);

		var reusableSVGContainer;

		var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {

			if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
				reusableSVGContainer = reusableSVGContainer || document.createElement('div');
				reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
				var svgNode = reusableSVGContainer.firstChild;
				while (svgNode.firstChild) {
					node.appendChild(svgNode.firstChild);
				}
			} else {
				node.innerHTML = html;
			}
		});

		if (ExecutionEnvironment.canUseDOM) {

			var testElement = document.createElement('div');
			testElement.innerHTML = ' ';
			if (testElement.innerHTML === '') {
				setInnerHTML = function setInnerHTML(node, html) {

					if (node.parentNode) {
						node.parentNode.replaceChild(node, node);
					}

					if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {

						node.innerHTML = String.fromCharCode(0xFEFF) + html;

						var textNode = node.firstChild;
						if (textNode.data.length === 1) {
							node.removeChild(textNode);
						} else {
							textNode.deleteData(0, 1);
						}
					} else {
						node.innerHTML = html;
					}
				};
			}
			testElement = null;
		}

		module.exports = setInnerHTML;
	}, // __react__/lib/createMicrosoftUnsafeLocalFunction.js
	function (__inner_require__, exports, module) {
		var createMicrosoftUnsafeLocalFunction = function createMicrosoftUnsafeLocalFunction(func) {
			if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
				return function (arg0, arg1, arg2, arg3) {
					MSApp.execUnsafeLocalFunction(function () {
						return func(arg0, arg1, arg2, arg3);
					});
				};
			} else {
				return func;
			}
		};

		module.exports = createMicrosoftUnsafeLocalFunction;
	}, // __react__/lib/setTextContent.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var escapeTextContentForBrowser = __inner_require__(295 /*__react__/lib/escapeTextContentForBrowser.js*/);
		var setInnerHTML = __inner_require__(292 /*__react__/lib/setInnerHTML.js*/);

		var setTextContent = function setTextContent(node, text) {
			if (text) {
				var firstChild = node.firstChild;

				if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
					firstChild.nodeValue = text;
					return;
				}
			}
			node.textContent = text;
		};

		if (ExecutionEnvironment.canUseDOM) {
			if (!('textContent' in document.documentElement)) {
				setTextContent = function setTextContent(node, text) {
					setInnerHTML(node, escapeTextContentForBrowser(text));
				};
			}
		}

		module.exports = setTextContent;
	}, // __react__/lib/escapeTextContentForBrowser.js
	function (__inner_require__, exports, module) {
		var matchHtmlRegExp = /["'&<>]/;

		function escapeHtml(string) {
			var str = '' + string;
			var match = matchHtmlRegExp.exec(str);

			if (!match) {
				return str;
			}

			var escape;
			var html = '';
			var index = 0;
			var lastIndex = 0;

			for (index = match.index; index < str.length; index++) {
				switch (str.charCodeAt(index)) {
					case 34:

						escape = '&quot;';
						break;
					case 38:

						escape = '&amp;';
						break;
					case 39:

						escape = '&#x27;';
						break;
					case 60:

						escape = '&lt;';
						break;
					case 62:

						escape = '&gt;';
						break;
					default:
						continue;}

				if (lastIndex !== index) {
					html += str.substring(lastIndex, index);
				}

				lastIndex = index + 1;
				html += escape;
			}

			return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
		}

		function escapeTextContentForBrowser(text) {
			if (typeof text === 'boolean' || typeof text === 'number') {

				return '' + text;
			}
			return escapeHtml(text);
		}

		module.exports = escapeTextContentForBrowser;
	}, // __react__/lib/Danger.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var createNodesFromMarkup = __inner_require__(297 /*__fbjs__/lib/createNodesFromMarkup.js*/);
		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var Danger = {

			dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
				!ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
				!markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
				!(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

				if (typeof markup === 'string') {
					var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
					oldChild.parentNode.replaceChild(newChild, oldChild);
				} else {
					DOMLazyTree.replaceChildWithTree(oldChild, markup);
				}
			} };

		module.exports = Danger;
	}, // __fbjs__/lib/createNodesFromMarkup.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var createArrayFromMixed = __inner_require__(298 /*__fbjs__/lib/createArrayFromMixed.js*/);
		var getMarkupWrap = __inner_require__(299 /*__fbjs__/lib/getMarkupWrap.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

		var nodeNamePattern = /^\s*<(\w+)/;

		function getNodeName(markup) {
			var nodeNameMatch = markup.match(nodeNamePattern);
			return nodeNameMatch && nodeNameMatch[1].toLowerCase();
		}

		function createNodesFromMarkup(markup, handleScript) {
			var node = dummyNode;
			!!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
			var nodeName = getNodeName(markup);

			var wrap = nodeName && getMarkupWrap(nodeName);
			if (wrap) {
				node.innerHTML = wrap[1] + markup + wrap[2];

				var wrapDepth = wrap[0];
				while (wrapDepth--) {
					node = node.lastChild;
				}
			} else {
				node.innerHTML = markup;
			}

			var scripts = node.getElementsByTagName('script');
			if (scripts.length) {
				!handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
				createArrayFromMixed(scripts).forEach(handleScript);
			}

			var nodes = Array.from(node.childNodes);
			while (node.lastChild) {
				node.removeChild(node.lastChild);
			}
			return nodes;
		}

		module.exports = createNodesFromMarkup;
	}, // __fbjs__/lib/createArrayFromMixed.js
	function (__inner_require__, exports, module) {
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function toArray(obj) {
			var length = obj.length;

			!(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

			!(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

			!(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

			!(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

			if (obj.hasOwnProperty) {
				try {
					return Array.prototype.slice.call(obj);
				} catch (e) {}
			}

			var ret = Array(length);
			for (var ii = 0; ii < length; ii++) {
				ret[ii] = obj[ii];
			}
			return ret;
		}

		function hasArrayNature(obj) {
			return !!obj && (typeof obj == 'object' || typeof obj == 'function') && 'length' in obj && !('setInterval' in obj) && typeof obj.nodeType != 'number' && (Array.isArray(obj) || 'callee' in obj || 'item' in obj);
		}

		function createArrayFromMixed(obj) {
			if (!hasArrayNature(obj)) {
				return [obj];
			} else if (Array.isArray(obj)) {
				return obj.slice();
			} else {
				return toArray(obj);
			}
		}

		module.exports = createArrayFromMixed;
	}, // __fbjs__/lib/getMarkupWrap.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

		var shouldWrap = {};

		var selectWrap = [1, '<select multiple="true">', '</select>'];
		var tableWrap = [1, '<table>', '</table>'];
		var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

		var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

		var markupWrap = {
			'*': [1, '?<div>', '</div>'],

			'area': [1, '<map>', '</map>'],
			'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
			'legend': [1, '<fieldset>', '</fieldset>'],
			'param': [1, '<object>', '</object>'],
			'tr': [2, '<table><tbody>', '</tbody></table>'],

			'optgroup': selectWrap,
			'option': selectWrap,

			'caption': tableWrap,
			'colgroup': tableWrap,
			'tbody': tableWrap,
			'tfoot': tableWrap,
			'thead': tableWrap,

			'td': trWrap,
			'th': trWrap };

		var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
		svgElements.forEach(function (nodeName) {
			markupWrap[nodeName] = svgWrap;
			shouldWrap[nodeName] = true;
		});

		function getMarkupWrap(nodeName) {
			!!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
			if (!markupWrap.hasOwnProperty(nodeName)) {
				nodeName = '*';
			}
			if (!shouldWrap.hasOwnProperty(nodeName)) {
				if (nodeName === '*') {
					dummyNode.innerHTML = '<link />';
				} else {
					dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
				}
				shouldWrap[nodeName] = !dummyNode.firstChild;
			}
			return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
		}

		module.exports = getMarkupWrap;
	}, // __react__/lib/ReactDOMIDOperations.js
	function (__inner_require__, exports, module) {
		var DOMChildrenOperations = __inner_require__(289 /*__react__/lib/DOMChildrenOperations.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);

		var ReactDOMIDOperations = {

			dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(parentInst, updates) {
				var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
				DOMChildrenOperations.processUpdates(node, updates);
			} };

		module.exports = ReactDOMIDOperations;
	}, // __react__/lib/ReactDOMComponent.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var AutoFocusUtils = __inner_require__(302 /*__react__/lib/AutoFocusUtils.js*/);
		var CSSPropertyOperations = __inner_require__(304 /*__react__/lib/CSSPropertyOperations.js*/);
		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var DOMNamespaces = __inner_require__(291 /*__react__/lib/DOMNamespaces.js*/);
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var DOMPropertyOperations = __inner_require__(312 /*__react__/lib/DOMPropertyOperations.js*/);
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var ReactBrowserEventEmitter = __inner_require__(314 /*__react__/lib/ReactBrowserEventEmitter.js*/);
		var ReactDOMButton = __inner_require__(316 /*__react__/lib/ReactDOMButton.js*/);
		var ReactDOMComponentFlags = __inner_require__(277 /*__react__/lib/ReactDOMComponentFlags.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactDOMInput = __inner_require__(318 /*__react__/lib/ReactDOMInput.js*/);
		var ReactDOMOption = __inner_require__(320 /*__react__/lib/ReactDOMOption.js*/);
		var ReactDOMSelect = __inner_require__(321 /*__react__/lib/ReactDOMSelect.js*/);
		var ReactDOMTextarea = __inner_require__(322 /*__react__/lib/ReactDOMTextarea.js*/);
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var ReactMultiChild = __inner_require__(63 /*__react__/lib/ReactMultiChild.js*/);
		var ReactServerRenderingTransaction = __inner_require__(323 /*__react__/lib/ReactServerRenderingTransaction.js*/);

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var escapeTextContentForBrowser = __inner_require__(295 /*__react__/lib/escapeTextContentForBrowser.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var isEventSupported = __inner_require__(279 /*__react__/lib/isEventSupported.js*/);
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);
		var shallowEqual = require('react-native@0.33/__fbjs__/lib/shallowEqual.js');
		var validateDOMNesting = __inner_require__(325 /*__react__/lib/validateDOMNesting.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var Flags = ReactDOMComponentFlags;
		var deleteListener = EventPluginHub.deleteListener;
		var getNode = ReactDOMComponentTree.getNodeFromInstance;
		var listenTo = ReactBrowserEventEmitter.listenTo;
		var registrationNameModules = EventPluginRegistry.registrationNameModules;

		var CONTENT_TYPES = { 'string': true, 'number': true };

		var STYLE = keyOf({ style: null });
		var HTML = keyOf({ __html: null });
		var RESERVED_PROPS = {
			children: null,
			dangerouslySetInnerHTML: null,
			suppressContentEditableWarning: null };

		var DOC_FRAGMENT_TYPE = 11;

		function getDeclarationErrorAddendum(internalInstance) {
			if (internalInstance) {
				var owner = internalInstance._currentElement._owner || null;
				if (owner) {
					var name = owner.getName();
					if (name) {
						return ' This DOM node was rendered by `' + name + '`.';
					}
				}
			}
			return '';
		}

		function friendlyStringify(obj) {
			if (typeof obj === 'object') {
				if (Array.isArray(obj)) {
					return '[' + obj.map(friendlyStringify).join(', ') + ']';
				} else {
					var pairs = [];
					for (var key in obj) {
						if (Object.prototype.hasOwnProperty.call(obj, key)) {
							var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
							pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
						}
					}
					return '{' + pairs.join(', ') + '}';
				}
			} else if (typeof obj === 'string') {
				return JSON.stringify(obj);
			} else if (typeof obj === 'function') {
				return '[function object]';
			}

			return String(obj);
		}

		var styleMutationWarning = {};

		function checkAndWarnForMutatedStyle(style1, style2, component) {
			if (style1 == null || style2 == null) {
				return;
			}
			if (shallowEqual(style1, style2)) {
				return;
			}

			var componentName = component._tag;
			var owner = component._currentElement._owner;
			var ownerName;
			if (owner) {
				ownerName = owner.getName();
			}

			var hash = ownerName + '|' + componentName;

			if (styleMutationWarning.hasOwnProperty(hash)) {
				return;
			}

			styleMutationWarning[hash] = true;

			process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
		}

		function assertValidProps(component, props) {
			if (!props) {
				return;
			}

			if (voidElementTags[component._tag]) {
				!(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
			}
			if (props.dangerouslySetInnerHTML != null) {
				!(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
				!(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
			}
			if (process.env.NODE_ENV !== 'production') {
				process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
				process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
				process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
			}
			!(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
		}

		function enqueuePutListener(inst, registrationName, listener, transaction) {
			if (transaction instanceof ReactServerRenderingTransaction) {
				return;
			}
			if (process.env.NODE_ENV !== 'production') {

				process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
			}
			var containerInfo = inst._hostContainerInfo;
			var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
			var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
			listenTo(registrationName, doc);
			transaction.getReactMountReady().enqueue(putListener, {
				inst: inst,
				registrationName: registrationName,
				listener: listener });
		}

		function putListener() {
			var listenerToPut = this;
			EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
		}

		function inputPostMount() {
			var inst = this;
			ReactDOMInput.postMountWrapper(inst);
		}

		function textareaPostMount() {
			var inst = this;
			ReactDOMTextarea.postMountWrapper(inst);
		}

		function optionPostMount() {
			var inst = this;
			ReactDOMOption.postMountWrapper(inst);
		}

		var setAndValidateContentChildDev = emptyFunction;
		if (process.env.NODE_ENV !== 'production') {
			setAndValidateContentChildDev = function setAndValidateContentChildDev(content) {
				var hasExistingContent = this._contentDebugID != null;
				var debugID = this._debugID;

				var contentDebugID = -debugID;

				if (content == null) {
					if (hasExistingContent) {
						ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
					}
					this._contentDebugID = null;
					return;
				}

				validateDOMNesting(null, String(content), this, this._ancestorInfo);
				this._contentDebugID = contentDebugID;
				if (hasExistingContent) {
					ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
					ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
				} else {
					ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
					ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
					ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
				}
			};
		}

		var mediaEvents = {
			topAbort: 'abort',
			topCanPlay: 'canplay',
			topCanPlayThrough: 'canplaythrough',
			topDurationChange: 'durationchange',
			topEmptied: 'emptied',
			topEncrypted: 'encrypted',
			topEnded: 'ended',
			topError: 'error',
			topLoadedData: 'loadeddata',
			topLoadedMetadata: 'loadedmetadata',
			topLoadStart: 'loadstart',
			topPause: 'pause',
			topPlay: 'play',
			topPlaying: 'playing',
			topProgress: 'progress',
			topRateChange: 'ratechange',
			topSeeked: 'seeked',
			topSeeking: 'seeking',
			topStalled: 'stalled',
			topSuspend: 'suspend',
			topTimeUpdate: 'timeupdate',
			topVolumeChange: 'volumechange',
			topWaiting: 'waiting' };

		function trapBubbledEventsLocal() {
			var inst = this;

			!inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
			var node = getNode(inst);
			!node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

			switch (inst._tag) {
				case 'iframe':
				case 'object':
					inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
					break;
				case 'video':
				case 'audio':

					inst._wrapperState.listeners = [];

					for (var event in mediaEvents) {
						if (mediaEvents.hasOwnProperty(event)) {
							inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
						}
					}
					break;
				case 'source':
					inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node)];
					break;
				case 'img':
					inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
					break;
				case 'form':
					inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
					break;
				case 'input':
				case 'select':
				case 'textarea':
					inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topInvalid, 'invalid', node)];
					break;}
		}

		function postUpdateSelectWrapper() {
			ReactDOMSelect.postUpdateWrapper(this);
		}

		var omittedCloseTags = {
			'area': true,
			'base': true,
			'br': true,
			'col': true,
			'embed': true,
			'hr': true,
			'img': true,
			'input': true,
			'keygen': true,
			'link': true,
			'meta': true,
			'param': true,
			'source': true,
			'track': true,
			'wbr': true };

		var newlineEatingTags = {
			'listing': true,
			'pre': true,
			'textarea': true };

		var voidElementTags = _assign({
			'menuitem': true }, omittedCloseTags);

		var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
		var validatedTagCache = {};
		var hasOwnProperty = {}.hasOwnProperty;

		function validateDangerousTag(tag) {
			if (!hasOwnProperty.call(validatedTagCache, tag)) {
				!VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
				validatedTagCache[tag] = true;
			}
		}

		function isCustomComponent(tagName, props) {
			return tagName.indexOf('-') >= 0 || props.is != null;
		}

		var globalIdCounter = 1;

		function ReactDOMComponent(element) {
			var tag = element.type;
			validateDangerousTag(tag);
			this._currentElement = element;
			this._tag = tag.toLowerCase();
			this._namespaceURI = null;
			this._renderedChildren = null;
			this._previousStyle = null;
			this._previousStyleCopy = null;
			this._hostNode = null;
			this._hostParent = null;
			this._rootNodeID = 0;
			this._domID = 0;
			this._hostContainerInfo = null;
			this._wrapperState = null;
			this._topLevelWrapper = null;
			this._flags = 0;
			if (process.env.NODE_ENV !== 'production') {
				this._ancestorInfo = null;
				setAndValidateContentChildDev.call(this, null);
			}
		}

		ReactDOMComponent.displayName = 'ReactDOMComponent';

		ReactDOMComponent.Mixin = {

			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
				this._rootNodeID = globalIdCounter++;
				this._domID = hostContainerInfo._idCounter++;
				this._hostParent = hostParent;
				this._hostContainerInfo = hostContainerInfo;

				var props = this._currentElement.props;

				switch (this._tag) {
					case 'audio':
					case 'form':
					case 'iframe':
					case 'img':
					case 'link':
					case 'object':
					case 'source':
					case 'video':
						this._wrapperState = {
							listeners: null };

						transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
						break;
					case 'button':
						props = ReactDOMButton.getHostProps(this, props, hostParent);
						break;
					case 'input':
						ReactDOMInput.mountWrapper(this, props, hostParent);
						props = ReactDOMInput.getHostProps(this, props);
						transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
						break;
					case 'option':
						ReactDOMOption.mountWrapper(this, props, hostParent);
						props = ReactDOMOption.getHostProps(this, props);
						break;
					case 'select':
						ReactDOMSelect.mountWrapper(this, props, hostParent);
						props = ReactDOMSelect.getHostProps(this, props);
						transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
						break;
					case 'textarea':
						ReactDOMTextarea.mountWrapper(this, props, hostParent);
						props = ReactDOMTextarea.getHostProps(this, props);
						transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
						break;}

				assertValidProps(this, props);

				var namespaceURI;
				var parentTag;
				if (hostParent != null) {
					namespaceURI = hostParent._namespaceURI;
					parentTag = hostParent._tag;
				} else if (hostContainerInfo._tag) {
					namespaceURI = hostContainerInfo._namespaceURI;
					parentTag = hostContainerInfo._tag;
				}
				if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
					namespaceURI = DOMNamespaces.html;
				}
				if (namespaceURI === DOMNamespaces.html) {
					if (this._tag === 'svg') {
						namespaceURI = DOMNamespaces.svg;
					} else if (this._tag === 'math') {
						namespaceURI = DOMNamespaces.mathml;
					}
				}
				this._namespaceURI = namespaceURI;

				if (process.env.NODE_ENV !== 'production') {
					var parentInfo;
					if (hostParent != null) {
						parentInfo = hostParent._ancestorInfo;
					} else if (hostContainerInfo._tag) {
						parentInfo = hostContainerInfo._ancestorInfo;
					}
					if (parentInfo) {

						validateDOMNesting(this._tag, null, this, parentInfo);
					}
					this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
				}

				var mountImage;
				if (transaction.useCreateElement) {
					var ownerDocument = hostContainerInfo._ownerDocument;
					var el;
					if (namespaceURI === DOMNamespaces.html) {
						if (this._tag === 'script') {

							var div = ownerDocument.createElement('div');
							var type = this._currentElement.type;
							div.innerHTML = '<' + type + '></' + type + '>';
							el = div.removeChild(div.firstChild);
						} else if (props.is) {
							el = ownerDocument.createElement(this._currentElement.type, props.is);
						} else {

							el = ownerDocument.createElement(this._currentElement.type);
						}
					} else {
						el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
					}
					ReactDOMComponentTree.precacheNode(this, el);
					this._flags |= Flags.hasCachedChildNodes;
					if (!this._hostParent) {
						DOMPropertyOperations.setAttributeForRoot(el);
					}
					this._updateDOMProperties(null, props, transaction);
					var lazyTree = DOMLazyTree(el);
					this._createInitialChildren(transaction, props, context, lazyTree);
					mountImage = lazyTree;
				} else {
					var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
					var tagContent = this._createContentMarkup(transaction, props, context);
					if (!tagContent && omittedCloseTags[this._tag]) {
						mountImage = tagOpen + '/>';
					} else {
						mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
					}
				}

				switch (this._tag) {
					case 'input':
						transaction.getReactMountReady().enqueue(inputPostMount, this);
						if (props.autoFocus) {
							transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
						}
						break;
					case 'textarea':
						transaction.getReactMountReady().enqueue(textareaPostMount, this);
						if (props.autoFocus) {
							transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
						}
						break;
					case 'select':
						if (props.autoFocus) {
							transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
						}
						break;
					case 'button':
						if (props.autoFocus) {
							transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
						}
						break;
					case 'option':
						transaction.getReactMountReady().enqueue(optionPostMount, this);
						break;}

				return mountImage;
			},

			_createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
				var ret = '<' + this._currentElement.type;

				for (var propKey in props) {
					if (!props.hasOwnProperty(propKey)) {
						continue;
					}
					var propValue = props[propKey];
					if (propValue == null) {
						continue;
					}
					if (registrationNameModules.hasOwnProperty(propKey)) {
						if (propValue) {
							enqueuePutListener(this, propKey, propValue, transaction);
						}
					} else {
						if (propKey === STYLE) {
							if (propValue) {
								if (process.env.NODE_ENV !== 'production') {

									this._previousStyle = propValue;
								}
								propValue = this._previousStyleCopy = _assign({}, props.style);
							}
							propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
						}
						var markup = null;
						if (this._tag != null && isCustomComponent(this._tag, props)) {
							if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
								markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
							}
						} else {
							markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
						}
						if (markup) {
							ret += ' ' + markup;
						}
					}
				}

				if (transaction.renderToStaticMarkup) {
					return ret;
				}

				if (!this._hostParent) {
					ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
				}
				ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
				return ret;
			},

			_createContentMarkup: function _createContentMarkup(transaction, props, context) {
				var ret = '';

				var innerHTML = props.dangerouslySetInnerHTML;
				if (innerHTML != null) {
					if (innerHTML.__html != null) {
						ret = innerHTML.__html;
					}
				} else {
					var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
					var childrenToUse = contentToUse != null ? null : props.children;
					if (contentToUse != null) {

						ret = escapeTextContentForBrowser(contentToUse);
						if (process.env.NODE_ENV !== 'production') {
							setAndValidateContentChildDev.call(this, contentToUse);
						}
					} else if (childrenToUse != null) {
						var mountImages = this.mountChildren(childrenToUse, transaction, context);
						ret = mountImages.join('');
					}
				}
				if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {

					return '\n' + ret;
				} else {
					return ret;
				}
			},

			_createInitialChildren: function _createInitialChildren(transaction, props, context, lazyTree) {

				var innerHTML = props.dangerouslySetInnerHTML;
				if (innerHTML != null) {
					if (innerHTML.__html != null) {
						DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
					}
				} else {
					var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
					var childrenToUse = contentToUse != null ? null : props.children;
					if (contentToUse != null) {

						if (process.env.NODE_ENV !== 'production') {
							setAndValidateContentChildDev.call(this, contentToUse);
						}
						DOMLazyTree.queueText(lazyTree, contentToUse);
					} else if (childrenToUse != null) {
						var mountImages = this.mountChildren(childrenToUse, transaction, context);
						for (var i = 0; i < mountImages.length; i++) {
							DOMLazyTree.queueChild(lazyTree, mountImages[i]);
						}
					}
				}
			},

			receiveComponent: function receiveComponent(nextElement, transaction, context) {
				var prevElement = this._currentElement;
				this._currentElement = nextElement;
				this.updateComponent(transaction, prevElement, nextElement, context);
			},

			updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
				var lastProps = prevElement.props;
				var nextProps = this._currentElement.props;

				switch (this._tag) {
					case 'button':
						lastProps = ReactDOMButton.getHostProps(this, lastProps);
						nextProps = ReactDOMButton.getHostProps(this, nextProps);
						break;
					case 'input':
						lastProps = ReactDOMInput.getHostProps(this, lastProps);
						nextProps = ReactDOMInput.getHostProps(this, nextProps);
						break;
					case 'option':
						lastProps = ReactDOMOption.getHostProps(this, lastProps);
						nextProps = ReactDOMOption.getHostProps(this, nextProps);
						break;
					case 'select':
						lastProps = ReactDOMSelect.getHostProps(this, lastProps);
						nextProps = ReactDOMSelect.getHostProps(this, nextProps);
						break;
					case 'textarea':
						lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
						nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
						break;}

				assertValidProps(this, nextProps);
				this._updateDOMProperties(lastProps, nextProps, transaction);
				this._updateDOMChildren(lastProps, nextProps, transaction, context);

				switch (this._tag) {
					case 'input':

						ReactDOMInput.updateWrapper(this);
						break;
					case 'textarea':
						ReactDOMTextarea.updateWrapper(this);
						break;
					case 'select':

						transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
						break;}
			},

			_updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction) {
				var propKey;
				var styleName;
				var styleUpdates;
				for (propKey in lastProps) {
					if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
						continue;
					}
					if (propKey === STYLE) {
						var lastStyle = this._previousStyleCopy;
						for (styleName in lastStyle) {
							if (lastStyle.hasOwnProperty(styleName)) {
								styleUpdates = styleUpdates || {};
								styleUpdates[styleName] = '';
							}
						}
						this._previousStyleCopy = null;
					} else if (registrationNameModules.hasOwnProperty(propKey)) {
						if (lastProps[propKey]) {

							deleteListener(this, propKey);
						}
					} else if (isCustomComponent(this._tag, lastProps)) {
						if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
							DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
						}
					} else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
						DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
					}
				}
				for (propKey in nextProps) {
					var nextProp = nextProps[propKey];
					var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
					if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
						continue;
					}
					if (propKey === STYLE) {
						if (nextProp) {
							if (process.env.NODE_ENV !== 'production') {
								checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
								this._previousStyle = nextProp;
							}
							nextProp = this._previousStyleCopy = _assign({}, nextProp);
						} else {
							this._previousStyleCopy = null;
						}
						if (lastProp) {

							for (styleName in lastProp) {
								if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
									styleUpdates = styleUpdates || {};
									styleUpdates[styleName] = '';
								}
							}

							for (styleName in nextProp) {
								if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
									styleUpdates = styleUpdates || {};
									styleUpdates[styleName] = nextProp[styleName];
								}
							}
						} else {

							styleUpdates = nextProp;
						}
					} else if (registrationNameModules.hasOwnProperty(propKey)) {
						if (nextProp) {
							enqueuePutListener(this, propKey, nextProp, transaction);
						} else if (lastProp) {
							deleteListener(this, propKey);
						}
					} else if (isCustomComponent(this._tag, nextProps)) {
						if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
							DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
						}
					} else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
						var node = getNode(this);

						if (nextProp != null) {
							DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
						} else {
							DOMPropertyOperations.deleteValueForProperty(node, propKey);
						}
					}
				}
				if (styleUpdates) {
					CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
				}
			},

			_updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
				var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
				var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

				var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
				var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

				var lastChildren = lastContent != null ? null : lastProps.children;
				var nextChildren = nextContent != null ? null : nextProps.children;

				var lastHasContentOrHtml = lastContent != null || lastHtml != null;
				var nextHasContentOrHtml = nextContent != null || nextHtml != null;
				if (lastChildren != null && nextChildren == null) {
					this.updateChildren(null, transaction, context);
				} else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
					this.updateTextContent('');
					if (process.env.NODE_ENV !== 'production') {
						ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
					}
				}

				if (nextContent != null) {
					if (lastContent !== nextContent) {
						this.updateTextContent('' + nextContent);
						if (process.env.NODE_ENV !== 'production') {
							setAndValidateContentChildDev.call(this, nextContent);
						}
					}
				} else if (nextHtml != null) {
					if (lastHtml !== nextHtml) {
						this.updateMarkup('' + nextHtml);
					}
					if (process.env.NODE_ENV !== 'production') {
						ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
					}
				} else if (nextChildren != null) {
					if (process.env.NODE_ENV !== 'production') {
						setAndValidateContentChildDev.call(this, null);
					}

					this.updateChildren(nextChildren, transaction, context);
				}
			},

			getHostNode: function getHostNode() {
				return getNode(this);
			},

			unmountComponent: function unmountComponent(safely) {
				switch (this._tag) {
					case 'audio':
					case 'form':
					case 'iframe':
					case 'img':
					case 'link':
					case 'object':
					case 'source':
					case 'video':
						var listeners = this._wrapperState.listeners;
						if (listeners) {
							for (var i = 0; i < listeners.length; i++) {
								listeners[i].remove();
							}
						}
						break;
					case 'html':
					case 'head':
					case 'body':

						!false ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
						break;}

				this.unmountChildren(safely);
				ReactDOMComponentTree.uncacheNode(this);
				EventPluginHub.deleteAllListeners(this);
				this._rootNodeID = 0;
				this._domID = 0;
				this._wrapperState = null;

				if (process.env.NODE_ENV !== 'production') {
					setAndValidateContentChildDev.call(this, null);
				}
			},

			getPublicInstance: function getPublicInstance() {
				return getNode(this);
			} };

		_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

		module.exports = ReactDOMComponent;
	}, // __react__/lib/AutoFocusUtils.js
	function (__inner_require__, exports, module) {
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);

		var focusNode = __inner_require__(303 /*__fbjs__/lib/focusNode.js*/);

		var AutoFocusUtils = {
			focusDOMComponent: function focusDOMComponent() {
				focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
			} };

		module.exports = AutoFocusUtils;
	}, // __fbjs__/lib/focusNode.js
	function (__inner_require__, exports, module) {
		function focusNode(node) {

			try {
				node.focus();
			} catch (e) {}
		}

		module.exports = focusNode;
	}, // __react__/lib/CSSPropertyOperations.js
	function (__inner_require__, exports, module) {
		var CSSProperty = __inner_require__(305 /*__react__/lib/CSSProperty.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');

		var camelizeStyleName = __inner_require__(306 /*__fbjs__/lib/camelizeStyleName.js*/);
		var dangerousStyleValue = __inner_require__(308 /*__react__/lib/dangerousStyleValue.js*/);
		var hyphenateStyleName = __inner_require__(309 /*__fbjs__/lib/hyphenateStyleName.js*/);
		var memoizeStringOnly = __inner_require__(311 /*__fbjs__/lib/memoizeStringOnly.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var processStyleName = memoizeStringOnly(function (styleName) {
			return hyphenateStyleName(styleName);
		});

		var hasShorthandPropertyBug = false;
		var styleFloatAccessor = 'cssFloat';
		if (ExecutionEnvironment.canUseDOM) {
			var tempStyle = document.createElement('div').style;
			try {

				tempStyle.font = '';
			} catch (e) {
				hasShorthandPropertyBug = true;
			}

			if (document.documentElement.style.cssFloat === undefined) {
				styleFloatAccessor = 'styleFloat';
			}
		}

		if (process.env.NODE_ENV !== 'production') {

			var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

			var badStyleValueWithSemicolonPattern = /;\s*$/;

			var warnedStyleNames = {};
			var warnedStyleValues = {};
			var warnedForNaNValue = false;

			var warnHyphenatedStyleName = function warnHyphenatedStyleName(name, owner) {
				if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
					return;
				}

				warnedStyleNames[name] = true;
				process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
			};

			var warnBadVendoredStyleName = function warnBadVendoredStyleName(name, owner) {
				if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
					return;
				}

				warnedStyleNames[name] = true;
				process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
			};

			var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value, owner) {
				if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
					return;
				}

				warnedStyleValues[value] = true;
				process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
			};

			var warnStyleValueIsNaN = function warnStyleValueIsNaN(name, value, owner) {
				if (warnedForNaNValue) {
					return;
				}

				warnedForNaNValue = true;
				process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
			};

			var checkRenderMessage = function checkRenderMessage(owner) {
				if (owner) {
					var name = owner.getName();
					if (name) {
						return ' Check the render method of `' + name + '`.';
					}
				}
				return '';
			};

			var warnValidStyle = function warnValidStyle(name, value, component) {
				var owner;
				if (component) {
					owner = component._currentElement._owner;
				}
				if (name.indexOf('-') > -1) {
					warnHyphenatedStyleName(name, owner);
				} else if (badVendoredStyleNamePattern.test(name)) {
					warnBadVendoredStyleName(name, owner);
				} else if (badStyleValueWithSemicolonPattern.test(value)) {
					warnStyleValueWithSemicolon(name, value, owner);
				}

				if (typeof value === 'number' && isNaN(value)) {
					warnStyleValueIsNaN(name, value, owner);
				}
			};
		}

		var CSSPropertyOperations = {

			createMarkupForStyles: function createMarkupForStyles(styles, component) {
				var serialized = '';
				for (var styleName in styles) {
					if (!styles.hasOwnProperty(styleName)) {
						continue;
					}
					var styleValue = styles[styleName];
					if (process.env.NODE_ENV !== 'production') {
						warnValidStyle(styleName, styleValue, component);
					}
					if (styleValue != null) {
						serialized += processStyleName(styleName) + ':';
						serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
					}
				}
				return serialized || null;
			},

			setValueForStyles: function setValueForStyles(node, styles, component) {
				if (process.env.NODE_ENV !== 'production') {
					ReactInstrumentation.debugTool.onHostOperation(component._debugID, 'update styles', styles);
				}

				var style = node.style;
				for (var styleName in styles) {
					if (!styles.hasOwnProperty(styleName)) {
						continue;
					}
					if (process.env.NODE_ENV !== 'production') {
						warnValidStyle(styleName, styles[styleName], component);
					}
					var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
					if (styleName === 'float' || styleName === 'cssFloat') {
						styleName = styleFloatAccessor;
					}
					if (styleValue) {
						style[styleName] = styleValue;
					} else {
						var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
						if (expansion) {

							for (var individualStyleName in expansion) {
								style[individualStyleName] = '';
							}
						} else {
							style[styleName] = '';
						}
					}
				}
			} };

		module.exports = CSSPropertyOperations;
	}, // __react__/lib/CSSProperty.js
	function (__inner_require__, exports, module) {
		var isUnitlessNumber = {
			animationIterationCount: true,
			borderImageOutset: true,
			borderImageSlice: true,
			borderImageWidth: true,
			boxFlex: true,
			boxFlexGroup: true,
			boxOrdinalGroup: true,
			columnCount: true,
			flex: true,
			flexGrow: true,
			flexPositive: true,
			flexShrink: true,
			flexNegative: true,
			flexOrder: true,
			gridRow: true,
			gridColumn: true,
			fontWeight: true,
			lineClamp: true,
			lineHeight: true,
			opacity: true,
			order: true,
			orphans: true,
			tabSize: true,
			widows: true,
			zIndex: true,
			zoom: true,

			fillOpacity: true,
			floodOpacity: true,
			stopOpacity: true,
			strokeDasharray: true,
			strokeDashoffset: true,
			strokeMiterlimit: true,
			strokeOpacity: true,
			strokeWidth: true };

		function prefixKey(prefix, key) {
			return prefix + key.charAt(0).toUpperCase() + key.substring(1);
		}

		var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

		Object.keys(isUnitlessNumber).forEach(function (prop) {
			prefixes.forEach(function (prefix) {
				isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
			});
		});

		var shorthandPropertyExpansions = {
			background: {
				backgroundAttachment: true,
				backgroundColor: true,
				backgroundImage: true,
				backgroundPositionX: true,
				backgroundPositionY: true,
				backgroundRepeat: true },

			backgroundPosition: {
				backgroundPositionX: true,
				backgroundPositionY: true },

			border: {
				borderWidth: true,
				borderStyle: true,
				borderColor: true },

			borderBottom: {
				borderBottomWidth: true,
				borderBottomStyle: true,
				borderBottomColor: true },

			borderLeft: {
				borderLeftWidth: true,
				borderLeftStyle: true,
				borderLeftColor: true },

			borderRight: {
				borderRightWidth: true,
				borderRightStyle: true,
				borderRightColor: true },

			borderTop: {
				borderTopWidth: true,
				borderTopStyle: true,
				borderTopColor: true },

			font: {
				fontStyle: true,
				fontVariant: true,
				fontWeight: true,
				fontSize: true,
				lineHeight: true,
				fontFamily: true },

			outline: {
				outlineWidth: true,
				outlineStyle: true,
				outlineColor: true } };

		var CSSProperty = {
			isUnitlessNumber: isUnitlessNumber,
			shorthandPropertyExpansions: shorthandPropertyExpansions };

		module.exports = CSSProperty;
	}, // __fbjs__/lib/camelizeStyleName.js
	function (__inner_require__, exports, module) {
		var camelize = __inner_require__(307 /*__fbjs__/lib/camelize.js*/);

		var msPattern = /^-ms-/;

		function camelizeStyleName(string) {
			return camelize(string.replace(msPattern, 'ms-'));
		}

		module.exports = camelizeStyleName;
	}, // __fbjs__/lib/camelize.js
	function (__inner_require__, exports, module) {
		var _hyphenPattern = /-(.)/g;

		function camelize(string) {
			return string.replace(_hyphenPattern, function (_, character) {
				return character.toUpperCase();
			});
		}

		module.exports = camelize;
	}, // __react__/lib/dangerousStyleValue.js
	function (__inner_require__, exports, module) {
		var CSSProperty = __inner_require__(305 /*__react__/lib/CSSProperty.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var isUnitlessNumber = CSSProperty.isUnitlessNumber;
		var styleWarnings = {};

		function dangerousStyleValue(name, value, component) {

			var isEmpty = value == null || typeof value === 'boolean' || value === '';
			if (isEmpty) {
				return '';
			}

			var isNonNumeric = isNaN(value);
			if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
				return '' + value;
			}

			if (typeof value === 'string') {
				if (process.env.NODE_ENV !== 'production') {

					if (component && value !== '0') {
						var owner = component._currentElement._owner;
						var ownerName = owner ? owner.getName() : null;
						if (ownerName && !styleWarnings[ownerName]) {
							styleWarnings[ownerName] = {};
						}
						var warned = false;
						if (ownerName) {
							var warnings = styleWarnings[ownerName];
							warned = warnings[name];
							if (!warned) {
								warnings[name] = true;
							}
						}
						if (!warned) {
							process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
						}
					}
				}
				value = value.trim();
			}
			return value + 'px';
		}

		module.exports = dangerousStyleValue;
	}, // __fbjs__/lib/hyphenateStyleName.js
	function (__inner_require__, exports, module) {
		var hyphenate = __inner_require__(310 /*__fbjs__/lib/hyphenate.js*/);

		var msPattern = /^ms-/;

		function hyphenateStyleName(string) {
			return hyphenate(string).replace(msPattern, '-ms-');
		}

		module.exports = hyphenateStyleName;
	}, // __fbjs__/lib/hyphenate.js
	function (__inner_require__, exports, module) {
		var _uppercasePattern = /([A-Z])/g;

		function hyphenate(string) {
			return string.replace(_uppercasePattern, '-$1').toLowerCase();
		}

		module.exports = hyphenate;
	}, // __fbjs__/lib/memoizeStringOnly.js
	function (__inner_require__, exports, module) {
		function memoizeStringOnly(callback) {
			var cache = {};
			return function (string) {
				if (!cache.hasOwnProperty(string)) {
					cache[string] = callback.call(this, string);
				}
				return cache[string];
			};
		}

		module.exports = memoizeStringOnly;
	}, // __react__/lib/DOMPropertyOperations.js
	function (__inner_require__, exports, module) {
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');

		var quoteAttributeValueForBrowser = __inner_require__(313 /*__react__/lib/quoteAttributeValueForBrowser.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
		var illegalAttributeNameCache = {};
		var validatedAttributeNameCache = {};

		function isAttributeNameSafe(attributeName) {
			if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
				return true;
			}
			if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
				return false;
			}
			if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
				validatedAttributeNameCache[attributeName] = true;
				return true;
			}
			illegalAttributeNameCache[attributeName] = true;
			process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
			return false;
		}

		function shouldIgnoreValue(propertyInfo, value) {
			return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
		}

		var DOMPropertyOperations = {

			createMarkupForID: function createMarkupForID(id) {
				return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
			},

			setAttributeForID: function setAttributeForID(node, id) {
				node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
			},

			createMarkupForRoot: function createMarkupForRoot() {
				return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
			},

			setAttributeForRoot: function setAttributeForRoot(node) {
				node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
			},

			createMarkupForProperty: function createMarkupForProperty(name, value) {
				var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
				if (propertyInfo) {
					if (shouldIgnoreValue(propertyInfo, value)) {
						return '';
					}
					var attributeName = propertyInfo.attributeName;
					if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
						return attributeName + '=""';
					}
					return attributeName + '=' + quoteAttributeValueForBrowser(value);
				} else if (DOMProperty.isCustomAttribute(name)) {
					if (value == null) {
						return '';
					}
					return name + '=' + quoteAttributeValueForBrowser(value);
				}
				return null;
			},

			createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
				if (!isAttributeNameSafe(name) || value == null) {
					return '';
				}
				return name + '=' + quoteAttributeValueForBrowser(value);
			},

			setValueForProperty: function setValueForProperty(node, name, value) {
				var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
				if (propertyInfo) {
					var mutationMethod = propertyInfo.mutationMethod;
					if (mutationMethod) {
						mutationMethod(node, value);
					} else if (shouldIgnoreValue(propertyInfo, value)) {
						this.deleteValueForProperty(node, name);
						return;
					} else if (propertyInfo.mustUseProperty) {

						node[propertyInfo.propertyName] = value;
					} else {
						var attributeName = propertyInfo.attributeName;
						var namespace = propertyInfo.attributeNamespace;

						if (namespace) {
							node.setAttributeNS(namespace, attributeName, '' + value);
						} else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
							node.setAttribute(attributeName, '');
						} else {
							node.setAttribute(attributeName, '' + value);
						}
					}
				} else if (DOMProperty.isCustomAttribute(name)) {
					DOMPropertyOperations.setValueForAttribute(node, name, value);
					return;
				}

				if (process.env.NODE_ENV !== 'production') {
					var payload = {};
					payload[name] = value;
					ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
				}
			},

			setValueForAttribute: function setValueForAttribute(node, name, value) {
				if (!isAttributeNameSafe(name)) {
					return;
				}
				if (value == null) {
					node.removeAttribute(name);
				} else {
					node.setAttribute(name, '' + value);
				}

				if (process.env.NODE_ENV !== 'production') {
					var payload = {};
					payload[name] = value;
					ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'update attribute', payload);
				}
			},

			deleteValueForAttribute: function deleteValueForAttribute(node, name) {
				node.removeAttribute(name);
				if (process.env.NODE_ENV !== 'production') {
					ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
				}
			},

			deleteValueForProperty: function deleteValueForProperty(node, name) {
				var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
				if (propertyInfo) {
					var mutationMethod = propertyInfo.mutationMethod;
					if (mutationMethod) {
						mutationMethod(node, undefined);
					} else if (propertyInfo.mustUseProperty) {
						var propName = propertyInfo.propertyName;
						if (propertyInfo.hasBooleanValue) {
							node[propName] = false;
						} else {
							node[propName] = '';
						}
					} else {
						node.removeAttribute(propertyInfo.attributeName);
					}
				} else if (DOMProperty.isCustomAttribute(name)) {
					node.removeAttribute(name);
				}

				if (process.env.NODE_ENV !== 'production') {
					ReactInstrumentation.debugTool.onHostOperation(ReactDOMComponentTree.getInstanceFromNode(node)._debugID, 'remove attribute', name);
				}
			} };

		module.exports = DOMPropertyOperations;
	}, // __react__/lib/quoteAttributeValueForBrowser.js
	function (__inner_require__, exports, module) {
		var escapeTextContentForBrowser = __inner_require__(295 /*__react__/lib/escapeTextContentForBrowser.js*/);

		function quoteAttributeValueForBrowser(value) {
			return '"' + escapeTextContentForBrowser(value) + '"';
		}

		module.exports = quoteAttributeValueForBrowser;
	}, // __react__/lib/ReactBrowserEventEmitter.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var ReactEventEmitterMixin = __inner_require__(62 /*__react__/lib/ReactEventEmitterMixin.js*/);
		var ViewportMetrics = __inner_require__(285 /*__react__/lib/ViewportMetrics.js*/);

		var getVendorPrefixedEventName = __inner_require__(315 /*__react__/lib/getVendorPrefixedEventName.js*/);
		var isEventSupported = __inner_require__(279 /*__react__/lib/isEventSupported.js*/);

		var hasEventPageXY;
		var alreadyListeningTo = {};
		var isMonitoringScrollValue = false;
		var reactTopListenersCounter = 0;

		var topEventMapping = {
			topAbort: 'abort',
			topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
			topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
			topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
			topBlur: 'blur',
			topCanPlay: 'canplay',
			topCanPlayThrough: 'canplaythrough',
			topChange: 'change',
			topClick: 'click',
			topCompositionEnd: 'compositionend',
			topCompositionStart: 'compositionstart',
			topCompositionUpdate: 'compositionupdate',
			topContextMenu: 'contextmenu',
			topCopy: 'copy',
			topCut: 'cut',
			topDoubleClick: 'dblclick',
			topDrag: 'drag',
			topDragEnd: 'dragend',
			topDragEnter: 'dragenter',
			topDragExit: 'dragexit',
			topDragLeave: 'dragleave',
			topDragOver: 'dragover',
			topDragStart: 'dragstart',
			topDrop: 'drop',
			topDurationChange: 'durationchange',
			topEmptied: 'emptied',
			topEncrypted: 'encrypted',
			topEnded: 'ended',
			topError: 'error',
			topFocus: 'focus',
			topInput: 'input',
			topKeyDown: 'keydown',
			topKeyPress: 'keypress',
			topKeyUp: 'keyup',
			topLoadedData: 'loadeddata',
			topLoadedMetadata: 'loadedmetadata',
			topLoadStart: 'loadstart',
			topMouseDown: 'mousedown',
			topMouseMove: 'mousemove',
			topMouseOut: 'mouseout',
			topMouseOver: 'mouseover',
			topMouseUp: 'mouseup',
			topPaste: 'paste',
			topPause: 'pause',
			topPlay: 'play',
			topPlaying: 'playing',
			topProgress: 'progress',
			topRateChange: 'ratechange',
			topScroll: 'scroll',
			topSeeked: 'seeked',
			topSeeking: 'seeking',
			topSelectionChange: 'selectionchange',
			topStalled: 'stalled',
			topSuspend: 'suspend',
			topTextInput: 'textInput',
			topTimeUpdate: 'timeupdate',
			topTouchCancel: 'touchcancel',
			topTouchEnd: 'touchend',
			topTouchMove: 'touchmove',
			topTouchStart: 'touchstart',
			topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
			topVolumeChange: 'volumechange',
			topWaiting: 'waiting',
			topWheel: 'wheel' };

		var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

		function getListeningForDocument(mountAt) {

			if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
				mountAt[topListenersIDKey] = reactTopListenersCounter++;
				alreadyListeningTo[mountAt[topListenersIDKey]] = {};
			}
			return alreadyListeningTo[mountAt[topListenersIDKey]];
		}

		var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

			ReactEventListener: null,

			injection: {

				injectReactEventListener: function injectReactEventListener(ReactEventListener) {
					ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
					ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
				} },

			setEnabled: function setEnabled(enabled) {
				if (ReactBrowserEventEmitter.ReactEventListener) {
					ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
				}
			},

			isEnabled: function isEnabled() {
				return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
			},

			listenTo: function listenTo(registrationName, contentDocumentHandle) {
				var mountAt = contentDocumentHandle;
				var isListening = getListeningForDocument(mountAt);
				var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

				var topLevelTypes = EventConstants.topLevelTypes;
				for (var i = 0; i < dependencies.length; i++) {
					var dependency = dependencies[i];
					if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
						if (dependency === topLevelTypes.topWheel) {
							if (isEventSupported('wheel')) {
								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
							} else if (isEventSupported('mousewheel')) {
								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
							} else {

								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
							}
						} else if (dependency === topLevelTypes.topScroll) {

							if (isEventSupported('scroll', true)) {
								ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
							} else {
								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
							}
						} else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {

							if (isEventSupported('focus', true)) {
								ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
								ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
							} else if (isEventSupported('focusin')) {

								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
								ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
							}

							isListening[topLevelTypes.topBlur] = true;
							isListening[topLevelTypes.topFocus] = true;
						} else if (topEventMapping.hasOwnProperty(dependency)) {
							ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
						}

						isListening[dependency] = true;
					}
				}
			},

			trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
				return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
			},

			trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
				return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
			},

			supportsEventPageXY: function supportsEventPageXY() {
				if (!document.createEvent) {
					return false;
				}
				var ev = document.createEvent('MouseEvent');
				return ev != null && 'pageX' in ev;
			},

			ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
				if (hasEventPageXY === undefined) {
					hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
				}
				if (!hasEventPageXY && !isMonitoringScrollValue) {
					var refresh = ViewportMetrics.refreshScrollValues;
					ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
					isMonitoringScrollValue = true;
				}
			} });

		module.exports = ReactBrowserEventEmitter;
	}, // __react__/lib/getVendorPrefixedEventName.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		function makePrefixMap(styleProp, eventName) {
			var prefixes = {};

			prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
			prefixes['Webkit' + styleProp] = 'webkit' + eventName;
			prefixes['Moz' + styleProp] = 'moz' + eventName;
			prefixes['ms' + styleProp] = 'MS' + eventName;
			prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

			return prefixes;
		}

		var vendorPrefixes = {
			animationend: makePrefixMap('Animation', 'AnimationEnd'),
			animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
			animationstart: makePrefixMap('Animation', 'AnimationStart'),
			transitionend: makePrefixMap('Transition', 'TransitionEnd') };

		var prefixedEventNames = {};

		var style = {};

		if (ExecutionEnvironment.canUseDOM) {
			style = document.createElement('div').style;

			if (!('AnimationEvent' in window)) {
				delete vendorPrefixes.animationend.animation;
				delete vendorPrefixes.animationiteration.animation;
				delete vendorPrefixes.animationstart.animation;
			}

			if (!('TransitionEvent' in window)) {
				delete vendorPrefixes.transitionend.transition;
			}
		}

		function getVendorPrefixedEventName(eventName) {
			if (prefixedEventNames[eventName]) {
				return prefixedEventNames[eventName];
			} else if (!vendorPrefixes[eventName]) {
				return eventName;
			}

			var prefixMap = vendorPrefixes[eventName];

			for (var styleProp in prefixMap) {
				if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
					return prefixedEventNames[eventName] = prefixMap[styleProp];
				}
			}

			return '';
		}

		module.exports = getVendorPrefixedEventName;
	}, // __react__/lib/ReactDOMButton.js
	function (__inner_require__, exports, module) {
		var DisabledInputUtils = __inner_require__(317 /*__react__/lib/DisabledInputUtils.js*/);

		var ReactDOMButton = {
			getHostProps: DisabledInputUtils.getHostProps };

		module.exports = ReactDOMButton;
	}, // __react__/lib/DisabledInputUtils.js
	function (__inner_require__, exports, module) {
		var disableableMouseListenerNames = {
			onClick: true,
			onDoubleClick: true,
			onMouseDown: true,
			onMouseMove: true,
			onMouseUp: true,

			onClickCapture: true,
			onDoubleClickCapture: true,
			onMouseDownCapture: true,
			onMouseMoveCapture: true,
			onMouseUpCapture: true };

		var DisabledInputUtils = {
			getHostProps: function getHostProps(inst, props) {
				if (!props.disabled) {
					return props;
				}

				var hostProps = {};
				for (var key in props) {
					if (!disableableMouseListenerNames[key] && props.hasOwnProperty(key)) {
						hostProps[key] = props[key];
					}
				}

				return hostProps;
			} };

		module.exports = DisabledInputUtils;
	}, // __react__/lib/ReactDOMInput.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var DisabledInputUtils = __inner_require__(317 /*__react__/lib/DisabledInputUtils.js*/);
		var DOMPropertyOperations = __inner_require__(312 /*__react__/lib/DOMPropertyOperations.js*/);
		var LinkedValueUtils = __inner_require__(319 /*__react__/lib/LinkedValueUtils.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var didWarnValueLink = false;
		var didWarnCheckedLink = false;
		var didWarnValueDefaultValue = false;
		var didWarnCheckedDefaultChecked = false;
		var didWarnControlledToUncontrolled = false;
		var didWarnUncontrolledToControlled = false;

		function forceUpdateIfMounted() {
			if (this._rootNodeID) {

				ReactDOMInput.updateWrapper(this);
			}
		}

		function isControlled(props) {
			var usesChecked = props.type === 'checkbox' || props.type === 'radio';
			return usesChecked ? props.checked != null : props.value != null;
		}

		var ReactDOMInput = {
			getHostProps: function getHostProps(inst, props) {
				var value = LinkedValueUtils.getValue(props);
				var checked = LinkedValueUtils.getChecked(props);

				var hostProps = _assign({

					type: undefined,

					step: undefined,

					min: undefined,
					max: undefined }, DisabledInputUtils.getHostProps(inst, props), {
					defaultChecked: undefined,
					defaultValue: undefined,
					value: value != null ? value : inst._wrapperState.initialValue,
					checked: checked != null ? checked : inst._wrapperState.initialChecked,
					onChange: inst._wrapperState.onChange });

				return hostProps;
			},

			mountWrapper: function mountWrapper(inst, props) {
				if (process.env.NODE_ENV !== 'production') {
					LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

					var owner = inst._currentElement._owner;

					if (props.valueLink !== undefined && !didWarnValueLink) {
						process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
						didWarnValueLink = true;
					}
					if (props.checkedLink !== undefined && !didWarnCheckedLink) {
						process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
						didWarnCheckedLink = true;
					}
					if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
						process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
						didWarnCheckedDefaultChecked = true;
					}
					if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
						process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
						didWarnValueDefaultValue = true;
					}
				}

				var defaultValue = props.defaultValue;
				inst._wrapperState = {
					initialChecked: props.checked != null ? props.checked : props.defaultChecked,
					initialValue: props.value != null ? props.value : defaultValue,
					listeners: null,
					onChange: _handleChange.bind(inst) };

				if (process.env.NODE_ENV !== 'production') {
					inst._wrapperState.controlled = isControlled(props);
				}
			},

			updateWrapper: function updateWrapper(inst) {
				var props = inst._currentElement.props;

				if (process.env.NODE_ENV !== 'production') {
					var controlled = isControlled(props);
					var owner = inst._currentElement._owner;

					if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
						process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
						didWarnUncontrolledToControlled = true;
					}
					if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
						process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
						didWarnControlledToUncontrolled = true;
					}
				}

				var checked = props.checked;
				if (checked != null) {
					DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
				}

				var node = ReactDOMComponentTree.getNodeFromInstance(inst);
				var value = LinkedValueUtils.getValue(props);
				if (value != null) {

					var newValue = '' + value;

					if (newValue !== node.value) {
						node.value = newValue;
					}
				} else {
					if (props.value == null && props.defaultValue != null) {
						node.defaultValue = '' + props.defaultValue;
					}
					if (props.checked == null && props.defaultChecked != null) {
						node.defaultChecked = !!props.defaultChecked;
					}
				}
			},

			postMountWrapper: function postMountWrapper(inst) {
				var props = inst._currentElement.props;

				var node = ReactDOMComponentTree.getNodeFromInstance(inst);

				switch (props.type) {
					case 'submit':
					case 'reset':
						break;
					case 'color':
					case 'date':
					case 'datetime':
					case 'datetime-local':
					case 'month':
					case 'time':
					case 'week':

						node.value = '';
						node.value = node.defaultValue;
						break;
					default:
						node.value = node.value;
						break;}

				var name = node.name;
				if (name !== '') {
					node.name = '';
				}
				node.defaultChecked = !node.defaultChecked;
				node.defaultChecked = !node.defaultChecked;
				if (name !== '') {
					node.name = name;
				}
			} };

		function _handleChange(event) {
			var props = this._currentElement.props;

			var returnValue = LinkedValueUtils.executeOnChange(props, event);

			ReactUpdates.asap(forceUpdateIfMounted, this);

			var name = props.name;
			if (props.type === 'radio' && name != null) {
				var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
				var queryRoot = rootNode;

				while (queryRoot.parentNode) {
					queryRoot = queryRoot.parentNode;
				}

				var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

				for (var i = 0; i < group.length; i++) {
					var otherNode = group[i];
					if (otherNode === rootNode || otherNode.form !== rootNode.form) {
						continue;
					}

					var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
					!otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;

					ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
				}
			}

			return returnValue;
		}

		module.exports = ReactDOMInput;
	}, // __react__/lib/LinkedValueUtils.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactPropTypes = __inner_require__(10 /*__react__/lib/ReactPropTypes.js*/);
		var ReactPropTypeLocations = require('react-native@0.33/__react__/lib/ReactPropTypeLocations.js');
		var ReactPropTypesSecret = require('react-native@0.33/__react__/lib/ReactPropTypesSecret.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var hasReadOnlyValue = {
			'button': true,
			'checkbox': true,
			'image': true,
			'hidden': true,
			'radio': true,
			'reset': true,
			'submit': true };

		function _assertSingleLink(inputProps) {
			!(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
		}
		function _assertValueLink(inputProps) {
			_assertSingleLink(inputProps);
			!(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
		}

		function _assertCheckedLink(inputProps) {
			_assertSingleLink(inputProps);
			!(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
		}

		var propTypes = {
			value: function value(props, propName, componentName) {
				if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
					return null;
				}
				return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
			},
			checked: function checked(props, propName, componentName) {
				if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
					return null;
				}
				return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
			},
			onChange: ReactPropTypes.func };

		var loggedTypeFailures = {};
		function getDeclarationErrorAddendum(owner) {
			if (owner) {
				var name = owner.getName();
				if (name) {
					return ' Check the render method of `' + name + '`.';
				}
			}
			return '';
		}

		var LinkedValueUtils = {
			checkPropTypes: function checkPropTypes(tagName, props, owner) {
				for (var propName in propTypes) {
					if (propTypes.hasOwnProperty(propName)) {
						var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop, null, ReactPropTypesSecret);
					}
					if (error instanceof Error && !(error.message in loggedTypeFailures)) {

						loggedTypeFailures[error.message] = true;

						var addendum = getDeclarationErrorAddendum(owner);
						process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
					}
				}
			},

			getValue: function getValue(inputProps) {
				if (inputProps.valueLink) {
					_assertValueLink(inputProps);
					return inputProps.valueLink.value;
				}
				return inputProps.value;
			},

			getChecked: function getChecked(inputProps) {
				if (inputProps.checkedLink) {
					_assertCheckedLink(inputProps);
					return inputProps.checkedLink.value;
				}
				return inputProps.checked;
			},

			executeOnChange: function executeOnChange(inputProps, event) {
				if (inputProps.valueLink) {
					_assertValueLink(inputProps);
					return inputProps.valueLink.requestChange(event.target.value);
				} else if (inputProps.checkedLink) {
					_assertCheckedLink(inputProps);
					return inputProps.checkedLink.requestChange(event.target.checked);
				} else if (inputProps.onChange) {
					return inputProps.onChange.call(undefined, event);
				}
			} };

		module.exports = LinkedValueUtils;
	}, // __react__/lib/ReactDOMOption.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var ReactChildren = __inner_require__(14 /*__react__/lib/ReactChildren.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactDOMSelect = __inner_require__(321 /*__react__/lib/ReactDOMSelect.js*/);

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');
		var didWarnInvalidOptionChildren = false;

		function flattenChildren(children) {
			var content = '';

			ReactChildren.forEach(children, function (child) {
				if (child == null) {
					return;
				}
				if (typeof child === 'string' || typeof child === 'number') {
					content += child;
				} else if (!didWarnInvalidOptionChildren) {
					didWarnInvalidOptionChildren = true;
					process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
				}
			});

			return content;
		}

		var ReactDOMOption = {
			mountWrapper: function mountWrapper(inst, props, hostParent) {

				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
				}

				var selectValue = null;
				if (hostParent != null) {
					var selectParent = hostParent;

					if (selectParent._tag === 'optgroup') {
						selectParent = selectParent._hostParent;
					}

					if (selectParent != null && selectParent._tag === 'select') {
						selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
					}
				}

				var selected = null;
				if (selectValue != null) {
					var value;
					if (props.value != null) {
						value = props.value + '';
					} else {
						value = flattenChildren(props.children);
					}
					selected = false;
					if (Array.isArray(selectValue)) {

						for (var i = 0; i < selectValue.length; i++) {
							if ('' + selectValue[i] === value) {
								selected = true;
								break;
							}
						}
					} else {
						selected = '' + selectValue === value;
					}
				}

				inst._wrapperState = { selected: selected };
			},

			postMountWrapper: function postMountWrapper(inst) {

				var props = inst._currentElement.props;
				if (props.value != null) {
					var node = ReactDOMComponentTree.getNodeFromInstance(inst);
					node.setAttribute('value', props.value);
				}
			},

			getHostProps: function getHostProps(inst, props) {
				var hostProps = _assign({ selected: undefined, children: undefined }, props);

				if (inst._wrapperState.selected != null) {
					hostProps.selected = inst._wrapperState.selected;
				}

				var content = flattenChildren(props.children);

				if (content) {
					hostProps.children = content;
				}

				return hostProps;
			} };

		module.exports = ReactDOMOption;
	}, // __react__/lib/ReactDOMSelect.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var DisabledInputUtils = __inner_require__(317 /*__react__/lib/DisabledInputUtils.js*/);
		var LinkedValueUtils = __inner_require__(319 /*__react__/lib/LinkedValueUtils.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var didWarnValueLink = false;
		var didWarnValueDefaultValue = false;

		function updateOptionsIfPendingUpdateAndMounted() {
			if (this._rootNodeID && this._wrapperState.pendingUpdate) {
				this._wrapperState.pendingUpdate = false;

				var props = this._currentElement.props;
				var value = LinkedValueUtils.getValue(props);

				if (value != null) {
					updateOptions(this, Boolean(props.multiple), value);
				}
			}
		}

		function getDeclarationErrorAddendum(owner) {
			if (owner) {
				var name = owner.getName();
				if (name) {
					return ' Check the render method of `' + name + '`.';
				}
			}
			return '';
		}

		var valuePropNames = ['value', 'defaultValue'];

		function checkSelectPropTypes(inst, props) {
			var owner = inst._currentElement._owner;
			LinkedValueUtils.checkPropTypes('select', props, owner);

			if (props.valueLink !== undefined && !didWarnValueLink) {
				process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
				didWarnValueLink = true;
			}

			for (var i = 0; i < valuePropNames.length; i++) {
				var propName = valuePropNames[i];
				if (props[propName] == null) {
					continue;
				}
				var isArray = Array.isArray(props[propName]);
				if (props.multiple && !isArray) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
				} else if (!props.multiple && isArray) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
				}
			}
		}

		function updateOptions(inst, multiple, propValue) {
			var selectedValue, i;
			var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

			if (multiple) {
				selectedValue = {};
				for (i = 0; i < propValue.length; i++) {
					selectedValue['' + propValue[i]] = true;
				}
				for (i = 0; i < options.length; i++) {
					var selected = selectedValue.hasOwnProperty(options[i].value);
					if (options[i].selected !== selected) {
						options[i].selected = selected;
					}
				}
			} else {

				selectedValue = '' + propValue;
				for (i = 0; i < options.length; i++) {
					if (options[i].value === selectedValue) {
						options[i].selected = true;
						return;
					}
				}
				if (options.length) {
					options[0].selected = true;
				}
			}
		}

		var ReactDOMSelect = {
			getHostProps: function getHostProps(inst, props) {
				return _assign({}, DisabledInputUtils.getHostProps(inst, props), {
					onChange: inst._wrapperState.onChange,
					value: undefined });
			},

			mountWrapper: function mountWrapper(inst, props) {
				if (process.env.NODE_ENV !== 'production') {
					checkSelectPropTypes(inst, props);
				}

				var value = LinkedValueUtils.getValue(props);
				inst._wrapperState = {
					pendingUpdate: false,
					initialValue: value != null ? value : props.defaultValue,
					listeners: null,
					onChange: _handleChange.bind(inst),
					wasMultiple: Boolean(props.multiple) };

				if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
					didWarnValueDefaultValue = true;
				}
			},

			getSelectValueContext: function getSelectValueContext(inst) {

				return inst._wrapperState.initialValue;
			},

			postUpdateWrapper: function postUpdateWrapper(inst) {
				var props = inst._currentElement.props;

				inst._wrapperState.initialValue = undefined;

				var wasMultiple = inst._wrapperState.wasMultiple;
				inst._wrapperState.wasMultiple = Boolean(props.multiple);

				var value = LinkedValueUtils.getValue(props);
				if (value != null) {
					inst._wrapperState.pendingUpdate = false;
					updateOptions(inst, Boolean(props.multiple), value);
				} else if (wasMultiple !== Boolean(props.multiple)) {

					if (props.defaultValue != null) {
						updateOptions(inst, Boolean(props.multiple), props.defaultValue);
					} else {

						updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
					}
				}
			} };

		function _handleChange(event) {
			var props = this._currentElement.props;
			var returnValue = LinkedValueUtils.executeOnChange(props, event);

			if (this._rootNodeID) {
				this._wrapperState.pendingUpdate = true;
			}
			ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
			return returnValue;
		}

		module.exports = ReactDOMSelect;
	}, // __react__/lib/ReactDOMTextarea.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var DisabledInputUtils = __inner_require__(317 /*__react__/lib/DisabledInputUtils.js*/);
		var LinkedValueUtils = __inner_require__(319 /*__react__/lib/LinkedValueUtils.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var didWarnValueLink = false;
		var didWarnValDefaultVal = false;

		function forceUpdateIfMounted() {
			if (this._rootNodeID) {

				ReactDOMTextarea.updateWrapper(this);
			}
		}

		var ReactDOMTextarea = {
			getHostProps: function getHostProps(inst, props) {
				!(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

				var hostProps = _assign({}, DisabledInputUtils.getHostProps(inst, props), {
					value: undefined,
					defaultValue: undefined,
					children: '' + inst._wrapperState.initialValue,
					onChange: inst._wrapperState.onChange });

				return hostProps;
			},

			mountWrapper: function mountWrapper(inst, props) {
				if (process.env.NODE_ENV !== 'production') {
					LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
					if (props.valueLink !== undefined && !didWarnValueLink) {
						process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
						didWarnValueLink = true;
					}
					if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
						process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
						didWarnValDefaultVal = true;
					}
				}

				var value = LinkedValueUtils.getValue(props);
				var initialValue = value;

				if (value == null) {
					var defaultValue = props.defaultValue;

					var children = props.children;
					if (children != null) {
						if (process.env.NODE_ENV !== 'production') {
							process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
						}
						!(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
						if (Array.isArray(children)) {
							!(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
							children = children[0];
						}

						defaultValue = '' + children;
					}
					if (defaultValue == null) {
						defaultValue = '';
					}
					initialValue = defaultValue;
				}

				inst._wrapperState = {
					initialValue: '' + initialValue,
					listeners: null,
					onChange: _handleChange.bind(inst) };
			},

			updateWrapper: function updateWrapper(inst) {
				var props = inst._currentElement.props;

				var node = ReactDOMComponentTree.getNodeFromInstance(inst);
				var value = LinkedValueUtils.getValue(props);
				if (value != null) {

					var newValue = '' + value;

					if (newValue !== node.value) {
						node.value = newValue;
					}
					if (props.defaultValue == null) {
						node.defaultValue = newValue;
					}
				}
				if (props.defaultValue != null) {
					node.defaultValue = props.defaultValue;
				}
			},

			postMountWrapper: function postMountWrapper(inst) {

				var node = ReactDOMComponentTree.getNodeFromInstance(inst);

				node.value = node.textContent;
			} };

		function _handleChange(event) {
			var props = this._currentElement.props;
			var returnValue = LinkedValueUtils.executeOnChange(props, event);
			ReactUpdates.asap(forceUpdateIfMounted, this);
			return returnValue;
		}

		module.exports = ReactDOMTextarea;
	}, // __react__/lib/ReactServerRenderingTransaction.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');
		var Transaction = require('react-native@0.33/__react__/lib/Transaction.js');
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var ReactServerUpdateQueue = __inner_require__(324 /*__react__/lib/ReactServerUpdateQueue.js*/);

		var TRANSACTION_WRAPPERS = [];

		if (process.env.NODE_ENV !== 'production') {
			TRANSACTION_WRAPPERS.push({
				initialize: ReactInstrumentation.debugTool.onBeginFlush,
				close: ReactInstrumentation.debugTool.onEndFlush });
		}

		var noopCallbackQueue = {
			enqueue: function enqueue() {} };

		function ReactServerRenderingTransaction(renderToStaticMarkup) {
			this.reinitializeTransaction();
			this.renderToStaticMarkup = renderToStaticMarkup;
			this.useCreateElement = false;
			this.updateQueue = new ReactServerUpdateQueue(this);
		}

		var Mixin = {

			getTransactionWrappers: function getTransactionWrappers() {
				return TRANSACTION_WRAPPERS;
			},

			getReactMountReady: function getReactMountReady() {
				return noopCallbackQueue;
			},

			getUpdateQueue: function getUpdateQueue() {
				return this.updateQueue;
			},

			destructor: function destructor() {},

			checkpoint: function checkpoint() {},

			rollback: function rollback() {} };

		_assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);

		PooledClass.addPoolingTo(ReactServerRenderingTransaction);

		module.exports = ReactServerRenderingTransaction;
	}, // __react__/lib/ReactServerUpdateQueue.js
	function (__inner_require__, exports, module) {
		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		var ReactUpdateQueue = require('react-native@0.33/__react__/lib/ReactUpdateQueue.js');
		var Transaction = require('react-native@0.33/__react__/lib/Transaction.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function warnNoop(publicInstance, callerName) {
			if (process.env.NODE_ENV !== 'production') {
				var constructor = publicInstance.constructor;
				process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
			}
		}

		var ReactServerUpdateQueue = function () {

			function ReactServerUpdateQueue(transaction) {
				_classCallCheck(this, ReactServerUpdateQueue);

				this.transaction = transaction;
			}

			ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
				return false;
			};

			ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
				if (this.transaction.isInTransaction()) {
					ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
				}
			};

			ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
				if (this.transaction.isInTransaction()) {
					ReactUpdateQueue.enqueueForceUpdate(publicInstance);
				} else {
					warnNoop(publicInstance, 'forceUpdate');
				}
			};

			ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
				if (this.transaction.isInTransaction()) {
					ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
				} else {
					warnNoop(publicInstance, 'replaceState');
				}
			};

			ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
				if (this.transaction.isInTransaction()) {
					ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
				} else {
					warnNoop(publicInstance, 'setState');
				}
			};

			return ReactServerUpdateQueue;
		}();

		module.exports = ReactServerUpdateQueue;
	}, // __react__/lib/validateDOMNesting.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var validateDOMNesting = emptyFunction;

		if (process.env.NODE_ENV !== 'production') {

			var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

			var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template', 'foreignObject', 'desc', 'title'];

			var buttonScopeTags = inScopeTags.concat(['button']);

			var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

			var emptyAncestorInfo = {
				current: null,

				formTag: null,
				aTagInScope: null,
				buttonTagInScope: null,
				nobrTagInScope: null,
				pTagInButtonScope: null,

				listItemTagAutoclosing: null,
				dlItemTagAutoclosing: null };

			var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
				var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
				var info = { tag: tag, instance: instance };

				if (inScopeTags.indexOf(tag) !== -1) {
					ancestorInfo.aTagInScope = null;
					ancestorInfo.buttonTagInScope = null;
					ancestorInfo.nobrTagInScope = null;
				}
				if (buttonScopeTags.indexOf(tag) !== -1) {
					ancestorInfo.pTagInButtonScope = null;
				}

				if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
					ancestorInfo.listItemTagAutoclosing = null;
					ancestorInfo.dlItemTagAutoclosing = null;
				}

				ancestorInfo.current = info;

				if (tag === 'form') {
					ancestorInfo.formTag = info;
				}
				if (tag === 'a') {
					ancestorInfo.aTagInScope = info;
				}
				if (tag === 'button') {
					ancestorInfo.buttonTagInScope = info;
				}
				if (tag === 'nobr') {
					ancestorInfo.nobrTagInScope = info;
				}
				if (tag === 'p') {
					ancestorInfo.pTagInButtonScope = info;
				}
				if (tag === 'li') {
					ancestorInfo.listItemTagAutoclosing = info;
				}
				if (tag === 'dd' || tag === 'dt') {
					ancestorInfo.dlItemTagAutoclosing = info;
				}

				return ancestorInfo;
			};

			var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {

				switch (parentTag) {

					case 'select':
						return tag === 'option' || tag === 'optgroup' || tag === '#text';
					case 'optgroup':
						return tag === 'option' || tag === '#text';

					case 'option':
						return tag === '#text';

					case 'tr':
						return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

					case 'tbody':
					case 'thead':
					case 'tfoot':
						return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

					case 'colgroup':
						return tag === 'col' || tag === 'template';

					case 'table':
						return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

					case 'head':
						return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

					case 'html':
						return tag === 'head' || tag === 'body';
					case '#document':
						return tag === 'html';}

				switch (tag) {
					case 'h1':
					case 'h2':
					case 'h3':
					case 'h4':
					case 'h5':
					case 'h6':
						return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

					case 'rp':
					case 'rt':
						return impliedEndTags.indexOf(parentTag) === -1;

					case 'body':
					case 'caption':
					case 'col':
					case 'colgroup':
					case 'frame':
					case 'head':
					case 'html':
					case 'tbody':
					case 'td':
					case 'tfoot':
					case 'th':
					case 'thead':
					case 'tr':

						return parentTag == null;}

				return true;
			};

			var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
				switch (tag) {
					case 'address':
					case 'article':
					case 'aside':
					case 'blockquote':
					case 'center':
					case 'details':
					case 'dialog':
					case 'dir':
					case 'div':
					case 'dl':
					case 'fieldset':
					case 'figcaption':
					case 'figure':
					case 'footer':
					case 'header':
					case 'hgroup':
					case 'main':
					case 'menu':
					case 'nav':
					case 'ol':
					case 'p':
					case 'section':
					case 'summary':
					case 'ul':

					case 'pre':
					case 'listing':

					case 'table':

					case 'hr':

					case 'xmp':

					case 'h1':
					case 'h2':
					case 'h3':
					case 'h4':
					case 'h5':
					case 'h6':
						return ancestorInfo.pTagInButtonScope;

					case 'form':
						return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

					case 'li':
						return ancestorInfo.listItemTagAutoclosing;

					case 'dd':
					case 'dt':
						return ancestorInfo.dlItemTagAutoclosing;

					case 'button':
						return ancestorInfo.buttonTagInScope;

					case 'a':

						return ancestorInfo.aTagInScope;

					case 'nobr':
						return ancestorInfo.nobrTagInScope;}

				return null;
			};

			var findOwnerStack = function findOwnerStack(instance) {
				if (!instance) {
					return [];
				}

				var stack = [];
				do {
					stack.push(instance);
				} while (instance = instance._currentElement._owner);
				stack.reverse();
				return stack;
			};

			var didWarn = {};

			validateDOMNesting = function validateDOMNesting(childTag, childText, childInstance, ancestorInfo) {
				ancestorInfo = ancestorInfo || emptyAncestorInfo;
				var parentInfo = ancestorInfo.current;
				var parentTag = parentInfo && parentInfo.tag;

				if (childText != null) {
					process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
					childTag = '#text';
				}

				var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
				var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
				var problematic = invalidParent || invalidAncestor;

				if (problematic) {
					var ancestorTag = problematic.tag;
					var ancestorInstance = problematic.instance;

					var childOwner = childInstance && childInstance._currentElement._owner;
					var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

					var childOwners = findOwnerStack(childOwner);
					var ancestorOwners = findOwnerStack(ancestorOwner);

					var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
					var i;

					var deepestCommon = -1;
					for (i = 0; i < minStackLen; i++) {
						if (childOwners[i] === ancestorOwners[i]) {
							deepestCommon = i;
						} else {
							break;
						}
					}

					var UNKNOWN = '(unknown)';
					var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
						return inst.getName() || UNKNOWN;
					});
					var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
						return inst.getName() || UNKNOWN;
					});
					var ownerInfo = [].concat(deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag, invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

					var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
					if (didWarn[warnKey]) {
						return;
					}
					didWarn[warnKey] = true;

					var tagDisplayName = childTag;
					var whitespaceInfo = '';
					if (childTag === '#text') {
						if (/\S/.test(childText)) {
							tagDisplayName = 'Text nodes';
						} else {
							tagDisplayName = 'Whitespace text nodes';
							whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
						}
					} else {
						tagDisplayName = '<' + childTag + '>';
					}

					if (invalidParent) {
						var info = '';
						if (ancestorTag === 'table' && childTag === 'tr') {
							info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
						}
						process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
					} else {
						process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
					}
				}
			};

			validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

			validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
				ancestorInfo = ancestorInfo || emptyAncestorInfo;
				var parentInfo = ancestorInfo.current;
				var parentTag = parentInfo && parentInfo.tag;
				return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
			};
		}

		module.exports = validateDOMNesting;
	}, // __react__/lib/ReactDOMEmptyComponent.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);

		var ReactDOMEmptyComponent = function ReactDOMEmptyComponent(instantiate) {

			this._currentElement = null;

			this._hostNode = null;
			this._hostParent = null;
			this._hostContainerInfo = null;
			this._domID = 0;
		};
		_assign(ReactDOMEmptyComponent.prototype, {
			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
				var domID = hostContainerInfo._idCounter++;
				this._domID = domID;
				this._hostParent = hostParent;
				this._hostContainerInfo = hostContainerInfo;

				var nodeValue = ' react-empty: ' + this._domID + ' ';
				if (transaction.useCreateElement) {
					var ownerDocument = hostContainerInfo._ownerDocument;
					var node = ownerDocument.createComment(nodeValue);
					ReactDOMComponentTree.precacheNode(this, node);
					return DOMLazyTree(node);
				} else {
					if (transaction.renderToStaticMarkup) {

						return '';
					}
					return '<!--' + nodeValue + '-->';
				}
			},
			receiveComponent: function receiveComponent() {},
			getHostNode: function getHostNode() {
				return ReactDOMComponentTree.getNodeFromInstance(this);
			},
			unmountComponent: function unmountComponent() {
				ReactDOMComponentTree.uncacheNode(this);
			} });

		module.exports = ReactDOMEmptyComponent;
	}, // __react__/lib/ReactDOMTreeTraversal.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');

		function getLowestCommonAncestor(instA, instB) {
			!('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
			!('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

			var depthA = 0;
			for (var tempA = instA; tempA; tempA = tempA._hostParent) {
				depthA++;
			}
			var depthB = 0;
			for (var tempB = instB; tempB; tempB = tempB._hostParent) {
				depthB++;
			}

			while (depthA - depthB > 0) {
				instA = instA._hostParent;
				depthA--;
			}

			while (depthB - depthA > 0) {
				instB = instB._hostParent;
				depthB--;
			}

			var depth = depthA;
			while (depth--) {
				if (instA === instB) {
					return instA;
				}
				instA = instA._hostParent;
				instB = instB._hostParent;
			}
			return null;
		}

		function isAncestor(instA, instB) {
			!('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
			!('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

			while (instB) {
				if (instB === instA) {
					return true;
				}
				instB = instB._hostParent;
			}
			return false;
		}

		function getParentInstance(inst) {
			!('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

			return inst._hostParent;
		}

		function traverseTwoPhase(inst, fn, arg) {
			var path = [];
			while (inst) {
				path.push(inst);
				inst = inst._hostParent;
			}
			var i;
			for (i = path.length; i-- > 0;) {
				fn(path[i], false, arg);
			}
			for (i = 0; i < path.length; i++) {
				fn(path[i], true, arg);
			}
		}

		function traverseEnterLeave(from, to, fn, argFrom, argTo) {
			var common = from && to ? getLowestCommonAncestor(from, to) : null;
			var pathFrom = [];
			while (from && from !== common) {
				pathFrom.push(from);
				from = from._hostParent;
			}
			var pathTo = [];
			while (to && to !== common) {
				pathTo.push(to);
				to = to._hostParent;
			}
			var i;
			for (i = 0; i < pathFrom.length; i++) {
				fn(pathFrom[i], true, argFrom);
			}
			for (i = pathTo.length; i-- > 0;) {
				fn(pathTo[i], false, argTo);
			}
		}

		module.exports = {
			isAncestor: isAncestor,
			getLowestCommonAncestor: getLowestCommonAncestor,
			getParentInstance: getParentInstance,
			traverseTwoPhase: traverseTwoPhase,
			traverseEnterLeave: traverseEnterLeave };
	}, // __react__/lib/ReactDOMTextComponent.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js'),
		    _assign = require('object-assign@4/index.js');

		var DOMChildrenOperations = __inner_require__(289 /*__react__/lib/DOMChildrenOperations.js*/);
		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);

		var escapeTextContentForBrowser = __inner_require__(295 /*__react__/lib/escapeTextContentForBrowser.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var validateDOMNesting = __inner_require__(325 /*__react__/lib/validateDOMNesting.js*/);

		var ReactDOMTextComponent = function ReactDOMTextComponent(text) {

			this._currentElement = text;
			this._stringText = '' + text;

			this._hostNode = null;
			this._hostParent = null;

			this._domID = 0;
			this._mountIndex = 0;
			this._closingComment = null;
			this._commentNodes = null;
		};

		_assign(ReactDOMTextComponent.prototype, {

			mountComponent: function mountComponent(transaction, hostParent, hostContainerInfo, context) {
				if (process.env.NODE_ENV !== 'production') {
					var parentInfo;
					if (hostParent != null) {
						parentInfo = hostParent._ancestorInfo;
					} else if (hostContainerInfo != null) {
						parentInfo = hostContainerInfo._ancestorInfo;
					}
					if (parentInfo) {

						validateDOMNesting(null, this._stringText, this, parentInfo);
					}
				}

				var domID = hostContainerInfo._idCounter++;
				var openingValue = ' react-text: ' + domID + ' ';
				var closingValue = ' /react-text ';
				this._domID = domID;
				this._hostParent = hostParent;
				if (transaction.useCreateElement) {
					var ownerDocument = hostContainerInfo._ownerDocument;
					var openingComment = ownerDocument.createComment(openingValue);
					var closingComment = ownerDocument.createComment(closingValue);
					var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
					DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
					if (this._stringText) {
						DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
					}
					DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
					ReactDOMComponentTree.precacheNode(this, openingComment);
					this._closingComment = closingComment;
					return lazyTree;
				} else {
					var escapedText = escapeTextContentForBrowser(this._stringText);

					if (transaction.renderToStaticMarkup) {

						return escapedText;
					}

					return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
				}
			},

			receiveComponent: function receiveComponent(nextText, transaction) {
				if (nextText !== this._currentElement) {
					this._currentElement = nextText;
					var nextStringText = '' + nextText;
					if (nextStringText !== this._stringText) {

						this._stringText = nextStringText;
						var commentNodes = this.getHostNode();
						DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
					}
				}
			},

			getHostNode: function getHostNode() {
				var hostNode = this._commentNodes;
				if (hostNode) {
					return hostNode;
				}
				if (!this._closingComment) {
					var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
					var node = openingComment.nextSibling;
					while (true) {
						!(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
						if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
							this._closingComment = node;
							break;
						}
						node = node.nextSibling;
					}
				}
				hostNode = [this._hostNode, this._closingComment];
				this._commentNodes = hostNode;
				return hostNode;
			},

			unmountComponent: function unmountComponent() {
				this._closingComment = null;
				this._commentNodes = null;
				ReactDOMComponentTree.uncacheNode(this);
			} });

		module.exports = ReactDOMTextComponent;
	}, // __react__/lib/ReactEventListener.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var EventListener = __inner_require__(330 /*__fbjs__/lib/EventListener.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var getEventTarget = __inner_require__(278 /*__react__/lib/getEventTarget.js*/);
		var getUnboundedScrollPosition = __inner_require__(331 /*__fbjs__/lib/getUnboundedScrollPosition.js*/);

		function findParent(inst) {

			while (inst._hostParent) {
				inst = inst._hostParent;
			}
			var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
			var container = rootNode.parentNode;
			return ReactDOMComponentTree.getClosestInstanceFromNode(container);
		}

		function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
			this.topLevelType = topLevelType;
			this.nativeEvent = nativeEvent;
			this.ancestors = [];
		}
		_assign(TopLevelCallbackBookKeeping.prototype, {
			destructor: function destructor() {
				this.topLevelType = null;
				this.nativeEvent = null;
				this.ancestors.length = 0;
			} });

		PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

		function handleTopLevelImpl(bookKeeping) {
			var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
			var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

			var ancestor = targetInst;
			do {
				bookKeeping.ancestors.push(ancestor);
				ancestor = ancestor && findParent(ancestor);
			} while (ancestor);

			for (var i = 0; i < bookKeeping.ancestors.length; i++) {
				targetInst = bookKeeping.ancestors[i];
				ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
			}
		}

		function scrollValueMonitor(cb) {
			var scrollPosition = getUnboundedScrollPosition(window);
			cb(scrollPosition);
		}

		var ReactEventListener = {
			_enabled: true,
			_handleTopLevel: null,

			WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

			setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
				ReactEventListener._handleTopLevel = handleTopLevel;
			},

			setEnabled: function setEnabled(enabled) {
				ReactEventListener._enabled = !!enabled;
			},

			isEnabled: function isEnabled() {
				return ReactEventListener._enabled;
			},

			trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
				var element = handle;
				if (!element) {
					return null;
				}
				return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
			},

			trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
				var element = handle;
				if (!element) {
					return null;
				}
				return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
			},

			monitorScrollValue: function monitorScrollValue(refresh) {
				var callback = scrollValueMonitor.bind(null, refresh);
				EventListener.listen(window, 'scroll', callback);
			},

			dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
				if (!ReactEventListener._enabled) {
					return;
				}

				var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
				try {

					ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
				} finally {
					TopLevelCallbackBookKeeping.release(bookKeeping);
				}
			} };

		module.exports = ReactEventListener;
	}, // __fbjs__/lib/EventListener.js
	function (__inner_require__, exports, module) {
		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');

		var EventListener = {

			listen: function listen(target, eventType, callback) {
				if (target.addEventListener) {
					target.addEventListener(eventType, callback, false);
					return {
						remove: function remove() {
							target.removeEventListener(eventType, callback, false);
						} };
				} else if (target.attachEvent) {
					target.attachEvent('on' + eventType, callback);
					return {
						remove: function remove() {
							target.detachEvent('on' + eventType, callback);
						} };
				}
			},

			capture: function capture(target, eventType, callback) {
				if (target.addEventListener) {
					target.addEventListener(eventType, callback, true);
					return {
						remove: function remove() {
							target.removeEventListener(eventType, callback, true);
						} };
				} else {
					if (process.env.NODE_ENV !== 'production') {
						console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
					}
					return {
						remove: emptyFunction };
				}
			},

			registerDefault: function registerDefault() {} };

		module.exports = EventListener;
	}, // __fbjs__/lib/getUnboundedScrollPosition.js
	function (__inner_require__, exports, module) {
		function getUnboundedScrollPosition(scrollable) {
			if (scrollable === window) {
				return {
					x: window.pageXOffset || document.documentElement.scrollLeft,
					y: window.pageYOffset || document.documentElement.scrollTop };
			}
			return {
				x: scrollable.scrollLeft,
				y: scrollable.scrollTop };
		}

		module.exports = getUnboundedScrollPosition;
	}, // __react__/lib/ReactInjection.js
	function (__inner_require__, exports, module) {
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var EventPluginHub = __inner_require__(57 /*__react__/lib/EventPluginHub.js*/);
		var EventPluginUtils = __inner_require__(59 /*__react__/lib/EventPluginUtils.js*/);
		var ReactComponentEnvironment = require('react-native@0.33/__react__/lib/ReactComponentEnvironment.js');
		var ReactClass = __inner_require__(20 /*__react__/lib/ReactClass.js*/);
		var ReactEmptyComponent = require('react-native@0.33/__react__/lib/ReactEmptyComponent.js');
		var ReactBrowserEventEmitter = __inner_require__(314 /*__react__/lib/ReactBrowserEventEmitter.js*/);
		var ReactHostComponent = require('react-native@0.33/__react__/lib/ReactHostComponent.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var ReactInjection = {
			Component: ReactComponentEnvironment.injection,
			Class: ReactClass.injection,
			DOMProperty: DOMProperty.injection,
			EmptyComponent: ReactEmptyComponent.injection,
			EventPluginHub: EventPluginHub.injection,
			EventPluginUtils: EventPluginUtils.injection,
			EventEmitter: ReactBrowserEventEmitter.injection,
			HostComponent: ReactHostComponent.injection,
			Updates: ReactUpdates.injection };

		module.exports = ReactInjection;
	}, // __react__/lib/ReactReconcileTransaction.js
	function (__inner_require__, exports, module) {
		var _assign = require('object-assign@4/index.js');

		var CallbackQueue = require('react-native@0.33/__react__/lib/CallbackQueue.js');
		var PooledClass = require('react-native@0.33/__react__/lib/PooledClass.js');
		var ReactBrowserEventEmitter = __inner_require__(314 /*__react__/lib/ReactBrowserEventEmitter.js*/);
		var ReactInputSelection = __inner_require__(334 /*__react__/lib/ReactInputSelection.js*/);
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var Transaction = require('react-native@0.33/__react__/lib/Transaction.js');
		var ReactUpdateQueue = require('react-native@0.33/__react__/lib/ReactUpdateQueue.js');

		var SELECTION_RESTORATION = {

			initialize: ReactInputSelection.getSelectionInformation,

			close: ReactInputSelection.restoreSelection };

		var EVENT_SUPPRESSION = {

			initialize: function initialize() {
				var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
				ReactBrowserEventEmitter.setEnabled(false);
				return currentlyEnabled;
			},

			close: function close(previouslyEnabled) {
				ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
			} };

		var ON_DOM_READY_QUEUEING = {

			initialize: function initialize() {
				this.reactMountReady.reset();
			},

			close: function close() {
				this.reactMountReady.notifyAll();
			} };

		var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

		if (process.env.NODE_ENV !== 'production') {
			TRANSACTION_WRAPPERS.push({
				initialize: ReactInstrumentation.debugTool.onBeginFlush,
				close: ReactInstrumentation.debugTool.onEndFlush });
		}

		function ReactReconcileTransaction(useCreateElement) {
			this.reinitializeTransaction();

			this.renderToStaticMarkup = false;
			this.reactMountReady = CallbackQueue.getPooled(null);
			this.useCreateElement = useCreateElement;
		}

		var Mixin = {

			getTransactionWrappers: function getTransactionWrappers() {
				return TRANSACTION_WRAPPERS;
			},

			getReactMountReady: function getReactMountReady() {
				return this.reactMountReady;
			},

			getUpdateQueue: function getUpdateQueue() {
				return ReactUpdateQueue;
			},

			checkpoint: function checkpoint() {

				return this.reactMountReady.checkpoint();
			},

			rollback: function rollback(checkpoint) {
				this.reactMountReady.rollback(checkpoint);
			},

			destructor: function destructor() {
				CallbackQueue.release(this.reactMountReady);
				this.reactMountReady = null;
			} };

		_assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);

		PooledClass.addPoolingTo(ReactReconcileTransaction);

		module.exports = ReactReconcileTransaction;
	}, // __react__/lib/ReactInputSelection.js
	function (__inner_require__, exports, module) {
		var ReactDOMSelection = __inner_require__(335 /*__react__/lib/ReactDOMSelection.js*/);

		var containsNode = __inner_require__(337 /*__fbjs__/lib/containsNode.js*/);
		var focusNode = __inner_require__(303 /*__fbjs__/lib/focusNode.js*/);
		var getActiveElement = __inner_require__(339 /*__fbjs__/lib/getActiveElement.js*/);

		function isInDocument(node) {
			return containsNode(document.documentElement, node);
		}

		var ReactInputSelection = {

			hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
				var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
				return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
			},

			getSelectionInformation: function getSelectionInformation() {
				var focusedElem = getActiveElement();
				return {
					focusedElem: focusedElem,
					selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null };
			},

			restoreSelection: function restoreSelection(priorSelectionInformation) {
				var curFocusedElem = getActiveElement();
				var priorFocusedElem = priorSelectionInformation.focusedElem;
				var priorSelectionRange = priorSelectionInformation.selectionRange;
				if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
					if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
						ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
					}
					focusNode(priorFocusedElem);
				}
			},

			getSelection: function getSelection(input) {
				var selection;

				if ('selectionStart' in input) {

					selection = {
						start: input.selectionStart,
						end: input.selectionEnd };
				} else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {

					var range = document.selection.createRange();

					if (range.parentElement() === input) {
						selection = {
							start: -range.moveStart('character', -input.value.length),
							end: -range.moveEnd('character', -input.value.length) };
					}
				} else {

					selection = ReactDOMSelection.getOffsets(input);
				}

				return selection || { start: 0, end: 0 };
			},

			setSelection: function setSelection(input, offsets) {
				var start = offsets.start;
				var end = offsets.end;
				if (end === undefined) {
					end = start;
				}

				if ('selectionStart' in input) {
					input.selectionStart = start;
					input.selectionEnd = Math.min(end, input.value.length);
				} else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
					var range = input.createTextRange();
					range.collapse(true);
					range.moveStart('character', start);
					range.moveEnd('character', end - start);
					range.select();
				} else {
					ReactDOMSelection.setOffsets(input, offsets);
				}
			} };

		module.exports = ReactInputSelection;
	}, // __react__/lib/ReactDOMSelection.js
	function (__inner_require__, exports, module) {
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');

		var getNodeForCharacterOffset = __inner_require__(336 /*__react__/lib/getNodeForCharacterOffset.js*/);
		var getTextContentAccessor = __inner_require__(271 /*__react__/lib/getTextContentAccessor.js*/);

		function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
			return anchorNode === focusNode && anchorOffset === focusOffset;
		}

		function getIEOffsets(node) {
			var selection = document.selection;
			var selectedRange = selection.createRange();
			var selectedLength = selectedRange.text.length;

			var fromStart = selectedRange.duplicate();
			fromStart.moveToElementText(node);
			fromStart.setEndPoint('EndToStart', selectedRange);

			var startOffset = fromStart.text.length;
			var endOffset = startOffset + selectedLength;

			return {
				start: startOffset,
				end: endOffset };
		}

		function getModernOffsets(node) {
			var selection = window.getSelection && window.getSelection();

			if (!selection || selection.rangeCount === 0) {
				return null;
			}

			var anchorNode = selection.anchorNode;
			var anchorOffset = selection.anchorOffset;
			var focusNode = selection.focusNode;
			var focusOffset = selection.focusOffset;

			var currentRange = selection.getRangeAt(0);

			try {

				currentRange.startContainer.nodeType;
				currentRange.endContainer.nodeType;
			} catch (e) {
				return null;
			}

			var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

			var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

			var tempRange = currentRange.cloneRange();
			tempRange.selectNodeContents(node);
			tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

			var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

			var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
			var end = start + rangeLength;

			var detectionRange = document.createRange();
			detectionRange.setStart(anchorNode, anchorOffset);
			detectionRange.setEnd(focusNode, focusOffset);
			var isBackward = detectionRange.collapsed;

			return {
				start: isBackward ? end : start,
				end: isBackward ? start : end };
		}

		function setIEOffsets(node, offsets) {
			var range = document.selection.createRange().duplicate();
			var start, end;

			if (offsets.end === undefined) {
				start = offsets.start;
				end = start;
			} else if (offsets.start > offsets.end) {
				start = offsets.end;
				end = offsets.start;
			} else {
				start = offsets.start;
				end = offsets.end;
			}

			range.moveToElementText(node);
			range.moveStart('character', start);
			range.setEndPoint('EndToStart', range);
			range.moveEnd('character', end - start);
			range.select();
		}

		function setModernOffsets(node, offsets) {
			if (!window.getSelection) {
				return;
			}

			var selection = window.getSelection();
			var length = node[getTextContentAccessor()].length;
			var start = Math.min(offsets.start, length);
			var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

			if (!selection.extend && start > end) {
				var temp = end;
				end = start;
				start = temp;
			}

			var startMarker = getNodeForCharacterOffset(node, start);
			var endMarker = getNodeForCharacterOffset(node, end);

			if (startMarker && endMarker) {
				var range = document.createRange();
				range.setStart(startMarker.node, startMarker.offset);
				selection.removeAllRanges();

				if (start > end) {
					selection.addRange(range);
					selection.extend(endMarker.node, endMarker.offset);
				} else {
					range.setEnd(endMarker.node, endMarker.offset);
					selection.addRange(range);
				}
			}
		}

		var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

		var ReactDOMSelection = {

			getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

			setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets };

		module.exports = ReactDOMSelection;
	}, // __react__/lib/getNodeForCharacterOffset.js
	function (__inner_require__, exports, module) {
		function getLeafNode(node) {
			while (node && node.firstChild) {
				node = node.firstChild;
			}
			return node;
		}

		function getSiblingNode(node) {
			while (node) {
				if (node.nextSibling) {
					return node.nextSibling;
				}
				node = node.parentNode;
			}
		}

		function getNodeForCharacterOffset(root, offset) {
			var node = getLeafNode(root);
			var nodeStart = 0;
			var nodeEnd = 0;

			while (node) {
				if (node.nodeType === 3) {
					nodeEnd = nodeStart + node.textContent.length;

					if (nodeStart <= offset && nodeEnd >= offset) {
						return {
							node: node,
							offset: offset - nodeStart };
					}

					nodeStart = nodeEnd;
				}

				node = getLeafNode(getSiblingNode(node));
			}
		}

		module.exports = getNodeForCharacterOffset;
	}, // __fbjs__/lib/containsNode.js
	function (__inner_require__, exports, module) {
		var isTextNode = __inner_require__(338 /*__fbjs__/lib/isTextNode.js*/);

		function containsNode(outerNode, innerNode) {
			if (!outerNode || !innerNode) {
				return false;
			} else if (outerNode === innerNode) {
				return true;
			} else if (isTextNode(outerNode)) {
				return false;
			} else if (isTextNode(innerNode)) {
				return containsNode(outerNode, innerNode.parentNode);
			} else if ('contains' in outerNode) {
				return outerNode.contains(innerNode);
			} else if (outerNode.compareDocumentPosition) {
				return !!(outerNode.compareDocumentPosition(innerNode) & 16);
			} else {
				return false;
			}
		}

		module.exports = containsNode;
	}, // __fbjs__/lib/isTextNode.js
	function (__inner_require__, exports, module) {
		var isNode = require('react-native@0.33/__fbjs__/lib/isNode.js');

		function isTextNode(object) {
			return isNode(object) && object.nodeType == 3;
		}

		module.exports = isTextNode;
	}, // __fbjs__/lib/getActiveElement.js
	function (__inner_require__, exports, module) {
		function getActiveElement() {
			if (typeof document === 'undefined') {
				return null;
			}
			try {
				return document.activeElement || document.body;
			} catch (e) {
				return document.body;
			}
		}

		module.exports = getActiveElement;
	}, // __react__/lib/SVGDOMPropertyConfig.js
	function (__inner_require__, exports, module) {
		var NS = {
			xlink: 'http://www.w3.org/1999/xlink',
			xml: 'http://www.w3.org/XML/1998/namespace' };

		var ATTRS = {
			accentHeight: 'accent-height',
			accumulate: 0,
			additive: 0,
			alignmentBaseline: 'alignment-baseline',
			allowReorder: 'allowReorder',
			alphabetic: 0,
			amplitude: 0,
			arabicForm: 'arabic-form',
			ascent: 0,
			attributeName: 'attributeName',
			attributeType: 'attributeType',
			autoReverse: 'autoReverse',
			azimuth: 0,
			baseFrequency: 'baseFrequency',
			baseProfile: 'baseProfile',
			baselineShift: 'baseline-shift',
			bbox: 0,
			begin: 0,
			bias: 0,
			by: 0,
			calcMode: 'calcMode',
			capHeight: 'cap-height',
			clip: 0,
			clipPath: 'clip-path',
			clipRule: 'clip-rule',
			clipPathUnits: 'clipPathUnits',
			colorInterpolation: 'color-interpolation',
			colorInterpolationFilters: 'color-interpolation-filters',
			colorProfile: 'color-profile',
			colorRendering: 'color-rendering',
			contentScriptType: 'contentScriptType',
			contentStyleType: 'contentStyleType',
			cursor: 0,
			cx: 0,
			cy: 0,
			d: 0,
			decelerate: 0,
			descent: 0,
			diffuseConstant: 'diffuseConstant',
			direction: 0,
			display: 0,
			divisor: 0,
			dominantBaseline: 'dominant-baseline',
			dur: 0,
			dx: 0,
			dy: 0,
			edgeMode: 'edgeMode',
			elevation: 0,
			enableBackground: 'enable-background',
			end: 0,
			exponent: 0,
			externalResourcesRequired: 'externalResourcesRequired',
			fill: 0,
			fillOpacity: 'fill-opacity',
			fillRule: 'fill-rule',
			filter: 0,
			filterRes: 'filterRes',
			filterUnits: 'filterUnits',
			floodColor: 'flood-color',
			floodOpacity: 'flood-opacity',
			focusable: 0,
			fontFamily: 'font-family',
			fontSize: 'font-size',
			fontSizeAdjust: 'font-size-adjust',
			fontStretch: 'font-stretch',
			fontStyle: 'font-style',
			fontVariant: 'font-variant',
			fontWeight: 'font-weight',
			format: 0,
			from: 0,
			fx: 0,
			fy: 0,
			g1: 0,
			g2: 0,
			glyphName: 'glyph-name',
			glyphOrientationHorizontal: 'glyph-orientation-horizontal',
			glyphOrientationVertical: 'glyph-orientation-vertical',
			glyphRef: 'glyphRef',
			gradientTransform: 'gradientTransform',
			gradientUnits: 'gradientUnits',
			hanging: 0,
			horizAdvX: 'horiz-adv-x',
			horizOriginX: 'horiz-origin-x',
			ideographic: 0,
			imageRendering: 'image-rendering',
			'in': 0,
			in2: 0,
			intercept: 0,
			k: 0,
			k1: 0,
			k2: 0,
			k3: 0,
			k4: 0,
			kernelMatrix: 'kernelMatrix',
			kernelUnitLength: 'kernelUnitLength',
			kerning: 0,
			keyPoints: 'keyPoints',
			keySplines: 'keySplines',
			keyTimes: 'keyTimes',
			lengthAdjust: 'lengthAdjust',
			letterSpacing: 'letter-spacing',
			lightingColor: 'lighting-color',
			limitingConeAngle: 'limitingConeAngle',
			local: 0,
			markerEnd: 'marker-end',
			markerMid: 'marker-mid',
			markerStart: 'marker-start',
			markerHeight: 'markerHeight',
			markerUnits: 'markerUnits',
			markerWidth: 'markerWidth',
			mask: 0,
			maskContentUnits: 'maskContentUnits',
			maskUnits: 'maskUnits',
			mathematical: 0,
			mode: 0,
			numOctaves: 'numOctaves',
			offset: 0,
			opacity: 0,
			operator: 0,
			order: 0,
			orient: 0,
			orientation: 0,
			origin: 0,
			overflow: 0,
			overlinePosition: 'overline-position',
			overlineThickness: 'overline-thickness',
			paintOrder: 'paint-order',
			panose1: 'panose-1',
			pathLength: 'pathLength',
			patternContentUnits: 'patternContentUnits',
			patternTransform: 'patternTransform',
			patternUnits: 'patternUnits',
			pointerEvents: 'pointer-events',
			points: 0,
			pointsAtX: 'pointsAtX',
			pointsAtY: 'pointsAtY',
			pointsAtZ: 'pointsAtZ',
			preserveAlpha: 'preserveAlpha',
			preserveAspectRatio: 'preserveAspectRatio',
			primitiveUnits: 'primitiveUnits',
			r: 0,
			radius: 0,
			refX: 'refX',
			refY: 'refY',
			renderingIntent: 'rendering-intent',
			repeatCount: 'repeatCount',
			repeatDur: 'repeatDur',
			requiredExtensions: 'requiredExtensions',
			requiredFeatures: 'requiredFeatures',
			restart: 0,
			result: 0,
			rotate: 0,
			rx: 0,
			ry: 0,
			scale: 0,
			seed: 0,
			shapeRendering: 'shape-rendering',
			slope: 0,
			spacing: 0,
			specularConstant: 'specularConstant',
			specularExponent: 'specularExponent',
			speed: 0,
			spreadMethod: 'spreadMethod',
			startOffset: 'startOffset',
			stdDeviation: 'stdDeviation',
			stemh: 0,
			stemv: 0,
			stitchTiles: 'stitchTiles',
			stopColor: 'stop-color',
			stopOpacity: 'stop-opacity',
			strikethroughPosition: 'strikethrough-position',
			strikethroughThickness: 'strikethrough-thickness',
			string: 0,
			stroke: 0,
			strokeDasharray: 'stroke-dasharray',
			strokeDashoffset: 'stroke-dashoffset',
			strokeLinecap: 'stroke-linecap',
			strokeLinejoin: 'stroke-linejoin',
			strokeMiterlimit: 'stroke-miterlimit',
			strokeOpacity: 'stroke-opacity',
			strokeWidth: 'stroke-width',
			surfaceScale: 'surfaceScale',
			systemLanguage: 'systemLanguage',
			tableValues: 'tableValues',
			targetX: 'targetX',
			targetY: 'targetY',
			textAnchor: 'text-anchor',
			textDecoration: 'text-decoration',
			textRendering: 'text-rendering',
			textLength: 'textLength',
			to: 0,
			transform: 0,
			u1: 0,
			u2: 0,
			underlinePosition: 'underline-position',
			underlineThickness: 'underline-thickness',
			unicode: 0,
			unicodeBidi: 'unicode-bidi',
			unicodeRange: 'unicode-range',
			unitsPerEm: 'units-per-em',
			vAlphabetic: 'v-alphabetic',
			vHanging: 'v-hanging',
			vIdeographic: 'v-ideographic',
			vMathematical: 'v-mathematical',
			values: 0,
			vectorEffect: 'vector-effect',
			version: 0,
			vertAdvY: 'vert-adv-y',
			vertOriginX: 'vert-origin-x',
			vertOriginY: 'vert-origin-y',
			viewBox: 'viewBox',
			viewTarget: 'viewTarget',
			visibility: 0,
			widths: 0,
			wordSpacing: 'word-spacing',
			writingMode: 'writing-mode',
			x: 0,
			xHeight: 'x-height',
			x1: 0,
			x2: 0,
			xChannelSelector: 'xChannelSelector',
			xlinkActuate: 'xlink:actuate',
			xlinkArcrole: 'xlink:arcrole',
			xlinkHref: 'xlink:href',
			xlinkRole: 'xlink:role',
			xlinkShow: 'xlink:show',
			xlinkTitle: 'xlink:title',
			xlinkType: 'xlink:type',
			xmlBase: 'xml:base',
			xmlns: 0,
			xmlnsXlink: 'xmlns:xlink',
			xmlLang: 'xml:lang',
			xmlSpace: 'xml:space',
			y: 0,
			y1: 0,
			y2: 0,
			yChannelSelector: 'yChannelSelector',
			z: 0,
			zoomAndPan: 'zoomAndPan' };

		var SVGDOMPropertyConfig = {
			Properties: {},
			DOMAttributeNamespaces: {
				xlinkActuate: NS.xlink,
				xlinkArcrole: NS.xlink,
				xlinkHref: NS.xlink,
				xlinkRole: NS.xlink,
				xlinkShow: NS.xlink,
				xlinkTitle: NS.xlink,
				xlinkType: NS.xlink,
				xmlBase: NS.xml,
				xmlLang: NS.xml,
				xmlSpace: NS.xml },

			DOMAttributeNames: {} };

		Object.keys(ATTRS).forEach(function (key) {
			SVGDOMPropertyConfig.Properties[key] = 0;
			if (ATTRS[key]) {
				SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
			}
		});

		module.exports = SVGDOMPropertyConfig;
	}, // __react__/lib/SelectEventPlugin.js
	function (__inner_require__, exports, module) {
		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactInputSelection = __inner_require__(334 /*__react__/lib/ReactInputSelection.js*/);
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var getActiveElement = __inner_require__(339 /*__fbjs__/lib/getActiveElement.js*/);
		var isTextInputElement = __inner_require__(280 /*__react__/lib/isTextInputElement.js*/);
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);
		var shallowEqual = require('react-native@0.33/__fbjs__/lib/shallowEqual.js');

		var topLevelTypes = EventConstants.topLevelTypes;

		var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

		var eventTypes = {
			select: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSelect: null }),
					captured: keyOf({ onSelectCapture: null }) },

				dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange] } };

		var activeElement = null;
		var activeElementInst = null;
		var lastSelection = null;
		var mouseDown = false;

		var hasListener = false;
		var ON_SELECT_KEY = keyOf({ onSelect: null });

		function getSelection(node) {
			if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
				return {
					start: node.selectionStart,
					end: node.selectionEnd };
			} else if (window.getSelection) {
				var selection = window.getSelection();
				return {
					anchorNode: selection.anchorNode,
					anchorOffset: selection.anchorOffset,
					focusNode: selection.focusNode,
					focusOffset: selection.focusOffset };
			} else if (document.selection) {
				var range = document.selection.createRange();
				return {
					parentElement: range.parentElement(),
					text: range.text,
					top: range.boundingTop,
					left: range.boundingLeft };
			}
		}

		function constructSelectEvent(nativeEvent, nativeEventTarget) {

			if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
				return null;
			}

			var currentSelection = getSelection(activeElement);
			if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
				lastSelection = currentSelection;

				var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

				syntheticEvent.type = 'select';
				syntheticEvent.target = activeElement;

				EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

				return syntheticEvent;
			}

			return null;
		}

		var SelectEventPlugin = {

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				if (!hasListener) {
					return null;
				}

				var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

				switch (topLevelType) {

					case topLevelTypes.topFocus:
						if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
							activeElement = targetNode;
							activeElementInst = targetInst;
							lastSelection = null;
						}
						break;
					case topLevelTypes.topBlur:
						activeElement = null;
						activeElementInst = null;
						lastSelection = null;
						break;

					case topLevelTypes.topMouseDown:
						mouseDown = true;
						break;
					case topLevelTypes.topContextMenu:
					case topLevelTypes.topMouseUp:
						mouseDown = false;
						return constructSelectEvent(nativeEvent, nativeEventTarget);

					case topLevelTypes.topSelectionChange:
						if (skipSelectionChangeEvent) {
							break;
						}

					case topLevelTypes.topKeyDown:
					case topLevelTypes.topKeyUp:
						return constructSelectEvent(nativeEvent, nativeEventTarget);}

				return null;
			},

			didPutListener: function didPutListener(inst, registrationName, listener) {
				if (registrationName === ON_SELECT_KEY) {
					hasListener = true;
				}
			} };

		module.exports = SelectEventPlugin;
	}, // __react__/lib/SimpleEventPlugin.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var EventConstants = __inner_require__(56 /*__react__/lib/EventConstants.js*/);
		var EventListener = __inner_require__(330 /*__fbjs__/lib/EventListener.js*/);
		var EventPropagators = __inner_require__(97 /*__react__/lib/EventPropagators.js*/);
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var SyntheticAnimationEvent = __inner_require__(343 /*__react__/lib/SyntheticAnimationEvent.js*/);
		var SyntheticClipboardEvent = __inner_require__(344 /*__react__/lib/SyntheticClipboardEvent.js*/);
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);
		var SyntheticFocusEvent = __inner_require__(345 /*__react__/lib/SyntheticFocusEvent.js*/);
		var SyntheticKeyboardEvent = __inner_require__(346 /*__react__/lib/SyntheticKeyboardEvent.js*/);
		var SyntheticMouseEvent = __inner_require__(283 /*__react__/lib/SyntheticMouseEvent.js*/);
		var SyntheticDragEvent = __inner_require__(349 /*__react__/lib/SyntheticDragEvent.js*/);
		var SyntheticTouchEvent = __inner_require__(350 /*__react__/lib/SyntheticTouchEvent.js*/);
		var SyntheticTransitionEvent = __inner_require__(351 /*__react__/lib/SyntheticTransitionEvent.js*/);
		var SyntheticUIEvent = __inner_require__(284 /*__react__/lib/SyntheticUIEvent.js*/);
		var SyntheticWheelEvent = __inner_require__(352 /*__react__/lib/SyntheticWheelEvent.js*/);

		var emptyFunction = require('react-native@0.33/__fbjs__/lib/emptyFunction.js');
		var getEventCharCode = __inner_require__(347 /*__react__/lib/getEventCharCode.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var keyOf = __inner_require__(21 /*__fbjs__/lib/keyOf.js*/);

		var topLevelTypes = EventConstants.topLevelTypes;

		var eventTypes = {
			abort: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onAbort: true }),
					captured: keyOf({ onAbortCapture: true }) } },

			animationEnd: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onAnimationEnd: true }),
					captured: keyOf({ onAnimationEndCapture: true }) } },

			animationIteration: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onAnimationIteration: true }),
					captured: keyOf({ onAnimationIterationCapture: true }) } },

			animationStart: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onAnimationStart: true }),
					captured: keyOf({ onAnimationStartCapture: true }) } },

			blur: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onBlur: true }),
					captured: keyOf({ onBlurCapture: true }) } },

			canPlay: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCanPlay: true }),
					captured: keyOf({ onCanPlayCapture: true }) } },

			canPlayThrough: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCanPlayThrough: true }),
					captured: keyOf({ onCanPlayThroughCapture: true }) } },

			click: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onClick: true }),
					captured: keyOf({ onClickCapture: true }) } },

			contextMenu: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onContextMenu: true }),
					captured: keyOf({ onContextMenuCapture: true }) } },

			copy: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCopy: true }),
					captured: keyOf({ onCopyCapture: true }) } },

			cut: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onCut: true }),
					captured: keyOf({ onCutCapture: true }) } },

			doubleClick: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDoubleClick: true }),
					captured: keyOf({ onDoubleClickCapture: true }) } },

			drag: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDrag: true }),
					captured: keyOf({ onDragCapture: true }) } },

			dragEnd: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragEnd: true }),
					captured: keyOf({ onDragEndCapture: true }) } },

			dragEnter: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragEnter: true }),
					captured: keyOf({ onDragEnterCapture: true }) } },

			dragExit: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragExit: true }),
					captured: keyOf({ onDragExitCapture: true }) } },

			dragLeave: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragLeave: true }),
					captured: keyOf({ onDragLeaveCapture: true }) } },

			dragOver: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragOver: true }),
					captured: keyOf({ onDragOverCapture: true }) } },

			dragStart: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDragStart: true }),
					captured: keyOf({ onDragStartCapture: true }) } },

			drop: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDrop: true }),
					captured: keyOf({ onDropCapture: true }) } },

			durationChange: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onDurationChange: true }),
					captured: keyOf({ onDurationChangeCapture: true }) } },

			emptied: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onEmptied: true }),
					captured: keyOf({ onEmptiedCapture: true }) } },

			encrypted: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onEncrypted: true }),
					captured: keyOf({ onEncryptedCapture: true }) } },

			ended: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onEnded: true }),
					captured: keyOf({ onEndedCapture: true }) } },

			error: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onError: true }),
					captured: keyOf({ onErrorCapture: true }) } },

			focus: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onFocus: true }),
					captured: keyOf({ onFocusCapture: true }) } },

			input: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onInput: true }),
					captured: keyOf({ onInputCapture: true }) } },

			invalid: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onInvalid: true }),
					captured: keyOf({ onInvalidCapture: true }) } },

			keyDown: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onKeyDown: true }),
					captured: keyOf({ onKeyDownCapture: true }) } },

			keyPress: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onKeyPress: true }),
					captured: keyOf({ onKeyPressCapture: true }) } },

			keyUp: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onKeyUp: true }),
					captured: keyOf({ onKeyUpCapture: true }) } },

			load: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onLoad: true }),
					captured: keyOf({ onLoadCapture: true }) } },

			loadedData: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onLoadedData: true }),
					captured: keyOf({ onLoadedDataCapture: true }) } },

			loadedMetadata: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onLoadedMetadata: true }),
					captured: keyOf({ onLoadedMetadataCapture: true }) } },

			loadStart: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onLoadStart: true }),
					captured: keyOf({ onLoadStartCapture: true }) } },

			mouseDown: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMouseDown: true }),
					captured: keyOf({ onMouseDownCapture: true }) } },

			mouseMove: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMouseMove: true }),
					captured: keyOf({ onMouseMoveCapture: true }) } },

			mouseOut: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMouseOut: true }),
					captured: keyOf({ onMouseOutCapture: true }) } },

			mouseOver: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMouseOver: true }),
					captured: keyOf({ onMouseOverCapture: true }) } },

			mouseUp: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onMouseUp: true }),
					captured: keyOf({ onMouseUpCapture: true }) } },

			paste: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onPaste: true }),
					captured: keyOf({ onPasteCapture: true }) } },

			pause: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onPause: true }),
					captured: keyOf({ onPauseCapture: true }) } },

			play: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onPlay: true }),
					captured: keyOf({ onPlayCapture: true }) } },

			playing: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onPlaying: true }),
					captured: keyOf({ onPlayingCapture: true }) } },

			progress: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onProgress: true }),
					captured: keyOf({ onProgressCapture: true }) } },

			rateChange: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onRateChange: true }),
					captured: keyOf({ onRateChangeCapture: true }) } },

			reset: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onReset: true }),
					captured: keyOf({ onResetCapture: true }) } },

			scroll: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onScroll: true }),
					captured: keyOf({ onScrollCapture: true }) } },

			seeked: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSeeked: true }),
					captured: keyOf({ onSeekedCapture: true }) } },

			seeking: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSeeking: true }),
					captured: keyOf({ onSeekingCapture: true }) } },

			stalled: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onStalled: true }),
					captured: keyOf({ onStalledCapture: true }) } },

			submit: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSubmit: true }),
					captured: keyOf({ onSubmitCapture: true }) } },

			suspend: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onSuspend: true }),
					captured: keyOf({ onSuspendCapture: true }) } },

			timeUpdate: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTimeUpdate: true }),
					captured: keyOf({ onTimeUpdateCapture: true }) } },

			touchCancel: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTouchCancel: true }),
					captured: keyOf({ onTouchCancelCapture: true }) } },

			touchEnd: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTouchEnd: true }),
					captured: keyOf({ onTouchEndCapture: true }) } },

			touchMove: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTouchMove: true }),
					captured: keyOf({ onTouchMoveCapture: true }) } },

			touchStart: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTouchStart: true }),
					captured: keyOf({ onTouchStartCapture: true }) } },

			transitionEnd: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onTransitionEnd: true }),
					captured: keyOf({ onTransitionEndCapture: true }) } },

			volumeChange: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onVolumeChange: true }),
					captured: keyOf({ onVolumeChangeCapture: true }) } },

			waiting: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onWaiting: true }),
					captured: keyOf({ onWaitingCapture: true }) } },

			wheel: {
				phasedRegistrationNames: {
					bubbled: keyOf({ onWheel: true }),
					captured: keyOf({ onWheelCapture: true }) } } };

		var topLevelEventsToDispatchConfig = {
			topAbort: eventTypes.abort,
			topAnimationEnd: eventTypes.animationEnd,
			topAnimationIteration: eventTypes.animationIteration,
			topAnimationStart: eventTypes.animationStart,
			topBlur: eventTypes.blur,
			topCanPlay: eventTypes.canPlay,
			topCanPlayThrough: eventTypes.canPlayThrough,
			topClick: eventTypes.click,
			topContextMenu: eventTypes.contextMenu,
			topCopy: eventTypes.copy,
			topCut: eventTypes.cut,
			topDoubleClick: eventTypes.doubleClick,
			topDrag: eventTypes.drag,
			topDragEnd: eventTypes.dragEnd,
			topDragEnter: eventTypes.dragEnter,
			topDragExit: eventTypes.dragExit,
			topDragLeave: eventTypes.dragLeave,
			topDragOver: eventTypes.dragOver,
			topDragStart: eventTypes.dragStart,
			topDrop: eventTypes.drop,
			topDurationChange: eventTypes.durationChange,
			topEmptied: eventTypes.emptied,
			topEncrypted: eventTypes.encrypted,
			topEnded: eventTypes.ended,
			topError: eventTypes.error,
			topFocus: eventTypes.focus,
			topInput: eventTypes.input,
			topInvalid: eventTypes.invalid,
			topKeyDown: eventTypes.keyDown,
			topKeyPress: eventTypes.keyPress,
			topKeyUp: eventTypes.keyUp,
			topLoad: eventTypes.load,
			topLoadedData: eventTypes.loadedData,
			topLoadedMetadata: eventTypes.loadedMetadata,
			topLoadStart: eventTypes.loadStart,
			topMouseDown: eventTypes.mouseDown,
			topMouseMove: eventTypes.mouseMove,
			topMouseOut: eventTypes.mouseOut,
			topMouseOver: eventTypes.mouseOver,
			topMouseUp: eventTypes.mouseUp,
			topPaste: eventTypes.paste,
			topPause: eventTypes.pause,
			topPlay: eventTypes.play,
			topPlaying: eventTypes.playing,
			topProgress: eventTypes.progress,
			topRateChange: eventTypes.rateChange,
			topReset: eventTypes.reset,
			topScroll: eventTypes.scroll,
			topSeeked: eventTypes.seeked,
			topSeeking: eventTypes.seeking,
			topStalled: eventTypes.stalled,
			topSubmit: eventTypes.submit,
			topSuspend: eventTypes.suspend,
			topTimeUpdate: eventTypes.timeUpdate,
			topTouchCancel: eventTypes.touchCancel,
			topTouchEnd: eventTypes.touchEnd,
			topTouchMove: eventTypes.touchMove,
			topTouchStart: eventTypes.touchStart,
			topTransitionEnd: eventTypes.transitionEnd,
			topVolumeChange: eventTypes.volumeChange,
			topWaiting: eventTypes.waiting,
			topWheel: eventTypes.wheel };

		for (var type in topLevelEventsToDispatchConfig) {
			topLevelEventsToDispatchConfig[type].dependencies = [type];
		}

		var ON_CLICK_KEY = keyOf({ onClick: null });
		var onClickListeners = {};

		function getDictionaryKey(inst) {

			return '.' + inst._rootNodeID;
		}

		var SimpleEventPlugin = {

			eventTypes: eventTypes,

			extractEvents: function extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
				var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
				if (!dispatchConfig) {
					return null;
				}
				var EventConstructor;
				switch (topLevelType) {
					case topLevelTypes.topAbort:
					case topLevelTypes.topCanPlay:
					case topLevelTypes.topCanPlayThrough:
					case topLevelTypes.topDurationChange:
					case topLevelTypes.topEmptied:
					case topLevelTypes.topEncrypted:
					case topLevelTypes.topEnded:
					case topLevelTypes.topError:
					case topLevelTypes.topInput:
					case topLevelTypes.topInvalid:
					case topLevelTypes.topLoad:
					case topLevelTypes.topLoadedData:
					case topLevelTypes.topLoadedMetadata:
					case topLevelTypes.topLoadStart:
					case topLevelTypes.topPause:
					case topLevelTypes.topPlay:
					case topLevelTypes.topPlaying:
					case topLevelTypes.topProgress:
					case topLevelTypes.topRateChange:
					case topLevelTypes.topReset:
					case topLevelTypes.topSeeked:
					case topLevelTypes.topSeeking:
					case topLevelTypes.topStalled:
					case topLevelTypes.topSubmit:
					case topLevelTypes.topSuspend:
					case topLevelTypes.topTimeUpdate:
					case topLevelTypes.topVolumeChange:
					case topLevelTypes.topWaiting:

						EventConstructor = SyntheticEvent;
						break;
					case topLevelTypes.topKeyPress:

						if (getEventCharCode(nativeEvent) === 0) {
							return null;
						}

					case topLevelTypes.topKeyDown:
					case topLevelTypes.topKeyUp:
						EventConstructor = SyntheticKeyboardEvent;
						break;
					case topLevelTypes.topBlur:
					case topLevelTypes.topFocus:
						EventConstructor = SyntheticFocusEvent;
						break;
					case topLevelTypes.topClick:

						if (nativeEvent.button === 2) {
							return null;
						}

					case topLevelTypes.topContextMenu:
					case topLevelTypes.topDoubleClick:
					case topLevelTypes.topMouseDown:
					case topLevelTypes.topMouseMove:
					case topLevelTypes.topMouseOut:
					case topLevelTypes.topMouseOver:
					case topLevelTypes.topMouseUp:
						EventConstructor = SyntheticMouseEvent;
						break;
					case topLevelTypes.topDrag:
					case topLevelTypes.topDragEnd:
					case topLevelTypes.topDragEnter:
					case topLevelTypes.topDragExit:
					case topLevelTypes.topDragLeave:
					case topLevelTypes.topDragOver:
					case topLevelTypes.topDragStart:
					case topLevelTypes.topDrop:
						EventConstructor = SyntheticDragEvent;
						break;
					case topLevelTypes.topTouchCancel:
					case topLevelTypes.topTouchEnd:
					case topLevelTypes.topTouchMove:
					case topLevelTypes.topTouchStart:
						EventConstructor = SyntheticTouchEvent;
						break;
					case topLevelTypes.topAnimationEnd:
					case topLevelTypes.topAnimationIteration:
					case topLevelTypes.topAnimationStart:
						EventConstructor = SyntheticAnimationEvent;
						break;
					case topLevelTypes.topTransitionEnd:
						EventConstructor = SyntheticTransitionEvent;
						break;
					case topLevelTypes.topScroll:
						EventConstructor = SyntheticUIEvent;
						break;
					case topLevelTypes.topWheel:
						EventConstructor = SyntheticWheelEvent;
						break;
					case topLevelTypes.topCopy:
					case topLevelTypes.topCut:
					case topLevelTypes.topPaste:
						EventConstructor = SyntheticClipboardEvent;
						break;}

				!EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
				var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
				EventPropagators.accumulateTwoPhaseDispatches(event);
				return event;
			},

			didPutListener: function didPutListener(inst, registrationName, listener) {

				if (registrationName === ON_CLICK_KEY) {
					var key = getDictionaryKey(inst);
					var node = ReactDOMComponentTree.getNodeFromInstance(inst);
					if (!onClickListeners[key]) {
						onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
					}
				}
			},

			willDeleteListener: function willDeleteListener(inst, registrationName) {
				if (registrationName === ON_CLICK_KEY) {
					var key = getDictionaryKey(inst);
					onClickListeners[key].remove();
					delete onClickListeners[key];
				}
			} };

		module.exports = SimpleEventPlugin;
	}, // __react__/lib/SyntheticAnimationEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var AnimationEventInterface = {
			animationName: null,
			elapsedTime: null,
			pseudoElement: null };

		function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

		module.exports = SyntheticAnimationEvent;
	}, // __react__/lib/SyntheticClipboardEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var ClipboardEventInterface = {
			clipboardData: function clipboardData(event) {
				return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
			} };

		function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

		module.exports = SyntheticClipboardEvent;
	}, // __react__/lib/SyntheticFocusEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticUIEvent = __inner_require__(284 /*__react__/lib/SyntheticUIEvent.js*/);

		var FocusEventInterface = {
			relatedTarget: null };

		function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

		module.exports = SyntheticFocusEvent;
	}, // __react__/lib/SyntheticKeyboardEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticUIEvent = __inner_require__(284 /*__react__/lib/SyntheticUIEvent.js*/);

		var getEventCharCode = __inner_require__(347 /*__react__/lib/getEventCharCode.js*/);
		var getEventKey = __inner_require__(348 /*__react__/lib/getEventKey.js*/);
		var getEventModifierState = __inner_require__(286 /*__react__/lib/getEventModifierState.js*/);

		var KeyboardEventInterface = {
			key: getEventKey,
			location: null,
			ctrlKey: null,
			shiftKey: null,
			altKey: null,
			metaKey: null,
			repeat: null,
			locale: null,
			getModifierState: getEventModifierState,

			charCode: function charCode(event) {

				if (event.type === 'keypress') {
					return getEventCharCode(event);
				}
				return 0;
			},
			keyCode: function keyCode(event) {

				if (event.type === 'keydown' || event.type === 'keyup') {
					return event.keyCode;
				}
				return 0;
			},
			which: function which(event) {

				if (event.type === 'keypress') {
					return getEventCharCode(event);
				}
				if (event.type === 'keydown' || event.type === 'keyup') {
					return event.keyCode;
				}
				return 0;
			} };

		function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

		module.exports = SyntheticKeyboardEvent;
	}, // __react__/lib/getEventCharCode.js
	function (__inner_require__, exports, module) {
		function getEventCharCode(nativeEvent) {
			var charCode;
			var keyCode = nativeEvent.keyCode;

			if ('charCode' in nativeEvent) {
				charCode = nativeEvent.charCode;

				if (charCode === 0 && keyCode === 13) {
					charCode = 13;
				}
			} else {

				charCode = keyCode;
			}

			if (charCode >= 32 || charCode === 13) {
				return charCode;
			}

			return 0;
		}

		module.exports = getEventCharCode;
	}, // __react__/lib/getEventKey.js
	function (__inner_require__, exports, module) {
		var getEventCharCode = __inner_require__(347 /*__react__/lib/getEventCharCode.js*/);

		var normalizeKey = {
			'Esc': 'Escape',
			'Spacebar': ' ',
			'Left': 'ArrowLeft',
			'Up': 'ArrowUp',
			'Right': 'ArrowRight',
			'Down': 'ArrowDown',
			'Del': 'Delete',
			'Win': 'OS',
			'Menu': 'ContextMenu',
			'Apps': 'ContextMenu',
			'Scroll': 'ScrollLock',
			'MozPrintableKey': 'Unidentified' };

		var translateToKey = {
			8: 'Backspace',
			9: 'Tab',
			12: 'Clear',
			13: 'Enter',
			16: 'Shift',
			17: 'Control',
			18: 'Alt',
			19: 'Pause',
			20: 'CapsLock',
			27: 'Escape',
			32: ' ',
			33: 'PageUp',
			34: 'PageDown',
			35: 'End',
			36: 'Home',
			37: 'ArrowLeft',
			38: 'ArrowUp',
			39: 'ArrowRight',
			40: 'ArrowDown',
			45: 'Insert',
			46: 'Delete',
			112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
			118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
			144: 'NumLock',
			145: 'ScrollLock',
			224: 'Meta' };

		function getEventKey(nativeEvent) {
			if (nativeEvent.key) {

				var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
				if (key !== 'Unidentified') {
					return key;
				}
			}

			if (nativeEvent.type === 'keypress') {
				var charCode = getEventCharCode(nativeEvent);

				return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
			}
			if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {

				return translateToKey[nativeEvent.keyCode] || 'Unidentified';
			}
			return '';
		}

		module.exports = getEventKey;
	}, // __react__/lib/SyntheticDragEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticMouseEvent = __inner_require__(283 /*__react__/lib/SyntheticMouseEvent.js*/);

		var DragEventInterface = {
			dataTransfer: null };

		function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

		module.exports = SyntheticDragEvent;
	}, // __react__/lib/SyntheticTouchEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticUIEvent = __inner_require__(284 /*__react__/lib/SyntheticUIEvent.js*/);

		var getEventModifierState = __inner_require__(286 /*__react__/lib/getEventModifierState.js*/);

		var TouchEventInterface = {
			touches: null,
			targetTouches: null,
			changedTouches: null,
			altKey: null,
			metaKey: null,
			ctrlKey: null,
			shiftKey: null,
			getModifierState: getEventModifierState };

		function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

		module.exports = SyntheticTouchEvent;
	}, // __react__/lib/SyntheticTransitionEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticEvent = __inner_require__(98 /*__react__/lib/SyntheticEvent.js*/);

		var TransitionEventInterface = {
			propertyName: null,
			elapsedTime: null,
			pseudoElement: null };

		function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

		module.exports = SyntheticTransitionEvent;
	}, // __react__/lib/SyntheticWheelEvent.js
	function (__inner_require__, exports, module) {
		var SyntheticMouseEvent = __inner_require__(283 /*__react__/lib/SyntheticMouseEvent.js*/);

		var WheelEventInterface = {
			deltaX: function deltaX(event) {
				return 'deltaX' in event ? event.deltaX : 'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
			},
			deltaY: function deltaY(event) {
				return 'deltaY' in event ? event.deltaY : 'wheelDeltaY' in event ? -event.wheelDeltaY : 'wheelDelta' in event ? -event.wheelDelta : 0;
			},
			deltaZ: null,

			deltaMode: null };

		function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
			return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
		}

		SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

		module.exports = SyntheticWheelEvent;
	}, // __react__/lib/ReactDOM.js
	function (__inner_require__, exports, module) {
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactDefaultInjection = __inner_require__(268 /*__react__/lib/ReactDefaultInjection.js*/);
		var ReactMount = __inner_require__(354 /*__react__/lib/ReactMount.js*/);
		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');
		var ReactVersion = __inner_require__(24 /*__react__/lib/ReactVersion.js*/);

		var findDOMNode = __inner_require__(359 /*__react__/lib/findDOMNode.js*/);
		var getHostComponentFromComposite = __inner_require__(360 /*__react__/lib/getHostComponentFromComposite.js*/);
		var renderSubtreeIntoContainer = __inner_require__(361 /*__react__/lib/renderSubtreeIntoContainer.js*/);
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		ReactDefaultInjection.inject();

		var ReactDOM = {
			findDOMNode: findDOMNode,
			render: ReactMount.render,
			unmountComponentAtNode: ReactMount.unmountComponentAtNode,
			version: ReactVersion,

			unstable_batchedUpdates: ReactUpdates.batchedUpdates,
			unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer };

		if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
			__REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
				ComponentTree: {
					getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
					getNodeFromInstance: function getNodeFromInstance(inst) {

						if (inst._renderedComponent) {
							inst = getHostComponentFromComposite(inst);
						}
						if (inst) {
							return ReactDOMComponentTree.getNodeFromInstance(inst);
						} else {
							return null;
						}
					} },

				Mount: ReactMount,
				Reconciler: ReactReconciler });
		}

		if (process.env.NODE_ENV !== 'production') {
			var ExecutionEnvironment = require('react-native@0.33/__fbjs__/lib/ExecutionEnvironment.js');
			if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

				if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {

					if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {

						var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
						console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
					}
				}

				var testFunc = function testFn() {};
				process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

				var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

				process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

				var expectedFeatures = [Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim];

				for (var i = 0; i < expectedFeatures.length; i++) {
					if (!expectedFeatures[i]) {
						process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
						break;
					}
				}
			}
		}

		if (process.env.NODE_ENV !== 'production') {
			var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
			var ReactDOMUnknownPropertyHook = __inner_require__(362 /*__react__/lib/ReactDOMUnknownPropertyHook.js*/);
			var ReactDOMNullInputValuePropHook = __inner_require__(363 /*__react__/lib/ReactDOMNullInputValuePropHook.js*/);

			ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
			ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
		}

		module.exports = ReactDOM;
	}, // __react__/lib/ReactMount.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var DOMLazyTree = __inner_require__(290 /*__react__/lib/DOMLazyTree.js*/);
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var ReactBrowserEventEmitter = __inner_require__(314 /*__react__/lib/ReactBrowserEventEmitter.js*/);
		var ReactCurrentOwner = require('react-native@0.33/__react__/lib/ReactCurrentOwner.js');
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactDOMContainerInfo = __inner_require__(355 /*__react__/lib/ReactDOMContainerInfo.js*/);
		var ReactDOMFeatureFlags = __inner_require__(356 /*__react__/lib/ReactDOMFeatureFlags.js*/);
		var ReactElement = require('react-native@0.33/__react__/lib/ReactElement.js');
		var ReactFeatureFlags = require('react-native@0.33/__react__/lib/ReactFeatureFlags.js');
		var ReactInstanceMap = require('react-native@0.33/__react__/lib/ReactInstanceMap.js');
		var ReactInstrumentation = require('react-native@0.33/__react__/lib/ReactInstrumentation.js');
		var ReactMarkupChecksum = __inner_require__(357 /*__react__/lib/ReactMarkupChecksum.js*/);
		var ReactReconciler = require('react-native@0.33/__react__/lib/ReactReconciler.js');
		var ReactUpdateQueue = require('react-native@0.33/__react__/lib/ReactUpdateQueue.js');
		var ReactUpdates = require('react-native@0.33/__react__/lib/ReactUpdates.js');

		var emptyObject = require('react-native@0.33/__fbjs__/lib/emptyObject.js');
		var instantiateReactComponent = require('react-native@0.33/__react__/lib/instantiateReactComponent.js');
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var setInnerHTML = __inner_require__(292 /*__react__/lib/setInnerHTML.js*/);
		var shouldUpdateReactComponent = require('react-native@0.33/__react__/lib/shouldUpdateReactComponent.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
		var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

		var ELEMENT_NODE_TYPE = 1;
		var DOC_NODE_TYPE = 9;
		var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

		var instancesByReactRootID = {};

		function firstDifferenceIndex(string1, string2) {
			var minLen = Math.min(string1.length, string2.length);
			for (var i = 0; i < minLen; i++) {
				if (string1.charAt(i) !== string2.charAt(i)) {
					return i;
				}
			}
			return string1.length === string2.length ? -1 : minLen;
		}

		function getReactRootElementInContainer(container) {
			if (!container) {
				return null;
			}

			if (container.nodeType === DOC_NODE_TYPE) {
				return container.documentElement;
			} else {
				return container.firstChild;
			}
		}

		function internalGetID(node) {

			return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
		}

		function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
			var markerName;
			if (ReactFeatureFlags.logTopLevelRenders) {
				var wrappedElement = wrapperInstance._currentElement.props;
				var type = wrappedElement.type;
				markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
				console.time(markerName);
			}

			var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0);

			if (markerName) {
				console.timeEnd(markerName);
			}

			wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
			ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
		}

		function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
			var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(!shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
			transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
			ReactUpdates.ReactReconcileTransaction.release(transaction);
		}

		function unmountComponentFromNode(instance, container, safely) {
			if (process.env.NODE_ENV !== 'production') {
				ReactInstrumentation.debugTool.onBeginFlush();
			}
			ReactReconciler.unmountComponent(instance, safely);
			if (process.env.NODE_ENV !== 'production') {
				ReactInstrumentation.debugTool.onEndFlush();
			}

			if (container.nodeType === DOC_NODE_TYPE) {
				container = container.documentElement;
			}

			while (container.lastChild) {
				container.removeChild(container.lastChild);
			}
		}

		function hasNonRootReactChild(container) {
			var rootEl = getReactRootElementInContainer(container);
			if (rootEl) {
				var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
				return !!(inst && inst._hostParent);
			}
		}

		function nodeIsRenderedByOtherInstance(container) {
			var rootEl = getReactRootElementInContainer(container);
			return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
		}

		function isValidContainer(node) {
			return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
		}

		function isReactNode(node) {
			return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
		}

		function getHostRootInstanceInContainer(container) {
			var rootEl = getReactRootElementInContainer(container);
			var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
			return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
		}

		function getTopLevelWrapperInContainer(container) {
			var root = getHostRootInstanceInContainer(container);
			return root ? root._hostContainerInfo._topLevelWrapper : null;
		}

		var topLevelRootCounter = 1;
		var TopLevelWrapper = function TopLevelWrapper() {
			this.rootID = topLevelRootCounter++;
		};
		TopLevelWrapper.prototype.isReactComponent = {};
		if (process.env.NODE_ENV !== 'production') {
			TopLevelWrapper.displayName = 'TopLevelWrapper';
		}
		TopLevelWrapper.prototype.render = function () {

			return this.props;
		};

		var ReactMount = {

			TopLevelWrapper: TopLevelWrapper,

			_instancesByReactRootID: instancesByReactRootID,

			scrollMonitor: function scrollMonitor(container, renderCallback) {
				renderCallback();
			},

			_updateRootComponent: function _updateRootComponent(prevComponent, nextElement, nextContext, container, callback) {
				ReactMount.scrollMonitor(container, function () {
					ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
					if (callback) {
						ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
					}
				});

				return prevComponent;
			},

			_renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {

				process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

				!isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

				ReactBrowserEventEmitter.ensureScrollValueMonitoring();
				var componentInstance = instantiateReactComponent(nextElement, false);

				ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

				var wrapperID = componentInstance._instance.rootID;
				instancesByReactRootID[wrapperID] = componentInstance;

				return componentInstance;
			},

			renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
				!(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
				return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
			},

			_renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
				ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
				!ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

				process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

				var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);

				var nextContext;
				if (parentComponent) {
					var parentInst = ReactInstanceMap.get(parentComponent);
					nextContext = parentInst._processChildContext(parentInst._context);
				} else {
					nextContext = emptyObject;
				}

				var prevComponent = getTopLevelWrapperInContainer(container);

				if (prevComponent) {
					var prevWrappedElement = prevComponent._currentElement;
					var prevElement = prevWrappedElement.props;
					if (shouldUpdateReactComponent(prevElement, nextElement)) {
						var publicInst = prevComponent._renderedComponent.getPublicInstance();
						var updatedCallback = callback && function () {
							callback.call(publicInst);
						};
						ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
						return publicInst;
					} else {
						ReactMount.unmountComponentAtNode(container);
					}
				}

				var reactRootElement = getReactRootElementInContainer(container);
				var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
				var containerHasNonRootReactChild = hasNonRootReactChild(container);

				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

					if (!containerHasReactMarkup || reactRootElement.nextSibling) {
						var rootElementSibling = reactRootElement;
						while (rootElementSibling) {
							if (internalGetID(rootElementSibling)) {
								process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
								break;
							}
							rootElementSibling = rootElementSibling.nextSibling;
						}
					}
				}

				var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
				var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
				if (callback) {
					callback.call(component);
				}
				return component;
			},

			render: function render(nextElement, container, callback) {
				return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
			},

			unmountComponentAtNode: function unmountComponentAtNode(container) {

				process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

				!isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

				if (process.env.NODE_ENV !== 'production') {
					process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
				}

				var prevComponent = getTopLevelWrapperInContainer(container);
				if (!prevComponent) {

					var containerHasNonRootReactChild = hasNonRootReactChild(container);

					var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

					if (process.env.NODE_ENV !== 'production') {
						process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
					}

					return false;
				}
				delete instancesByReactRootID[prevComponent._instance.rootID];
				ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
				return true;
			},

			_mountImageIntoNode: function _mountImageIntoNode(markup, container, instance, shouldReuseMarkup, transaction) {
				!isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

				if (shouldReuseMarkup) {
					var rootElement = getReactRootElementInContainer(container);
					if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
						ReactDOMComponentTree.precacheNode(instance, rootElement);
						return;
					} else {
						var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
						rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

						var rootMarkup = rootElement.outerHTML;
						rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

						var normalizedMarkup = markup;
						if (process.env.NODE_ENV !== 'production') {

							var normalizer;
							if (container.nodeType === ELEMENT_NODE_TYPE) {
								normalizer = document.createElement('div');
								normalizer.innerHTML = markup;
								normalizedMarkup = normalizer.innerHTML;
							} else {
								normalizer = document.createElement('iframe');
								document.body.appendChild(normalizer);
								normalizer.contentDocument.write(markup);
								normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
								document.body.removeChild(normalizer);
							}
						}

						var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
						var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

						!(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

						if (process.env.NODE_ENV !== 'production') {
							process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
						}
					}
				}

				!(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

				if (transaction.useCreateElement) {
					while (container.lastChild) {
						container.removeChild(container.lastChild);
					}
					DOMLazyTree.insertTreeBefore(container, markup, null);
				} else {
					setInnerHTML(container, markup);
					ReactDOMComponentTree.precacheNode(instance, container.firstChild);
				}

				if (process.env.NODE_ENV !== 'production') {
					var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
					if (hostNode._debugID !== 0) {
						ReactInstrumentation.debugTool.onHostOperation(hostNode._debugID, 'mount', markup.toString());
					}
				}
			} };

		module.exports = ReactMount;
	}, // __react__/lib/ReactDOMContainerInfo.js
	function (__inner_require__, exports, module) {
		var validateDOMNesting = __inner_require__(325 /*__react__/lib/validateDOMNesting.js*/);

		var DOC_NODE_TYPE = 9;

		function ReactDOMContainerInfo(topLevelWrapper, node) {
			var info = {
				_topLevelWrapper: topLevelWrapper,
				_idCounter: 1,
				_ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
				_node: node,
				_tag: node ? node.nodeName.toLowerCase() : null,
				_namespaceURI: node ? node.namespaceURI : null };

			if (process.env.NODE_ENV !== 'production') {
				info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
			}
			return info;
		}

		module.exports = ReactDOMContainerInfo;
	}, // __react__/lib/ReactDOMFeatureFlags.js
	function (__inner_require__, exports, module) {
		var ReactDOMFeatureFlags = {
			useCreateElement: true };

		module.exports = ReactDOMFeatureFlags;
	}, // __react__/lib/ReactMarkupChecksum.js
	function (__inner_require__, exports, module) {
		var adler32 = __inner_require__(358 /*__react__/lib/adler32.js*/);

		var TAG_END = /\/?>/;
		var COMMENT_START = /^<\!\-\-/;

		var ReactMarkupChecksum = {
			CHECKSUM_ATTR_NAME: 'data-react-checksum',

			addChecksumToMarkup: function addChecksumToMarkup(markup) {
				var checksum = adler32(markup);

				if (COMMENT_START.test(markup)) {
					return markup;
				} else {
					return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
				}
			},

			canReuseMarkup: function canReuseMarkup(markup, element) {
				var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
				existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
				var markupChecksum = adler32(markup);
				return markupChecksum === existingChecksum;
			} };

		module.exports = ReactMarkupChecksum;
	}, // __react__/lib/adler32.js
	function (__inner_require__, exports, module) {
		var MOD = 65521;

		function adler32(data) {
			var a = 1;
			var b = 0;
			var i = 0;
			var l = data.length;
			var m = l & ~0x3;
			while (i < m) {
				var n = Math.min(i + 4096, m);
				for (; i < n; i += 4) {
					b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
				}
				a %= MOD;
				b %= MOD;
			}
			for (; i < l; i++) {
				b += a += data.charCodeAt(i);
			}
			a %= MOD;
			b %= MOD;
			return a | b << 16;
		}

		module.exports = adler32;
	}, // __react__/lib/findDOMNode.js
	function (__inner_require__, exports, module) {
		var _prodInvariant = require('react-native@0.33/__react__/lib/reactProdInvariant.js');

		var ReactCurrentOwner = require('react-native@0.33/__react__/lib/ReactCurrentOwner.js');
		var ReactDOMComponentTree = __inner_require__(275 /*__react__/lib/ReactDOMComponentTree.js*/);
		var ReactInstanceMap = require('react-native@0.33/__react__/lib/ReactInstanceMap.js');

		var getHostComponentFromComposite = __inner_require__(360 /*__react__/lib/getHostComponentFromComposite.js*/);
		var invariant = require('react-native@0.33/__fbjs__/lib/invariant.js');
		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		function findDOMNode(componentOrElement) {
			if (process.env.NODE_ENV !== 'production') {
				var owner = ReactCurrentOwner.current;
				if (owner !== null) {
					process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
					owner._warnedAboutRefsInRender = true;
				}
			}
			if (componentOrElement == null) {
				return null;
			}
			if (componentOrElement.nodeType === 1) {
				return componentOrElement;
			}

			var inst = ReactInstanceMap.get(componentOrElement);
			if (inst) {
				inst = getHostComponentFromComposite(inst);
				return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
			}

			if (typeof componentOrElement.render === 'function') {
				!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
			} else {
				!false ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
			}
		}

		module.exports = findDOMNode;
	}, // __react__/lib/getHostComponentFromComposite.js
	function (__inner_require__, exports, module) {
		var ReactNodeTypes = require('react-native@0.33/__react__/lib/ReactNodeTypes.js');

		function getHostComponentFromComposite(inst) {
			var type;

			while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
				inst = inst._renderedComponent;
			}

			if (type === ReactNodeTypes.HOST) {
				return inst._renderedComponent;
			} else if (type === ReactNodeTypes.EMPTY) {
				return null;
			}
		}

		module.exports = getHostComponentFromComposite;
	}, // __react__/lib/renderSubtreeIntoContainer.js
	function (__inner_require__, exports, module) {
		var ReactMount = __inner_require__(354 /*__react__/lib/ReactMount.js*/);

		module.exports = ReactMount.renderSubtreeIntoContainer;
	}, // __react__/lib/ReactDOMUnknownPropertyHook.js
	function (__inner_require__, exports, module) {
		var DOMProperty = __inner_require__(276 /*__react__/lib/DOMProperty.js*/);
		var EventPluginRegistry = __inner_require__(58 /*__react__/lib/EventPluginRegistry.js*/);
		var ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		if (process.env.NODE_ENV !== 'production') {
			var reactProps = {
				children: true,
				dangerouslySetInnerHTML: true,
				key: true,
				ref: true,

				autoFocus: true,
				defaultValue: true,
				valueLink: true,
				defaultChecked: true,
				checkedLink: true,
				innerHTML: true,
				suppressContentEditableWarning: true,
				onFocusIn: true,
				onFocusOut: true };

			var warnedProperties = {};

			var validateProperty = function validateProperty(tagName, name, debugID) {
				if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
					return true;
				}
				if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
					return true;
				}
				if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
					return true;
				}
				warnedProperties[name] = true;
				var lowerCasedName = name.toLowerCase();

				var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

				var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

				if (standardName != null) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
					return true;
				} else if (registrationName != null) {
					process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
					return true;
				} else {

					return false;
				}
			};
		}

		var warnUnknownProperties = function warnUnknownProperties(debugID, element) {
			var unknownProps = [];
			for (var key in element.props) {
				var isValid = validateProperty(element.type, key, debugID);
				if (!isValid) {
					unknownProps.push(key);
				}
			}

			var unknownPropString = unknownProps.map(function (prop) {
				return '`' + prop + '`';
			}).join(', ');

			if (unknownProps.length === 1) {
				process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
			} else if (unknownProps.length > 1) {
				process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
			}
		};

		function handleElement(debugID, element) {
			if (element == null || typeof element.type !== 'string') {
				return;
			}
			if (element.type.indexOf('-') >= 0 || element.props.is) {
				return;
			}
			warnUnknownProperties(debugID, element);
		}

		var ReactDOMUnknownPropertyHook = {
			onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
				handleElement(debugID, element);
			},
			onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
				handleElement(debugID, element);
			} };

		module.exports = ReactDOMUnknownPropertyHook;
	}, // __react__/lib/ReactDOMNullInputValuePropHook.js
	function (__inner_require__, exports, module) {
		var ReactComponentTreeHook = require('react-native@0.33/__react__/lib/ReactComponentTreeHook.js');

		var warning = require('react-native@0.33/__fbjs__/lib/warning.js');

		var didWarnValueNull = false;

		function handleElement(debugID, element) {
			if (element == null) {
				return;
			}
			if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
				return;
			}
			if (element.props != null && element.props.value === null && !didWarnValueNull) {
				process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

				didWarnValueNull = true;
			}
		}

		var ReactDOMNullInputValuePropHook = {
			onBeforeMountComponent: function onBeforeMountComponent(debugID, element) {
				handleElement(debugID, element);
			},
			onBeforeUpdateComponent: function onBeforeUpdateComponent(debugID, element) {
				handleElement(debugID, element);
			} };

		module.exports = ReactDOMNullInputValuePropHook;
	}];
});