使用glob定义入口文件
以入口文件作为入口开始打包
打包时，对于依赖文件，如果依赖文件是入口文件或者当前项目被超过2个及以上入口文件依赖的，独立打包，否则打包进当前包
单个包内，打包进来的依赖模块ID转换为数字
独立包文件名及ID转换为文件的md5值
对入口文件生成一个路径与模块id的对应表
对于业务项目，版本号一般使用自动升级次级版本方式生成
config(modName@version, {
	"a/b/c": "dajfjalkdjlf",
	...
}
对于当前项目中引用的独立文件，require(a/b/c)=>require(dajfjalkdjlf)
每个项目发布成npm 包，打包时对于npm文件，按照以下规则转换require的地址：
依赖模块的版本规则：
	锁死版本：
		例如1.1.1
		进入该模块进行打包时，发布到modName/1.1.1/目录下
		require("modName@1.1.1/a/b/c")
		=>经过入口文件对应表转换
		=>require("modName@1.1.1/dajfjalkdjlf")
	自动升级修订版本
		例如^1.1.1
		进入该模块进行打包时，发布到modName/1.1/目录下
		require("modName@1.1/a/b/c")
		=>经过入口文件对应表转换
		=>require("modName@1.1/dajfjalkdjlf")
	自动升级次级版本
		例如~1.1.1
		进入该模块进行打包时，发布到modName/1/目录下
		require("modName@1/a/b/c")
		=>经过入口文件对应表转换
		=>require("modName@1/dajfjalkdjlf")
所有入口文件提取同步静态依赖到顶层，分析出所使用到的所有项目，加载这些项目下的入口文件对应表
为了解决深度依赖版本更新灾难，对于外部项目的非锁死依赖，依赖ID使用真实路径，运行时根据对应表解析出真实ID，对于锁死的依赖，就直接编译时转换为md5模块名了
define("dajfjalkdjlf", ["adlajdfa", "dkflad", "abc@2.1/a/c", "ddd@1.6.2/ls/dfd"], function(){})

目前的问题，当粒度太细时，顶层模块分析出来的依赖会太大
为了解决这个问题，入口文件只显示直接依赖，对于深度依赖项不写在文件里，独立生成一个依赖列表文件，页面引入时，引入这个依赖列表文件，比较本地存储，进行过滤，以生成请求url

页面中使用
加入当前项目是aaa@1，依赖了bbb@1.2、ccc@2.1、ddd@1.6.3
对应表文件需要md5版本值
request ss.elong.com/static/??bbb@1.2@dafadf/__hash,ccc@2.1@dfadfa（如果没有依赖外部项目，则不需要这个请求，对于锁死的版本，不需要）
loader.load([aaa@1/adfad, aaa@1/dfad, bbb@1.2/a/b/c, bbb@1.2/dd/sd, ccc@2.1/df/ee/df])

以递增64进制作为版本号，替换md5版本号